{"version":3,"sources":["webpack:///test.js","webpack:///webpack/bootstrap ecf7139b4982c612b5f0?8bd3","webpack:///./test/entry.js","webpack:///./~/whatwg-fetch/fetch.js?cba3","webpack:///./src/vars.js?0900","webpack:///./src/utils.js?2ff8","webpack:///./src/api.js?9f94","webpack:///./~/loglevel/lib/loglevel.js?dceb","webpack:///./test/api.js","webpack:///./~/chai/index.js","webpack:///./~/chai/lib/chai.js","webpack:///./~/assertion-error/index.js","webpack:///./~/chai/lib/chai/utils/index.js","webpack:///./~/chai/lib/chai/utils/test.js","webpack:///./~/chai/lib/chai/utils/flag.js","webpack:///./~/type-detect/lib/type.js","webpack:///./~/chai/lib/chai/utils/expectTypes.js","webpack:///./~/chai/lib/chai/utils/getMessage.js","webpack:///./~/chai/lib/chai/utils/getActual.js","webpack:///./~/chai/lib/chai/utils/inspect.js","webpack:///./~/chai/lib/chai/utils/getName.js","webpack:///./~/chai/lib/chai/utils/getProperties.js","webpack:///./~/chai/lib/chai/utils/getEnumerableProperties.js","webpack:///./~/chai/lib/chai/utils/objDisplay.js","webpack:///./~/chai/lib/chai/config.js","webpack:///./~/chai/lib/chai/utils/transferFlags.js","webpack:///./~/deep-eql/index.js","webpack:///./~/deep-eql/lib/eql.js","webpack:///./~/deep-eql/~/type-detect/lib/type.js","webpack:///./~/buffer/index.js","webpack:///./~/base64-js/lib/b64.js","webpack:///./~/ieee754/index.js","webpack:///./~/is-array/index.js","webpack:///./~/chai/lib/chai/utils/getPathValue.js","webpack:///./~/chai/lib/chai/utils/getPathInfo.js","webpack:///./~/chai/lib/chai/utils/hasProperty.js","webpack:///./~/chai/lib/chai/utils/addProperty.js","webpack:///./~/chai/lib/chai/utils/addMethod.js","webpack:///./~/chai/lib/chai/utils/overwriteProperty.js","webpack:///./~/chai/lib/chai/utils/overwriteMethod.js","webpack:///./~/chai/lib/chai/utils/addChainableMethod.js","webpack:///./~/chai/lib/chai/utils/overwriteChainableMethod.js","webpack:///./~/chai/lib/chai/assertion.js","webpack:///./~/chai/lib/chai/core/assertions.js","webpack:///./~/chai/lib/chai/interface/expect.js","webpack:///./~/chai/lib/chai/interface/should.js","webpack:///./~/chai/lib/chai/interface/assert.js","webpack:///./test/vars.js","webpack:///./~/type-detect/index.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","i","Object","prototype","hasOwnProperty","_m","args","slice","fn","a","b","apply","this","concat","global","normalizeName","name","String","test","TypeError","toLowerCase","normalizeValue","value","Headers","headers","map","forEach","append","getOwnPropertyNames","consumed","body","bodyUsed","Promise","reject","fileReaderReady","reader","resolve","onload","result","onerror","error","readBlobAsArrayBuffer","blob","FileReader","readAsArrayBuffer","readBlobAsText","readAsText","Body","_initBody","_bodyInit","_bodyText","support","Blob","isPrototypeOf","_bodyBlob","formData","FormData","_bodyFormData","arrayBuffer","ArrayBuffer","Error","rejected","then","text","decode","json","JSON","parse","normalizeMethod","method","upcased","toUpperCase","methods","indexOf","Request","input","options","url","credentials","mode","referrer","form","trim","split","bytes","shift","replace","join","decodeURIComponent","xhr","head","pairs","getAllResponseHeaders","header","key","Response","bodyInit","type","status","ok","statusText","self","fetch","list","push","get","values","getAll","has","set","callback","thisArg","e","clone","response","redirectStatuses","redirect","RangeError","location","init","responseURL","getResponseHeader","request","XMLHttpRequest","responseText","open","withCredentials","responseType","setRequestHeader","send","polyfill","defineProperty","HOST_URL","PROD_HOST","DEV_HOST","undefined","_utils","isDev","getHumanizedTimeDuration","timeDurationInMilliseconds","addPluralSuffix","number","duration","Math","floor","years","days","hours","minutes","seconds","isServiceWorkerContext","window","_interopRequireDefault","obj","__esModule","default","apiCall","action","data","contents","cache","stringify","_vars","sendNotification","appId","playerIds","titles","params","app_id","headings","include_player_ids","isAnyWeb","_loglevel","_loglevel2","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","root","definition","log","realMethod","methodName","console","undefinedType","bindMethod","noop","bind","Function","arguments","enableLoggingWhenConsoleArrives","level","loggerName","replaceLoggingMethods","logMethods","length","methodFactory","defaultMethodFactory","Logger","defaultLevel","factory","persistLevelIfPossible","levelNum","levelName","localStorage","storageKey","ignore","document","cookie","encodeURIComponent","getPersistedLevel","storedLevel","exec","levels","currentLevel","TRACE","DEBUG","INFO","WARN","ERROR","SILENT","getLevel","setLevel","persist","setDefaultLevel","enableAll","disableAll","initialLevel","defaultLogger","_loggersByName","getLogger","logger","_log","noConflict","_chai","_chai2","_api","describe","it","should","eventually","be","rejectedWith","APP_ID","en","PLAYER_ID","fulfilled","used","version","AssertionError","util","use","config","assertion","core","expect","assert","exclude","excludeProps","res","keys","excludes","extendExclude","message","_props","ssf","extend","props","showDiff","callee","captureStackTrace","stack","create","constructor","toJSON","expectTypes","getMessage","getActual","inspect","objDisplay","flag","transferFlags","eql","getPathValue","getPathInfo","hasProperty","getName","addProperty","addMethod","overwriteProperty","overwriteMethod","addChainableMethod","overwriteChainableMethod","negate","expr","flags","__flags","getType","toString","match","objectTypeRegexp","Library","tests","of","define","ReferenceError","types","t","sort","str","index","art","charAt","or","some","expected","val","actual","msg","flagMsg","_obj","showHidden","depth","colors","ctx","seen","stylize","formatValue","recurseTimes","ret","primitive","formatPrimitive","isDOMElement","outerHTML","xmlVersion","xmlSerializer","XMLSerializer","serializeToString","ns","container","createElementNS","appendChild","cloneNode","html","innerHTML","err","visibleKeys","getEnumerableProperties","getProperties","isError","nameSuffix","isRegExp","RegExp","isDate","Date","toUTCString","formatError","base","array","braces","isArray","output","formatArray","formatProperty","pop","reduceToSingleString","simple","Infinity","l","__lookupGetter__","__lookupSetter__","line","substr","numLinesEst","reduce","prev","cur","ar","Array","objectToString","re","d","o","object","HTMLElement","nodeType","nodeName","func","property","proto","getPrototypeOf","truncateThreshold","kstr","splice","includeStack","includeAll","deepEqual","sameValue","dateEqual","regexpEqual","Buffer","isBuffer","bufferEqual","argumentsEqual","typeEqual","objectEqual","getTime","enumerable","iterableEqual","isValue","ka","kb","ex","natives","[object Array]","[object RegExp]","[object Function]","[object Arguments]","[object Date]","typedArraySupport","Bar","arr","Uint8Array","foo","subarray","byteLength","kMaxLength","TYPED_ARRAY_SUPPORT","arg","parent","fromNumber","fromString","fromObject","that","allocate","checked","string","encoding","write","fromBuffer","fromArray","buffer","fromTypedArray","fromArrayBuffer","fromArrayLike","fromJsonObject","copy","_augment","__proto__","_isBuffer","fromPool","poolSize","rootParent","SlowBuffer","subject","buf","len","loweredCase","utf8ToBytes","base64ToBytes","slowToString","start","end","hexSlice","utf8Slice","asciiSlice","binarySlice","base64Slice","utf16leSlice","hexWrite","offset","Number","remaining","strLen","parsed","parseInt","isNaN","utf8Write","blitBuffer","asciiWrite","asciiToBytes","binaryWrite","base64Write","ucs2Write","utf16leToBytes","base64","fromByteArray","min","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","decodeCodePointsArray","codePoints","MAX_ARGUMENTS_LENGTH","fromCharCode","out","toHex","checkOffset","ext","checkInt","max","objectWriteUInt16","littleEndian","j","objectWriteUInt32","checkIEEE754","writeFloat","noAssert","ieee754","writeDouble","base64clean","stringtrim","INVALID_BASE64_RE","n","units","leadSurrogate","charCodeAt","byteArray","hi","lo","toByteArray","src","dst","INSPECT_MAX_BYTES","compare","x","y","isEncoding","pos","item","equals","byteOffset","arrayIndexOf","foundIndex","readUInt8","v","writeUInt8","isFinite","swap","_arr","newBuf","sliceLen","readUIntLE","mul","readUIntBE","readUInt16LE","readUInt16BE","readUInt32LE","readUInt32BE","readIntLE","pow","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","read","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","writeUIntBE","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","target","targetStart","_set","fill","toArrayBuffer","BP","toLocaleString","lookup","elt","code","PLUS","PLUS_URL_SAFE","SLASH","SLASH_URL_SAFE","NUMBER","UPPER","LOWER","b64ToByteArray","b64","L","tmp","placeHolders","Arr","uint8ToBase64","uint8","encode","num","tripletToBase64","extraBytes","temp","base64js","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","s","NaN","rt","abs","LN2","path","info","parsePath","parts","mArr","parseFloat","_getPathValue","part","last","exists","literals","ot","getter","old_ssfi","configurable","_get","getOwnPropertyDescriptor","_super","_method","hasProtoSupport","excludeNames","chainingBehavior","chainableBehavior","__methods","asserterNames","asserterName","pd","_chainingBehavior","Assertion","warn","negateMsg","_actual","chai","_","an","article","includeChainingBehavior","include","k","subset","checkArguments","assertEqual","assertEql","assertAbove","to","have","assertLeast","assertBelow","assertMost","assertInstanceOf","assertOwnProperty","assertOwnPropertyDescriptor","descriptor","actualDescriptor","assertLengthChain","assertLength","assertMatch","assertKeys","mixedArgsMsg","any","all","intersection","filter","every","assertThrows","errMsg","is","thrown","desiredError","thrownError","actuallyGot","expectedThrown","respondTo","itself","context","satisfy","matcher","closeTo","delta","isSubsetOf","superset","cmp","elem","elem2","oneOf","assertChanges","prop","initial","assertIncreases","assertDecreases","chain","finish","range","isDeep","pathInfo","isExtensible","isSealed","isFrozen","fail","operator","loadShould","shouldGetter","Boolean","valueOf","shouldSetter","writable","equal","val1","val2","Throw","errt","errs","exist","not","Should","express","errmsg","isOk","isNotOk","act","exp","notEqual","strictEqual","notStrictEqual","notDeepEqual","isAbove","abv","above","isAtLeast","atlst","least","isBelow","blw","below","isAtMost","atmst","most","isTrue","isNotTrue","isFalse","isNotFalse","isNull","isNotNull","isNotNaN","isUndefined","isDefined","isFunction","isNotFunction","isObject","isNotObject","isNotArray","isString","isNotString","isNumber","isNotNumber","isBoolean","isNotBoolean","typeOf","notTypeOf","instanceOf","notInstanceOf","inc","notInclude","notMatch","notProperty","deepProperty","deep","notDeepProperty","propertyVal","propertyNotVal","deepPropertyVal","deepPropertyNotVal","lengthOf","assertErr","doesNotThrow","approximately","sameMembers","set1","set2","same","members","sameDeepMembers","includeMembers","inList","changes","change","doesNotChange","increases","increase","doesNotIncrease","decreases","decrease","doesNotDecrease","ifError","extensible","isNotExtensible","sealed","isNotSealed","frozen","isNotFrozen","alias","as","__webpack_module_template_argument_0__"],"mappings":"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","file":"test.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ((function(modules) {\n\t// Check all modules for deduplicated modules\n\tfor(var i in modules) {\n\t\tif(Object.prototype.hasOwnProperty.call(modules, i)) {\n\t\t\tswitch(typeof modules[i]) {\n\t\t\tcase \"function\": break;\n\t\t\tcase \"object\":\n\t\t\t\t// Module can be created from a template\n\t\t\t\tmodules[i] = (function(_m) {\n\t\t\t\t\tvar args = _m.slice(1), fn = modules[_m[0]];\n\t\t\t\t\treturn function (a,b,c) {\n\t\t\t\t\t\tfn.apply(this, [a,b,c].concat(args));\n\t\t\t\t\t};\n\t\t\t\t}(modules[i]));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// Module is a copy of another module\n\t\t\t\tmodules[i] = modules[modules[i]];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn modules;\n}([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t__webpack_require__(10);\n\n/***/ },\n/* 1 */,\n/* 2 */,\n/* 3 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/*** IMPORTS FROM imports-loader ***/\n\t(function() {\n\t\n\t(function() {\n\t  'use strict';\n\t\n\t  if (self.fetch) {\n\t    return\n\t  }\n\t\n\t  function normalizeName(name) {\n\t    if (typeof name !== 'string') {\n\t      name = String(name)\n\t    }\n\t    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n\t      throw new TypeError('Invalid character in header field name')\n\t    }\n\t    return name.toLowerCase()\n\t  }\n\t\n\t  function normalizeValue(value) {\n\t    if (typeof value !== 'string') {\n\t      value = String(value)\n\t    }\n\t    return value\n\t  }\n\t\n\t  function Headers(headers) {\n\t    this.map = {}\n\t\n\t    if (headers instanceof Headers) {\n\t      headers.forEach(function(value, name) {\n\t        this.append(name, value)\n\t      }, this)\n\t\n\t    } else if (headers) {\n\t      Object.getOwnPropertyNames(headers).forEach(function(name) {\n\t        this.append(name, headers[name])\n\t      }, this)\n\t    }\n\t  }\n\t\n\t  Headers.prototype.append = function(name, value) {\n\t    name = normalizeName(name)\n\t    value = normalizeValue(value)\n\t    var list = this.map[name]\n\t    if (!list) {\n\t      list = []\n\t      this.map[name] = list\n\t    }\n\t    list.push(value)\n\t  }\n\t\n\t  Headers.prototype['delete'] = function(name) {\n\t    delete this.map[normalizeName(name)]\n\t  }\n\t\n\t  Headers.prototype.get = function(name) {\n\t    var values = this.map[normalizeName(name)]\n\t    return values ? values[0] : null\n\t  }\n\t\n\t  Headers.prototype.getAll = function(name) {\n\t    return this.map[normalizeName(name)] || []\n\t  }\n\t\n\t  Headers.prototype.has = function(name) {\n\t    return this.map.hasOwnProperty(normalizeName(name))\n\t  }\n\t\n\t  Headers.prototype.set = function(name, value) {\n\t    this.map[normalizeName(name)] = [normalizeValue(value)]\n\t  }\n\t\n\t  Headers.prototype.forEach = function(callback, thisArg) {\n\t    Object.getOwnPropertyNames(this.map).forEach(function(name) {\n\t      this.map[name].forEach(function(value) {\n\t        callback.call(thisArg, value, name, this)\n\t      }, this)\n\t    }, this)\n\t  }\n\t\n\t  function consumed(body) {\n\t    if (body.bodyUsed) {\n\t      return Promise.reject(new TypeError('Already read'))\n\t    }\n\t    body.bodyUsed = true\n\t  }\n\t\n\t  function fileReaderReady(reader) {\n\t    return new Promise(function(resolve, reject) {\n\t      reader.onload = function() {\n\t        resolve(reader.result)\n\t      }\n\t      reader.onerror = function() {\n\t        reject(reader.error)\n\t      }\n\t    })\n\t  }\n\t\n\t  function readBlobAsArrayBuffer(blob) {\n\t    var reader = new FileReader()\n\t    reader.readAsArrayBuffer(blob)\n\t    return fileReaderReady(reader)\n\t  }\n\t\n\t  function readBlobAsText(blob) {\n\t    var reader = new FileReader()\n\t    reader.readAsText(blob)\n\t    return fileReaderReady(reader)\n\t  }\n\t\n\t  var support = {\n\t    blob: 'FileReader' in self && 'Blob' in self && (function() {\n\t      try {\n\t        new Blob();\n\t        return true\n\t      } catch(e) {\n\t        return false\n\t      }\n\t    })(),\n\t    formData: 'FormData' in self,\n\t    arrayBuffer: 'ArrayBuffer' in self\n\t  }\n\t\n\t  function Body() {\n\t    this.bodyUsed = false\n\t\n\t\n\t    this._initBody = function(body) {\n\t      this._bodyInit = body\n\t      if (typeof body === 'string') {\n\t        this._bodyText = body\n\t      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n\t        this._bodyBlob = body\n\t      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n\t        this._bodyFormData = body\n\t      } else if (!body) {\n\t        this._bodyText = ''\n\t      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {\n\t        // Only support ArrayBuffers for POST method.\n\t        // Receiving ArrayBuffers happens via Blobs, instead.\n\t      } else {\n\t        throw new Error('unsupported BodyInit type')\n\t      }\n\t    }\n\t\n\t    if (support.blob) {\n\t      this.blob = function() {\n\t        var rejected = consumed(this)\n\t        if (rejected) {\n\t          return rejected\n\t        }\n\t\n\t        if (this._bodyBlob) {\n\t          return Promise.resolve(this._bodyBlob)\n\t        } else if (this._bodyFormData) {\n\t          throw new Error('could not read FormData body as blob')\n\t        } else {\n\t          return Promise.resolve(new Blob([this._bodyText]))\n\t        }\n\t      }\n\t\n\t      this.arrayBuffer = function() {\n\t        return this.blob().then(readBlobAsArrayBuffer)\n\t      }\n\t\n\t      this.text = function() {\n\t        var rejected = consumed(this)\n\t        if (rejected) {\n\t          return rejected\n\t        }\n\t\n\t        if (this._bodyBlob) {\n\t          return readBlobAsText(this._bodyBlob)\n\t        } else if (this._bodyFormData) {\n\t          throw new Error('could not read FormData body as text')\n\t        } else {\n\t          return Promise.resolve(this._bodyText)\n\t        }\n\t      }\n\t    } else {\n\t      this.text = function() {\n\t        var rejected = consumed(this)\n\t        return rejected ? rejected : Promise.resolve(this._bodyText)\n\t      }\n\t    }\n\t\n\t    if (support.formData) {\n\t      this.formData = function() {\n\t        return this.text().then(decode)\n\t      }\n\t    }\n\t\n\t    this.json = function() {\n\t      return this.text().then(JSON.parse)\n\t    }\n\t\n\t    return this\n\t  }\n\t\n\t  // HTTP methods whose capitalization should be normalized\n\t  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\t\n\t  function normalizeMethod(method) {\n\t    var upcased = method.toUpperCase()\n\t    return (methods.indexOf(upcased) > -1) ? upcased : method\n\t  }\n\t\n\t  function Request(input, options) {\n\t    options = options || {}\n\t    var body = options.body\n\t    if (Request.prototype.isPrototypeOf(input)) {\n\t      if (input.bodyUsed) {\n\t        throw new TypeError('Already read')\n\t      }\n\t      this.url = input.url\n\t      this.credentials = input.credentials\n\t      if (!options.headers) {\n\t        this.headers = new Headers(input.headers)\n\t      }\n\t      this.method = input.method\n\t      this.mode = input.mode\n\t      if (!body) {\n\t        body = input._bodyInit\n\t        input.bodyUsed = true\n\t      }\n\t    } else {\n\t      this.url = input\n\t    }\n\t\n\t    this.credentials = options.credentials || this.credentials || 'omit'\n\t    if (options.headers || !this.headers) {\n\t      this.headers = new Headers(options.headers)\n\t    }\n\t    this.method = normalizeMethod(options.method || this.method || 'GET')\n\t    this.mode = options.mode || this.mode || null\n\t    this.referrer = null\n\t\n\t    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n\t      throw new TypeError('Body not allowed for GET or HEAD requests')\n\t    }\n\t    this._initBody(body)\n\t  }\n\t\n\t  Request.prototype.clone = function() {\n\t    return new Request(this)\n\t  }\n\t\n\t  function decode(body) {\n\t    var form = new FormData()\n\t    body.trim().split('&').forEach(function(bytes) {\n\t      if (bytes) {\n\t        var split = bytes.split('=')\n\t        var name = split.shift().replace(/\\+/g, ' ')\n\t        var value = split.join('=').replace(/\\+/g, ' ')\n\t        form.append(decodeURIComponent(name), decodeURIComponent(value))\n\t      }\n\t    })\n\t    return form\n\t  }\n\t\n\t  function headers(xhr) {\n\t    var head = new Headers()\n\t    var pairs = xhr.getAllResponseHeaders().trim().split('\\n')\n\t    pairs.forEach(function(header) {\n\t      var split = header.trim().split(':')\n\t      var key = split.shift().trim()\n\t      var value = split.join(':').trim()\n\t      head.append(key, value)\n\t    })\n\t    return head\n\t  }\n\t\n\t  Body.call(Request.prototype)\n\t\n\t  function Response(bodyInit, options) {\n\t    if (!options) {\n\t      options = {}\n\t    }\n\t\n\t    this._initBody(bodyInit)\n\t    this.type = 'default'\n\t    this.status = options.status\n\t    this.ok = this.status >= 200 && this.status < 300\n\t    this.statusText = options.statusText\n\t    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)\n\t    this.url = options.url || ''\n\t  }\n\t\n\t  Body.call(Response.prototype)\n\t\n\t  Response.prototype.clone = function() {\n\t    return new Response(this._bodyInit, {\n\t      status: this.status,\n\t      statusText: this.statusText,\n\t      headers: new Headers(this.headers),\n\t      url: this.url\n\t    })\n\t  }\n\t\n\t  Response.error = function() {\n\t    var response = new Response(null, {status: 0, statusText: ''})\n\t    response.type = 'error'\n\t    return response\n\t  }\n\t\n\t  var redirectStatuses = [301, 302, 303, 307, 308]\n\t\n\t  Response.redirect = function(url, status) {\n\t    if (redirectStatuses.indexOf(status) === -1) {\n\t      throw new RangeError('Invalid status code')\n\t    }\n\t\n\t    return new Response(null, {status: status, headers: {location: url}})\n\t  }\n\t\n\t  self.Headers = Headers;\n\t  self.Request = Request;\n\t  self.Response = Response;\n\t\n\t  self.fetch = function(input, init) {\n\t    return new Promise(function(resolve, reject) {\n\t      var request\n\t      if (Request.prototype.isPrototypeOf(input) && !init) {\n\t        request = input\n\t      } else {\n\t        request = new Request(input, init)\n\t      }\n\t\n\t      var xhr = new XMLHttpRequest()\n\t\n\t      function responseURL() {\n\t        if ('responseURL' in xhr) {\n\t          return xhr.responseURL\n\t        }\n\t\n\t        // Avoid security warnings on getResponseHeader when not allowed by CORS\n\t        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n\t          return xhr.getResponseHeader('X-Request-URL')\n\t        }\n\t\n\t        return;\n\t      }\n\t\n\t      xhr.onload = function() {\n\t        var status = (xhr.status === 1223) ? 204 : xhr.status\n\t        if (status < 100 || status > 599) {\n\t          reject(new TypeError('Network request failed'))\n\t          return\n\t        }\n\t        var options = {\n\t          status: status,\n\t          statusText: xhr.statusText,\n\t          headers: headers(xhr),\n\t          url: responseURL()\n\t        }\n\t        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n\t        resolve(new Response(body, options))\n\t      }\n\t\n\t      xhr.onerror = function() {\n\t        reject(new TypeError('Network request failed'))\n\t      }\n\t\n\t      xhr.open(request.method, request.url, true)\n\t\n\t      if (request.credentials === 'include') {\n\t        xhr.withCredentials = true\n\t      }\n\t\n\t      if ('responseType' in xhr && support.blob) {\n\t        xhr.responseType = 'blob'\n\t      }\n\t\n\t      request.headers.forEach(function(value, name) {\n\t        xhr.setRequestHeader(name, value)\n\t      })\n\t\n\t      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n\t    })\n\t  }\n\t  self.fetch.polyfill = true\n\t})();\n\t\n\t\n\t/*** EXPORTS FROM exports-loader ***/\n\tmodule.exports = global.fetch\n\t}.call(global));\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.HOST_URL = exports.PROD_HOST = exports.DEV_HOST = undefined;\n\t\n\tvar _utils = __webpack_require__(5);\n\t\n\tvar DEV_HOST = exports.DEV_HOST = 'https://192.168.1.206:3000';\n\tvar PROD_HOST = exports.PROD_HOST = 'https://onesignal.com';\n\tvar HOST_URL = exports.HOST_URL = ((0, _utils.isDev)() ? DEV_HOST : PROD_HOST) + '/api/v1/';\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.getHumanizedTimeDuration = getHumanizedTimeDuration;\n\texports.isServiceWorkerContext = isServiceWorkerContext;\n\texports.isDev = isDev;\n\tfunction getHumanizedTimeDuration(timeDurationInMilliseconds) {\n\t  function addPluralSuffix(number) {\n\t    return number > 1 ? 's' : '';\n\t  }\n\t  var duration = Math.floor(timeDurationInMilliseconds / 1000);\n\t\n\t  var years = Math.floor(duration / 31536000);\n\t  if (years) return years + ' year' + addPluralSuffix(years);\n\t\n\t  var days = Math.floor((duration %= 31536000) / 86400);\n\t  if (days) return days + ' day' + addPluralSuffix(days);\n\t\n\t  var hours = Math.floor((duration %= 86400) / 3600);\n\t  if (hours) return hours + ' hour' + addPluralSuffix(hours);\n\t\n\t  var minutes = Math.floor((duration %= 3600) / 60);\n\t  if (minutes) return minutes + ' minute' + addPluralSuffix(minutes);\n\t\n\t  var seconds = duration % 60;\n\t  if (seconds) return seconds + ' second' + addPluralSuffix(seconds);\n\t\n\t  return 'just now';\n\t}\n\t\n\tfunction isServiceWorkerContext() {\n\t  return typeof window === \"undefined\";\n\t}\n\t\n\tfunction isDev() {\n\t  return (false);\n\t}\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(fetch) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.apiCall = apiCall;\n\texports.sendNotification = sendNotification;\n\t\n\tvar _vars = __webpack_require__(4);\n\t\n\tvar _loglevel = __webpack_require__(7);\n\t\n\tvar _loglevel2 = _interopRequireDefault(_loglevel);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction apiCall(action, method, data) {\n\t  var headers = new Headers();\n\t  headers.append('Content-Type', 'application/json;charset=UTF-8');\n\t\n\t  var contents = {\n\t    method: method || 'NO_METHOD_SPECIFIED',\n\t    headers: headers,\n\t    cache: 'no-cache',\n\t    body: JSON.stringify(data)\n\t  };\n\t\n\t  return new Promise(function (resolve, reject) {\n\t    fetch(_vars.HOST_URL + action, contents).then(function status(response) {\n\t      if (response.status >= 200 && response.status < 300) resolve(response.json());else reject(new Error(response.statusText));\n\t    }).catch(function (e) {\n\t      reject(e);\n\t    });\n\t  });\n\t}\n\t\n\tfunction sendNotification(appId, playerIds, titles, contents) {\n\t  var params = {\n\t    'app_id': appId,\n\t    'headings': titles,\n\t    'contents': contents,\n\t    'include_player_ids': playerIds,\n\t    'isAnyWeb': true,\n\t    'url': 'javascript:void(0);'\n\t  };\n\t  return apiCall('notifications', 'POST', params);\n\t}\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\r\n\t* loglevel - https://github.com/pimterry/loglevel\r\n\t*\r\n\t* Copyright (c) 2013 Tim Perry\r\n\t* Licensed under the MIT license.\r\n\t*/\r\n\t(function (root, definition) {\r\n\t    \"use strict\";\r\n\t    if (typeof module === 'object' && module.exports && \"function\" === 'function') {\r\n\t        module.exports = definition();\r\n\t    } else if (true) {\r\n\t        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t    } else {\r\n\t        root.log = definition();\r\n\t    }\r\n\t}(this, function () {\r\n\t    \"use strict\";\r\n\t    var noop = function() {};\r\n\t    var undefinedType = \"undefined\";\r\n\t\r\n\t    function realMethod(methodName) {\r\n\t        if (typeof console === undefinedType) {\r\n\t            return false; // We can't build a real method without a console to log to\r\n\t        } else if (console[methodName] !== undefined) {\r\n\t            return bindMethod(console, methodName);\r\n\t        } else if (console.log !== undefined) {\r\n\t            return bindMethod(console, 'log');\r\n\t        } else {\r\n\t            return noop;\r\n\t        }\r\n\t    }\r\n\t\r\n\t    function bindMethod(obj, methodName) {\r\n\t        var method = obj[methodName];\r\n\t        if (typeof method.bind === 'function') {\r\n\t            return method.bind(obj);\r\n\t        } else {\r\n\t            try {\r\n\t                return Function.prototype.bind.call(method, obj);\r\n\t            } catch (e) {\r\n\t                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\r\n\t                return function() {\r\n\t                    return Function.prototype.apply.apply(method, [obj, arguments]);\r\n\t                };\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t\r\n\t    // these private functions always need `this` to be set properly\r\n\t\r\n\t    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\r\n\t        return function () {\r\n\t            if (typeof console !== undefinedType) {\r\n\t                replaceLoggingMethods.call(this, level, loggerName);\r\n\t                this[methodName].apply(this, arguments);\r\n\t            }\r\n\t        };\r\n\t    }\r\n\t\r\n\t    function replaceLoggingMethods(level, loggerName) {\r\n\t        /*jshint validthis:true */\r\n\t        for (var i = 0; i < logMethods.length; i++) {\r\n\t            var methodName = logMethods[i];\r\n\t            this[methodName] = (i < level) ?\r\n\t                noop :\r\n\t                this.methodFactory(methodName, level, loggerName);\r\n\t        }\r\n\t    }\r\n\t\r\n\t    function defaultMethodFactory(methodName, level, loggerName) {\r\n\t        /*jshint validthis:true */\r\n\t        return realMethod(methodName) ||\r\n\t               enableLoggingWhenConsoleArrives.apply(this, arguments);\r\n\t    }\r\n\t\r\n\t    var logMethods = [\r\n\t        \"trace\",\r\n\t        \"debug\",\r\n\t        \"info\",\r\n\t        \"warn\",\r\n\t        \"error\"\r\n\t    ];\r\n\t\r\n\t    function Logger(name, defaultLevel, factory) {\r\n\t      var self = this;\r\n\t      var currentLevel;\r\n\t      var storageKey = \"loglevel\";\r\n\t      if (name) {\r\n\t        storageKey += \":\" + name;\r\n\t      }\r\n\t\r\n\t      function persistLevelIfPossible(levelNum) {\r\n\t          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\r\n\t\r\n\t          // Use localStorage if available\r\n\t          try {\r\n\t              window.localStorage[storageKey] = levelName;\r\n\t              return;\r\n\t          } catch (ignore) {}\r\n\t\r\n\t          // Use session cookie as fallback\r\n\t          try {\r\n\t              window.document.cookie =\r\n\t                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\r\n\t          } catch (ignore) {}\r\n\t      }\r\n\t\r\n\t      function getPersistedLevel() {\r\n\t          var storedLevel;\r\n\t\r\n\t          try {\r\n\t              storedLevel = window.localStorage[storageKey];\r\n\t          } catch (ignore) {}\r\n\t\r\n\t          if (typeof storedLevel === undefinedType) {\r\n\t              try {\r\n\t                  var cookie = window.document.cookie;\r\n\t                  var location = cookie.indexOf(\r\n\t                      encodeURIComponent(storageKey) + \"=\");\r\n\t                  if (location) {\r\n\t                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\r\n\t                  }\r\n\t              } catch (ignore) {}\r\n\t          }\r\n\t\r\n\t          // If the stored level is not valid, treat it as if nothing was stored.\r\n\t          if (self.levels[storedLevel] === undefined) {\r\n\t              storedLevel = undefined;\r\n\t          }\r\n\t\r\n\t          return storedLevel;\r\n\t      }\r\n\t\r\n\t      /*\r\n\t       *\r\n\t       * Public API\r\n\t       *\r\n\t       */\r\n\t\r\n\t      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\r\n\t          \"ERROR\": 4, \"SILENT\": 5};\r\n\t\r\n\t      self.methodFactory = factory || defaultMethodFactory;\r\n\t\r\n\t      self.getLevel = function () {\r\n\t          return currentLevel;\r\n\t      };\r\n\t\r\n\t      self.setLevel = function (level, persist) {\r\n\t          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\r\n\t              level = self.levels[level.toUpperCase()];\r\n\t          }\r\n\t          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\r\n\t              currentLevel = level;\r\n\t              if (persist !== false) {  // defaults to true\r\n\t                  persistLevelIfPossible(level);\r\n\t              }\r\n\t              replaceLoggingMethods.call(self, level, name);\r\n\t              if (typeof console === undefinedType && level < self.levels.SILENT) {\r\n\t                  return \"No console available for logging\";\r\n\t              }\r\n\t          } else {\r\n\t              throw \"log.setLevel() called with invalid level: \" + level;\r\n\t          }\r\n\t      };\r\n\t\r\n\t      self.setDefaultLevel = function (level) {\r\n\t          if (!getPersistedLevel()) {\r\n\t              self.setLevel(level, false);\r\n\t          }\r\n\t      };\r\n\t\r\n\t      self.enableAll = function(persist) {\r\n\t          self.setLevel(self.levels.TRACE, persist);\r\n\t      };\r\n\t\r\n\t      self.disableAll = function(persist) {\r\n\t          self.setLevel(self.levels.SILENT, persist);\r\n\t      };\r\n\t\r\n\t      // Initialize with the right level\r\n\t      var initialLevel = getPersistedLevel();\r\n\t      if (initialLevel == null) {\r\n\t          initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\r\n\t      }\r\n\t      self.setLevel(initialLevel, false);\r\n\t    }\r\n\t\r\n\t    /*\r\n\t     *\r\n\t     * Package-level API\r\n\t     *\r\n\t     */\r\n\t\r\n\t    var defaultLogger = new Logger();\r\n\t\r\n\t    var _loggersByName = {};\r\n\t    defaultLogger.getLogger = function getLogger(name) {\r\n\t        if (typeof name !== \"string\" || name === \"\") {\r\n\t          throw new TypeError(\"You must supply a name when creating a logger.\");\r\n\t        }\r\n\t\r\n\t        var logger = _loggersByName[name];\r\n\t        if (!logger) {\r\n\t          logger = _loggersByName[name] = new Logger(\r\n\t            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\r\n\t        }\r\n\t        return logger;\r\n\t    };\r\n\t\r\n\t    // Grab the current global log variable in case of overwrite\r\n\t    var _log = (typeof window !== undefinedType) ? window.log : undefined;\r\n\t    defaultLogger.noConflict = function() {\r\n\t        if (typeof window !== undefinedType &&\r\n\t               window.log === defaultLogger) {\r\n\t            window.log = _log;\r\n\t        }\r\n\t\r\n\t        return defaultLogger;\r\n\t    };\r\n\t\r\n\t    return defaultLogger;\r\n\t}));\r\n\n\n/***/ },\n/* 8 */,\n/* 9 */,\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _chai = __webpack_require__(11);\n\t\n\tvar _chai2 = _interopRequireDefault(_chai);\n\t\n\tvar _api = __webpack_require__(6);\n\t\n\tvar _vars = __webpack_require__(51);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tdescribe('api.js', function () {\n\t  it('should fail an invalid create notification', function () {\n\t    return (0, _api.apiCall)('notifications', 'POST', null).should.eventually.be.rejectedWith('Error: Bad Request');\n\t  });\n\t\n\t  it('should send a valid create notification', function () {\n\t    // App is on local server\n\t    var params = {\n\t      'app_id': _vars.APP_ID,\n\t      'contents': { 'en': 'Web SDK unit test.' },\n\t      'include_player_ids': [_vars.PLAYER_ID]\n\t    };\n\t    return (0, _api.apiCall)('notifications', 'POST', params).should.eventually.be.fulfilled;\n\t  });\n\t});\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(12);\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * chai\n\t * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n\t * MIT Licensed\n\t */\n\t\n\tvar used = []\n\t  , exports = module.exports = {};\n\t\n\t/*!\n\t * Chai version\n\t */\n\t\n\texports.version = '3.4.1';\n\t\n\t/*!\n\t * Assertion Error\n\t */\n\t\n\texports.AssertionError = __webpack_require__(13);\n\t\n\t/*!\n\t * Utils for plugins (not exported)\n\t */\n\t\n\tvar util = __webpack_require__(14);\n\t\n\t/**\n\t * # .use(function)\n\t *\n\t * Provides a way to extend the internals of Chai\n\t *\n\t * @param {Function}\n\t * @returns {this} for chaining\n\t * @api public\n\t */\n\t\n\texports.use = function (fn) {\n\t  if (!~used.indexOf(fn)) {\n\t    fn(this, util);\n\t    used.push(fn);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/*!\n\t * Utility Functions\n\t */\n\t\n\texports.util = util;\n\t\n\t/*!\n\t * Configuration\n\t */\n\t\n\tvar config = __webpack_require__(27);\n\texports.config = config;\n\t\n\t/*!\n\t * Primary `Assertion` prototype\n\t */\n\t\n\tvar assertion = __webpack_require__(46);\n\texports.use(assertion);\n\t\n\t/*!\n\t * Core Assertions\n\t */\n\t\n\tvar core = __webpack_require__(47);\n\texports.use(core);\n\t\n\t/*!\n\t * Expect interface\n\t */\n\t\n\tvar expect = __webpack_require__(48);\n\texports.use(expect);\n\t\n\t/*!\n\t * Should interface\n\t */\n\t\n\tvar should = __webpack_require__(49);\n\texports.use(should);\n\t\n\t/*!\n\t * Assert interface\n\t */\n\t\n\tvar assert = __webpack_require__(50);\n\texports.use(assert);\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t/*!\n\t * assertion-error\n\t * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>\n\t * MIT Licensed\n\t */\n\t\n\t/*!\n\t * Return a function that will copy properties from\n\t * one object to another excluding any originally\n\t * listed. Returned function will create a new `{}`.\n\t *\n\t * @param {String} excluded properties ...\n\t * @return {Function}\n\t */\n\t\n\tfunction exclude () {\n\t  var excludes = [].slice.call(arguments);\n\t\n\t  function excludeProps (res, obj) {\n\t    Object.keys(obj).forEach(function (key) {\n\t      if (!~excludes.indexOf(key)) res[key] = obj[key];\n\t    });\n\t  }\n\t\n\t  return function extendExclude () {\n\t    var args = [].slice.call(arguments)\n\t      , i = 0\n\t      , res = {};\n\t\n\t    for (; i < args.length; i++) {\n\t      excludeProps(res, args[i]);\n\t    }\n\t\n\t    return res;\n\t  };\n\t};\n\t\n\t/*!\n\t * Primary Exports\n\t */\n\t\n\tmodule.exports = AssertionError;\n\t\n\t/**\n\t * ### AssertionError\n\t *\n\t * An extension of the JavaScript `Error` constructor for\n\t * assertion and validation scenarios.\n\t *\n\t * @param {String} message\n\t * @param {Object} properties to include (optional)\n\t * @param {callee} start stack function (optional)\n\t */\n\t\n\tfunction AssertionError (message, _props, ssf) {\n\t  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON')\n\t    , props = extend(_props || {});\n\t\n\t  // default values\n\t  this.message = message || 'Unspecified AssertionError';\n\t  this.showDiff = false;\n\t\n\t  // copy from properties\n\t  for (var key in props) {\n\t    this[key] = props[key];\n\t  }\n\t\n\t  // capture stack trace\n\t  ssf = ssf || arguments.callee;\n\t  if (ssf && Error.captureStackTrace) {\n\t    Error.captureStackTrace(this, ssf);\n\t  } else {\n\t    this.stack = new Error().stack;\n\t  }\n\t}\n\t\n\t/*!\n\t * Inherit from Error.prototype\n\t */\n\t\n\tAssertionError.prototype = Object.create(Error.prototype);\n\t\n\t/*!\n\t * Statically set name\n\t */\n\t\n\tAssertionError.prototype.name = 'AssertionError';\n\t\n\t/*!\n\t * Ensure correct constructor\n\t */\n\t\n\tAssertionError.prototype.constructor = AssertionError;\n\t\n\t/**\n\t * Allow errors to be converted to JSON for static transfer.\n\t *\n\t * @param {Boolean} include stack (default: `true`)\n\t * @return {Object} object that can be `JSON.stringify`\n\t */\n\t\n\tAssertionError.prototype.toJSON = function (stack) {\n\t  var extend = exclude('constructor', 'toJSON', 'stack')\n\t    , props = extend({ name: this.name }, this);\n\t\n\t  // include stack if exists and not turned off\n\t  if (false !== stack && this.stack) {\n\t    props.stack = this.stack;\n\t  }\n\t\n\t  return props;\n\t};\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * chai\n\t * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>\n\t * MIT Licensed\n\t */\n\t\n\t/*!\n\t * Main exports\n\t */\n\t\n\tvar exports = module.exports = {};\n\t\n\t/*!\n\t * test utility\n\t */\n\t\n\texports.test = __webpack_require__(15);\n\t\n\t/*!\n\t * type utility\n\t */\n\t\n\texports.type = __webpack_require__(17);\n\t\n\t/*!\n\t * expectTypes utility\n\t */\n\texports.expectTypes = __webpack_require__(19);\n\t\n\t/*!\n\t * message utility\n\t */\n\t\n\texports.getMessage = __webpack_require__(20);\n\t\n\t/*!\n\t * actual utility\n\t */\n\t\n\texports.getActual = __webpack_require__(21);\n\t\n\t/*!\n\t * Inspect util\n\t */\n\t\n\texports.inspect = __webpack_require__(22);\n\t\n\t/*!\n\t * Object Display util\n\t */\n\t\n\texports.objDisplay = __webpack_require__(26);\n\t\n\t/*!\n\t * Flag utility\n\t */\n\t\n\texports.flag = __webpack_require__(16);\n\t\n\t/*!\n\t * Flag transferring utility\n\t */\n\t\n\texports.transferFlags = __webpack_require__(28);\n\t\n\t/*!\n\t * Deep equal utility\n\t */\n\t\n\texports.eql = __webpack_require__(29);\n\t\n\t/*!\n\t * Deep path value\n\t */\n\t\n\texports.getPathValue = __webpack_require__(37);\n\t\n\t/*!\n\t * Deep path info\n\t */\n\t\n\texports.getPathInfo = __webpack_require__(38);\n\t\n\t/*!\n\t * Check if a property exists\n\t */\n\t\n\texports.hasProperty = __webpack_require__(39);\n\t\n\t/*!\n\t * Function name\n\t */\n\t\n\texports.getName = __webpack_require__(23);\n\t\n\t/*!\n\t * add Property\n\t */\n\t\n\texports.addProperty = __webpack_require__(40);\n\t\n\t/*!\n\t * add Method\n\t */\n\t\n\texports.addMethod = __webpack_require__(41);\n\t\n\t/*!\n\t * overwrite Property\n\t */\n\t\n\texports.overwriteProperty = __webpack_require__(42);\n\t\n\t/*!\n\t * overwrite Method\n\t */\n\t\n\texports.overwriteMethod = __webpack_require__(43);\n\t\n\t/*!\n\t * Add a chainable method\n\t */\n\t\n\texports.addChainableMethod = __webpack_require__(44);\n\t\n\t/*!\n\t * Overwrite chainable method\n\t */\n\t\n\texports.overwriteChainableMethod = __webpack_require__(45);\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * Chai - test utility\n\t * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n\t * MIT Licensed\n\t */\n\t\n\t/*!\n\t * Module dependancies\n\t */\n\t\n\tvar flag = __webpack_require__(16);\n\t\n\t/**\n\t * # test(object, expression)\n\t *\n\t * Test and object for expression.\n\t *\n\t * @param {Object} object (constructed Assertion)\n\t * @param {Arguments} chai.Assertion.prototype.assert arguments\n\t */\n\t\n\tmodule.exports = function (obj, args) {\n\t  var negate = flag(obj, 'negate')\n\t    , expr = args[0];\n\t  return negate ? !expr : expr;\n\t};\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\t/*!\n\t * Chai - flag utility\n\t * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n\t * MIT Licensed\n\t */\n\t\n\t/**\n\t * ### flag(object, key, [value])\n\t *\n\t * Get or set a flag value on an object. If a\n\t * value is provided it will be set, else it will\n\t * return the currently set value or `undefined` if\n\t * the value is not set.\n\t *\n\t *     utils.flag(this, 'foo', 'bar'); // setter\n\t *     utils.flag(this, 'foo'); // getter, returns `bar`\n\t *\n\t * @param {Object} object constructed Assertion\n\t * @param {String} key\n\t * @param {Mixed} value (optional)\n\t * @name flag\n\t * @api private\n\t */\n\t\n\tmodule.exports = function (obj, key, value) {\n\t  var flags = obj.__flags || (obj.__flags = Object.create(null));\n\t  if (arguments.length === 3) {\n\t    flags[key] = value;\n\t  } else {\n\t    return flags[key];\n\t  }\n\t};\n\n\n/***/ },\n/* 17 */\n[52, 18],\n/* 18 */\n/***/ function(module, exports) {\n\n\t/*!\n\t * type-detect\n\t * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>\n\t * MIT Licensed\n\t */\n\t\n\t/*!\n\t * Primary Exports\n\t */\n\t\n\tvar exports = module.exports = getType;\n\t\n\t/**\n\t * ### typeOf (obj)\n\t *\n\t * Use several different techniques to determine\n\t * the type of object being tested.\n\t *\n\t *\n\t * @param {Mixed} object\n\t * @return {String} object type\n\t * @api public\n\t */\n\tvar objectTypeRegexp = /^\\[object (.*)\\]$/;\n\t\n\tfunction getType(obj) {\n\t  var type = Object.prototype.toString.call(obj).match(objectTypeRegexp)[1].toLowerCase();\n\t  // Let \"new String('')\" return 'object'\n\t  if (typeof Promise === 'function' && obj instanceof Promise) return 'promise';\n\t  // PhantomJS has type \"DOMWindow\" for null\n\t  if (obj === null) return 'null';\n\t  // PhantomJS has type \"DOMWindow\" for undefined\n\t  if (obj === undefined) return 'undefined';\n\t  return type;\n\t}\n\t\n\texports.Library = Library;\n\t\n\t/**\n\t * ### Library\n\t *\n\t * Create a repository for custom type detection.\n\t *\n\t * ```js\n\t * var lib = new type.Library;\n\t * ```\n\t *\n\t */\n\t\n\tfunction Library() {\n\t  if (!(this instanceof Library)) return new Library();\n\t  this.tests = {};\n\t}\n\t\n\t/**\n\t * #### .of (obj)\n\t *\n\t * Expose replacement `typeof` detection to the library.\n\t *\n\t * ```js\n\t * if ('string' === lib.of('hello world')) {\n\t *   // ...\n\t * }\n\t * ```\n\t *\n\t * @param {Mixed} object to test\n\t * @return {String} type\n\t */\n\t\n\tLibrary.prototype.of = getType;\n\t\n\t/**\n\t * #### .define (type, test)\n\t *\n\t * Add a test to for the `.test()` assertion.\n\t *\n\t * Can be defined as a regular expression:\n\t *\n\t * ```js\n\t * lib.define('int', /^[0-9]+$/);\n\t * ```\n\t *\n\t * ... or as a function:\n\t *\n\t * ```js\n\t * lib.define('bln', function (obj) {\n\t *   if ('boolean' === lib.of(obj)) return true;\n\t *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];\n\t *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();\n\t *   return !! ~blns.indexOf(obj);\n\t * });\n\t * ```\n\t *\n\t * @param {String} type\n\t * @param {RegExp|Function} test\n\t * @api public\n\t */\n\t\n\tLibrary.prototype.define = function(type, test) {\n\t  if (arguments.length === 1) return this.tests[type];\n\t  this.tests[type] = test;\n\t  return this;\n\t};\n\t\n\t/**\n\t * #### .test (obj, test)\n\t *\n\t * Assert that an object is of type. Will first\n\t * check natives, and if that does not pass it will\n\t * use the user defined custom tests.\n\t *\n\t * ```js\n\t * assert(lib.test('1', 'int'));\n\t * assert(lib.test('yes', 'bln'));\n\t * ```\n\t *\n\t * @param {Mixed} object\n\t * @param {String} type\n\t * @return {Boolean} result\n\t * @api public\n\t */\n\t\n\tLibrary.prototype.test = function(obj, type) {\n\t  if (type === getType(obj)) return true;\n\t  var test = this.tests[type];\n\t\n\t  if (test && 'regexp' === getType(test)) {\n\t    return test.test(obj);\n\t  } else if (test && 'function' === getType(test)) {\n\t    return test(obj);\n\t  } else {\n\t    throw new ReferenceError('Type test \"' + type + '\" not defined or invalid.');\n\t  }\n\t};\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * Chai - expectTypes utility\n\t * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n\t * MIT Licensed\n\t */\n\t\n\t/**\n\t * ### expectTypes(obj, types)\n\t *\n\t * Ensures that the object being tested against is of a valid type.\n\t *\n\t *     utils.expectTypes(this, ['array', 'object', 'string']);\n\t *\n\t * @param {Mixed} obj constructed Assertion\n\t * @param {Array} type A list of allowed types for this assertion\n\t * @name expectTypes\n\t * @api public\n\t */\n\t\n\tvar AssertionError = __webpack_require__(13);\n\tvar flag = __webpack_require__(16);\n\tvar type = __webpack_require__(17);\n\t\n\tmodule.exports = function (obj, types) {\n\t  var obj = flag(obj, 'object');\n\t  types = types.map(function (t) { return t.toLowerCase(); });\n\t  types.sort();\n\t\n\t  // Transforms ['lorem', 'ipsum'] into 'a lirum, or an ipsum'\n\t  var str = types.map(function (t, index) {\n\t    var art = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(t.charAt(0)) ? 'an' : 'a';\n\t    var or = types.length > 1 && index === types.length - 1 ? 'or ' : '';\n\t    return or + art + ' ' + t;\n\t  }).join(', ');\n\t\n\t  if (!types.some(function (expected) { return type(obj) === expected; })) {\n\t    throw new AssertionError(\n\t      'object tested must be ' + str + ', but ' + type(obj) + ' given'\n\t    );\n\t  }\n\t};\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * Chai - message composition utility\n\t * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n\t * MIT Licensed\n\t */\n\t\n\t/*!\n\t * Module dependancies\n\t */\n\t\n\tvar flag = __webpack_require__(16)\n\t  , getActual = __webpack_require__(21)\n\t  , inspect = __webpack_require__(22)\n\t  , objDisplay = __webpack_require__(26);\n\t\n\t/**\n\t * ### .getMessage(object, message, negateMessage)\n\t *\n\t * Construct the error message based on flags\n\t * and template tags. Template tags will return\n\t * a stringified inspection of the object referenced.\n\t *\n\t * Message template tags:\n\t * - `#{this}` current asserted object\n\t * - `#{act}` actual value\n\t * - `#{exp}` expected value\n\t *\n\t * @param {Object} object (constructed Assertion)\n\t * @param {Arguments} chai.Assertion.prototype.assert arguments\n\t * @name getMessage\n\t * @api public\n\t */\n\t\n\tmodule.exports = function (obj, args) {\n\t  var negate = flag(obj, 'negate')\n\t    , val = flag(obj, 'object')\n\t    , expected = args[3]\n\t    , actual = getActual(obj, args)\n\t    , msg = negate ? args[2] : args[1]\n\t    , flagMsg = flag(obj, 'message');\n\t\n\t  if(typeof msg === \"function\") msg = msg();\n\t  msg = msg || '';\n\t  msg = msg\n\t    .replace(/#{this}/g, objDisplay(val))\n\t    .replace(/#{act}/g, objDisplay(actual))\n\t    .replace(/#{exp}/g, objDisplay(expected));\n\t\n\t  return flagMsg ? flagMsg + ': ' + msg : msg;\n\t};\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\t/*!\n\t * Chai - getActual utility\n\t * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n\t * MIT Licensed\n\t */\n\t\n\t/**\n\t * # getActual(object, [actual])\n\t *\n\t * Returns the `actual` value for an Assertion\n\t *\n\t * @param {Object} object (constructed Assertion)\n\t * @param {Arguments} chai.Assertion.prototype.assert arguments\n\t */\n\t\n\tmodule.exports = function (obj, args) {\n\t  return args.length > 4 ? args[4] : obj._obj;\n\t};\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// This is (almost) directly from Node.js utils\n\t// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js\n\t\n\tvar getName = __webpack_require__(23);\n\tvar getProperties = __webpack_require__(24);\n\tvar getEnumerableProperties = __webpack_require__(25);\n\t\n\tmodule.exports = inspect;\n\t\n\t/**\n\t * Echos the value of a value. Trys to print the value out\n\t * in the best way possible given the different types.\n\t *\n\t * @param {Object} obj The object to print out.\n\t * @param {Boolean} showHidden Flag that shows hidden (not enumerable)\n\t *    properties of objects.\n\t * @param {Number} depth Depth in which to descend in object. Default is 2.\n\t * @param {Boolean} colors Flag to turn on ANSI escape codes to color the\n\t *    output. Default is false (no coloring).\n\t */\n\tfunction inspect(obj, showHidden, depth, colors) {\n\t  var ctx = {\n\t    showHidden: showHidden,\n\t    seen: [],\n\t    stylize: function (str) { return str; }\n\t  };\n\t  return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));\n\t}\n\t\n\t// Returns true if object is a DOM element.\n\tvar isDOMElement = function (object) {\n\t  if (typeof HTMLElement === 'object') {\n\t    return object instanceof HTMLElement;\n\t  } else {\n\t    return object &&\n\t      typeof object === 'object' &&\n\t      object.nodeType === 1 &&\n\t      typeof object.nodeName === 'string';\n\t  }\n\t};\n\t\n\tfunction formatValue(ctx, value, recurseTimes) {\n\t  // Provide a hook for user-specified inspect functions.\n\t  // Check that value is an object with an inspect function on it\n\t  if (value && typeof value.inspect === 'function' &&\n\t      // Filter out the util module, it's inspect function is special\n\t      value.inspect !== exports.inspect &&\n\t      // Also filter out any prototype objects using the circular check.\n\t      !(value.constructor && value.constructor.prototype === value)) {\n\t    var ret = value.inspect(recurseTimes);\n\t    if (typeof ret !== 'string') {\n\t      ret = formatValue(ctx, ret, recurseTimes);\n\t    }\n\t    return ret;\n\t  }\n\t\n\t  // Primitive types cannot have properties\n\t  var primitive = formatPrimitive(ctx, value);\n\t  if (primitive) {\n\t    return primitive;\n\t  }\n\t\n\t  // If this is a DOM element, try to get the outer HTML.\n\t  if (isDOMElement(value)) {\n\t    if ('outerHTML' in value) {\n\t      return value.outerHTML;\n\t      // This value does not have an outerHTML attribute,\n\t      //   it could still be an XML element\n\t    } else {\n\t      // Attempt to serialize it\n\t      try {\n\t        if (document.xmlVersion) {\n\t          var xmlSerializer = new XMLSerializer();\n\t          return xmlSerializer.serializeToString(value);\n\t        } else {\n\t          // Firefox 11- do not support outerHTML\n\t          //   It does, however, support innerHTML\n\t          //   Use the following to render the element\n\t          var ns = \"http://www.w3.org/1999/xhtml\";\n\t          var container = document.createElementNS(ns, '_');\n\t\n\t          container.appendChild(value.cloneNode(false));\n\t          html = container.innerHTML\n\t            .replace('><', '>' + value.innerHTML + '<');\n\t          container.innerHTML = '';\n\t          return html;\n\t        }\n\t      } catch (err) {\n\t        // This could be a non-native DOM implementation,\n\t        //   continue with the normal flow:\n\t        //   printing the element as if it is an object.\n\t      }\n\t    }\n\t  }\n\t\n\t  // Look up the keys of the object.\n\t  var visibleKeys = getEnumerableProperties(value);\n\t  var keys = ctx.showHidden ? getProperties(value) : visibleKeys;\n\t\n\t  // Some type of object without properties can be shortcutted.\n\t  // In IE, errors have a single `stack` property, or if they are vanilla `Error`,\n\t  // a `stack` plus `description` property; ignore those for consistency.\n\t  if (keys.length === 0 || (isError(value) && (\n\t      (keys.length === 1 && keys[0] === 'stack') ||\n\t      (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')\n\t     ))) {\n\t    if (typeof value === 'function') {\n\t      var name = getName(value);\n\t      var nameSuffix = name ? ': ' + name : '';\n\t      return ctx.stylize('[Function' + nameSuffix + ']', 'special');\n\t    }\n\t    if (isRegExp(value)) {\n\t      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n\t    }\n\t    if (isDate(value)) {\n\t      return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');\n\t    }\n\t    if (isError(value)) {\n\t      return formatError(value);\n\t    }\n\t  }\n\t\n\t  var base = '', array = false, braces = ['{', '}'];\n\t\n\t  // Make Array say that they are Array\n\t  if (isArray(value)) {\n\t    array = true;\n\t    braces = ['[', ']'];\n\t  }\n\t\n\t  // Make functions say that they are functions\n\t  if (typeof value === 'function') {\n\t    var name = getName(value);\n\t    var nameSuffix = name ? ': ' + name : '';\n\t    base = ' [Function' + nameSuffix + ']';\n\t  }\n\t\n\t  // Make RegExps say that they are RegExps\n\t  if (isRegExp(value)) {\n\t    base = ' ' + RegExp.prototype.toString.call(value);\n\t  }\n\t\n\t  // Make dates with properties first say the date\n\t  if (isDate(value)) {\n\t    base = ' ' + Date.prototype.toUTCString.call(value);\n\t  }\n\t\n\t  // Make error with message first say the error\n\t  if (isError(value)) {\n\t    return formatError(value);\n\t  }\n\t\n\t  if (keys.length === 0 && (!array || value.length == 0)) {\n\t    return braces[0] + base + braces[1];\n\t  }\n\t\n\t  if (recurseTimes < 0) {\n\t    if (isRegExp(value)) {\n\t      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n\t    } else {\n\t      return ctx.stylize('[Object]', 'special');\n\t    }\n\t  }\n\t\n\t  ctx.seen.push(value);\n\t\n\t  var output;\n\t  if (array) {\n\t    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n\t  } else {\n\t    output = keys.map(function(key) {\n\t      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n\t    });\n\t  }\n\t\n\t  ctx.seen.pop();\n\t\n\t  return reduceToSingleString(output, base, braces);\n\t}\n\t\n\t\n\tfunction formatPrimitive(ctx, value) {\n\t  switch (typeof value) {\n\t    case 'undefined':\n\t      return ctx.stylize('undefined', 'undefined');\n\t\n\t    case 'string':\n\t      var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n\t                                               .replace(/'/g, \"\\\\'\")\n\t                                               .replace(/\\\\\"/g, '\"') + '\\'';\n\t      return ctx.stylize(simple, 'string');\n\t\n\t    case 'number':\n\t      if (value === 0 && (1/value) === -Infinity) {\n\t        return ctx.stylize('-0', 'number');\n\t      }\n\t      return ctx.stylize('' + value, 'number');\n\t\n\t    case 'boolean':\n\t      return ctx.stylize('' + value, 'boolean');\n\t  }\n\t  // For some reason typeof null is \"object\", so special case here.\n\t  if (value === null) {\n\t    return ctx.stylize('null', 'null');\n\t  }\n\t}\n\t\n\t\n\tfunction formatError(value) {\n\t  return '[' + Error.prototype.toString.call(value) + ']';\n\t}\n\t\n\t\n\tfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n\t  var output = [];\n\t  for (var i = 0, l = value.length; i < l; ++i) {\n\t    if (Object.prototype.hasOwnProperty.call(value, String(i))) {\n\t      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n\t          String(i), true));\n\t    } else {\n\t      output.push('');\n\t    }\n\t  }\n\t  keys.forEach(function(key) {\n\t    if (!key.match(/^\\d+$/)) {\n\t      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n\t          key, true));\n\t    }\n\t  });\n\t  return output;\n\t}\n\t\n\t\n\tfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n\t  var name, str;\n\t  if (value.__lookupGetter__) {\n\t    if (value.__lookupGetter__(key)) {\n\t      if (value.__lookupSetter__(key)) {\n\t        str = ctx.stylize('[Getter/Setter]', 'special');\n\t      } else {\n\t        str = ctx.stylize('[Getter]', 'special');\n\t      }\n\t    } else {\n\t      if (value.__lookupSetter__(key)) {\n\t        str = ctx.stylize('[Setter]', 'special');\n\t      }\n\t    }\n\t  }\n\t  if (visibleKeys.indexOf(key) < 0) {\n\t    name = '[' + key + ']';\n\t  }\n\t  if (!str) {\n\t    if (ctx.seen.indexOf(value[key]) < 0) {\n\t      if (recurseTimes === null) {\n\t        str = formatValue(ctx, value[key], null);\n\t      } else {\n\t        str = formatValue(ctx, value[key], recurseTimes - 1);\n\t      }\n\t      if (str.indexOf('\\n') > -1) {\n\t        if (array) {\n\t          str = str.split('\\n').map(function(line) {\n\t            return '  ' + line;\n\t          }).join('\\n').substr(2);\n\t        } else {\n\t          str = '\\n' + str.split('\\n').map(function(line) {\n\t            return '   ' + line;\n\t          }).join('\\n');\n\t        }\n\t      }\n\t    } else {\n\t      str = ctx.stylize('[Circular]', 'special');\n\t    }\n\t  }\n\t  if (typeof name === 'undefined') {\n\t    if (array && key.match(/^\\d+$/)) {\n\t      return str;\n\t    }\n\t    name = JSON.stringify('' + key);\n\t    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n\t      name = name.substr(1, name.length - 2);\n\t      name = ctx.stylize(name, 'name');\n\t    } else {\n\t      name = name.replace(/'/g, \"\\\\'\")\n\t                 .replace(/\\\\\"/g, '\"')\n\t                 .replace(/(^\"|\"$)/g, \"'\");\n\t      name = ctx.stylize(name, 'string');\n\t    }\n\t  }\n\t\n\t  return name + ': ' + str;\n\t}\n\t\n\t\n\tfunction reduceToSingleString(output, base, braces) {\n\t  var numLinesEst = 0;\n\t  var length = output.reduce(function(prev, cur) {\n\t    numLinesEst++;\n\t    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n\t    return prev + cur.length + 1;\n\t  }, 0);\n\t\n\t  if (length > 60) {\n\t    return braces[0] +\n\t           (base === '' ? '' : base + '\\n ') +\n\t           ' ' +\n\t           output.join(',\\n  ') +\n\t           ' ' +\n\t           braces[1];\n\t  }\n\t\n\t  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n\t}\n\t\n\tfunction isArray(ar) {\n\t  return Array.isArray(ar) ||\n\t         (typeof ar === 'object' && objectToString(ar) === '[object Array]');\n\t}\n\t\n\tfunction isRegExp(re) {\n\t  return typeof re === 'object' && objectToString(re) === '[object RegExp]';\n\t}\n\t\n\tfunction isDate(d) {\n\t  return typeof d === 'object' && objectToString(d) === '[object Date]';\n\t}\n\t\n\tfunction isError(e) {\n\t  return typeof e === 'object' && objectToString(e) === '[object Error]';\n\t}\n\t\n\tfunction objectToString(o) {\n\t  return Object.prototype.toString.call(o);\n\t}\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\t/*!\n\t * Chai - getName utility\n\t * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n\t * MIT Licensed\n\t */\n\t\n\t/**\n\t * # getName(func)\n\t *\n\t * Gets the name of a function, in a cross-browser way.\n\t *\n\t * @param {Function} a function (usually a constructor)\n\t */\n\t\n\tmodule.exports = function (func) {\n\t  if (func.name) return func.name;\n\t\n\t  var match = /^\\s?function ([^(]*)\\(/.exec(func);\n\t  return match && match[1] ? match[1] : \"\";\n\t};\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\n\t/*!\n\t * Chai - getProperties utility\n\t * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n\t * MIT Licensed\n\t */\n\t\n\t/**\n\t * ### .getProperties(object)\n\t *\n\t * This allows the retrieval of property names of an object, enumerable or not,\n\t * inherited or not.\n\t *\n\t * @param {Object} object\n\t * @returns {Array}\n\t * @name getProperties\n\t * @api public\n\t */\n\t\n\tmodule.exports = function getProperties(object) {\n\t  var result = Object.getOwnPropertyNames(object);\n\t\n\t  function addProperty(property) {\n\t    if (result.indexOf(property) === -1) {\n\t      result.push(property);\n\t    }\n\t  }\n\t\n\t  var proto = Object.getPrototypeOf(object);\n\t  while (proto !== null) {\n\t    Object.getOwnPropertyNames(proto).forEach(addProperty);\n\t    proto = Object.getPrototypeOf(proto);\n\t  }\n\t\n\t  return result;\n\t};\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\t/*!\n\t * Chai - getEnumerableProperties utility\n\t * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n\t * MIT Licensed\n\t */\n\t\n\t/**\n\t * ### .getEnumerableProperties(object)\n\t *\n\t * This allows the retrieval of enumerable property names of an object,\n\t * inherited or not.\n\t *\n\t * @param {Object} object\n\t * @returns {Array}\n\t * @name getEnumerableProperties\n\t * @api public\n\t */\n\t\n\tmodule.exports = function getEnumerableProperties(object) {\n\t  var result = [];\n\t  for (var name in object) {\n\t    result.push(name);\n\t  }\n\t  return result;\n\t};\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * Chai - flag utility\n\t * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n\t * MIT Licensed\n\t */\n\t\n\t/*!\n\t * Module dependancies\n\t */\n\t\n\tvar inspect = __webpack_require__(22);\n\tvar config = __webpack_require__(27);\n\t\n\t/**\n\t * ### .objDisplay (object)\n\t *\n\t * Determines if an object or an array matches\n\t * criteria to be inspected in-line for error\n\t * messages or should be truncated.\n\t *\n\t * @param {Mixed} javascript object to inspect\n\t * @name objDisplay\n\t * @api public\n\t */\n\t\n\tmodule.exports = function (obj) {\n\t  var str = inspect(obj)\n\t    , type = Object.prototype.toString.call(obj);\n\t\n\t  if (config.truncateThreshold && str.length >= config.truncateThreshold) {\n\t    if (type === '[object Function]') {\n\t      return !obj.name || obj.name === ''\n\t        ? '[Function]'\n\t        : '[Function: ' + obj.name + ']';\n\t    } else if (type === '[object Array]') {\n\t      return '[ Array(' + obj.length + ') ]';\n\t    } else if (type === '[object Object]') {\n\t      var keys = Object.keys(obj)\n\t        , kstr = keys.length > 2\n\t          ? keys.splice(0, 2).join(', ') + ', ...'\n\t          : keys.join(', ');\n\t      return '{ Object (' + kstr + ') }';\n\t    } else {\n\t      return str;\n\t    }\n\t  } else {\n\t    return str;\n\t  }\n\t};\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {\n\t\n\t  /**\n\t   * ### config.includeStack\n\t   *\n\t   * User configurable property, influences whether stack trace\n\t   * is included in Assertion error message. Default of false\n\t   * suppresses stack trace in the error message.\n\t   *\n\t   *     chai.config.includeStack = true;  // enable stack on error\n\t   *\n\t   * @param {Boolean}\n\t   * @api public\n\t   */\n\t\n\t   includeStack: false,\n\t\n\t  /**\n\t   * ### config.showDiff\n\t   *\n\t   * User configurable property, influences whether or not\n\t   * the `showDiff` flag should be included in the thrown\n\t   * AssertionErrors. `false` will always be `false`; `true`\n\t   * will be true when the assertion has requested a diff\n\t   * be shown.\n\t   *\n\t   * @param {Boolean}\n\t   * @api public\n\t   */\n\t\n\t  showDiff: true,\n\t\n\t  /**\n\t   * ### config.truncateThreshold\n\t   *\n\t   * User configurable property, sets length threshold for actual and\n\t   * expected values in assertion errors. If this threshold is exceeded, for\n\t   * example for large data structures, the value is replaced with something\n\t   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.\n\t   *\n\t   * Set it to zero if you want to disable truncating altogether.\n\t   *\n\t   * This is especially userful when doing assertions on arrays: having this\n\t   * set to a reasonable large value makes the failure messages readily\n\t   * inspectable.\n\t   *\n\t   *     chai.config.truncateThreshold = 0;  // disable truncating\n\t   *\n\t   * @param {Number}\n\t   * @api public\n\t   */\n\t\n\t  truncateThreshold: 40\n\t\n\t};\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports) {\n\n\t/*!\n\t * Chai - transferFlags utility\n\t * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n\t * MIT Licensed\n\t */\n\t\n\t/**\n\t * ### transferFlags(assertion, object, includeAll = true)\n\t *\n\t * Transfer all the flags for `assertion` to `object`. If\n\t * `includeAll` is set to `false`, then the base Chai\n\t * assertion flags (namely `object`, `ssfi`, and `message`)\n\t * will not be transferred.\n\t *\n\t *\n\t *     var newAssertion = new Assertion();\n\t *     utils.transferFlags(assertion, newAssertion);\n\t *\n\t *     var anotherAsseriton = new Assertion(myObj);\n\t *     utils.transferFlags(assertion, anotherAssertion, false);\n\t *\n\t * @param {Assertion} assertion the assertion to transfer the flags from\n\t * @param {Object} object the object to transfer the flags to; usually a new assertion\n\t * @param {Boolean} includeAll\n\t * @name transferFlags\n\t * @api private\n\t */\n\t\n\tmodule.exports = function (assertion, object, includeAll) {\n\t  var flags = assertion.__flags || (assertion.__flags = Object.create(null));\n\t\n\t  if (!object.__flags) {\n\t    object.__flags = Object.create(null);\n\t  }\n\t\n\t  includeAll = arguments.length === 3 ? includeAll : true;\n\t\n\t  for (var flag in flags) {\n\t    if (includeAll ||\n\t        (flag !== 'object' && flag !== 'ssfi' && flag != 'message')) {\n\t      object.__flags[flag] = flags[flag];\n\t    }\n\t  }\n\t};\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(30);\n\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * deep-eql\n\t * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>\n\t * MIT Licensed\n\t */\n\t\n\t/*!\n\t * Module dependencies\n\t */\n\t\n\tvar type = __webpack_require__(31);\n\t\n\t/*!\n\t * Buffer.isBuffer browser shim\n\t */\n\t\n\tvar Buffer;\n\ttry { Buffer = __webpack_require__(33).Buffer; }\n\tcatch(ex) {\n\t  Buffer = {};\n\t  Buffer.isBuffer = function() { return false; }\n\t}\n\t\n\t/*!\n\t * Primary Export\n\t */\n\t\n\tmodule.exports = deepEqual;\n\t\n\t/**\n\t * Assert super-strict (egal) equality between\n\t * two objects of any type.\n\t *\n\t * @param {Mixed} a\n\t * @param {Mixed} b\n\t * @param {Array} memoised (optional)\n\t * @return {Boolean} equal match\n\t */\n\t\n\tfunction deepEqual(a, b, m) {\n\t  if (sameValue(a, b)) {\n\t    return true;\n\t  } else if ('date' === type(a)) {\n\t    return dateEqual(a, b);\n\t  } else if ('regexp' === type(a)) {\n\t    return regexpEqual(a, b);\n\t  } else if (Buffer.isBuffer(a)) {\n\t    return bufferEqual(a, b);\n\t  } else if ('arguments' === type(a)) {\n\t    return argumentsEqual(a, b, m);\n\t  } else if (!typeEqual(a, b)) {\n\t    return false;\n\t  } else if (('object' !== type(a) && 'object' !== type(b))\n\t  && ('array' !== type(a) && 'array' !== type(b))) {\n\t    return sameValue(a, b);\n\t  } else {\n\t    return objectEqual(a, b, m);\n\t  }\n\t}\n\t\n\t/*!\n\t * Strict (egal) equality test. Ensures that NaN always\n\t * equals NaN and `-0` does not equal `+0`.\n\t *\n\t * @param {Mixed} a\n\t * @param {Mixed} b\n\t * @return {Boolean} equal match\n\t */\n\t\n\tfunction sameValue(a, b) {\n\t  if (a === b) return a !== 0 || 1 / a === 1 / b;\n\t  return a !== a && b !== b;\n\t}\n\t\n\t/*!\n\t * Compare the types of two given objects and\n\t * return if they are equal. Note that an Array\n\t * has a type of `array` (not `object`) and arguments\n\t * have a type of `arguments` (not `array`/`object`).\n\t *\n\t * @param {Mixed} a\n\t * @param {Mixed} b\n\t * @return {Boolean} result\n\t */\n\t\n\tfunction typeEqual(a, b) {\n\t  return type(a) === type(b);\n\t}\n\t\n\t/*!\n\t * Compare two Date objects by asserting that\n\t * the time values are equal using `saveValue`.\n\t *\n\t * @param {Date} a\n\t * @param {Date} b\n\t * @return {Boolean} result\n\t */\n\t\n\tfunction dateEqual(a, b) {\n\t  if ('date' !== type(b)) return false;\n\t  return sameValue(a.getTime(), b.getTime());\n\t}\n\t\n\t/*!\n\t * Compare two regular expressions by converting them\n\t * to string and checking for `sameValue`.\n\t *\n\t * @param {RegExp} a\n\t * @param {RegExp} b\n\t * @return {Boolean} result\n\t */\n\t\n\tfunction regexpEqual(a, b) {\n\t  if ('regexp' !== type(b)) return false;\n\t  return sameValue(a.toString(), b.toString());\n\t}\n\t\n\t/*!\n\t * Assert deep equality of two `arguments` objects.\n\t * Unfortunately, these must be sliced to arrays\n\t * prior to test to ensure no bad behavior.\n\t *\n\t * @param {Arguments} a\n\t * @param {Arguments} b\n\t * @param {Array} memoize (optional)\n\t * @return {Boolean} result\n\t */\n\t\n\tfunction argumentsEqual(a, b, m) {\n\t  if ('arguments' !== type(b)) return false;\n\t  a = [].slice.call(a);\n\t  b = [].slice.call(b);\n\t  return deepEqual(a, b, m);\n\t}\n\t\n\t/*!\n\t * Get enumerable properties of a given object.\n\t *\n\t * @param {Object} a\n\t * @return {Array} property names\n\t */\n\t\n\tfunction enumerable(a) {\n\t  var res = [];\n\t  for (var key in a) res.push(key);\n\t  return res;\n\t}\n\t\n\t/*!\n\t * Simple equality for flat iterable objects\n\t * such as Arrays or Node.js buffers.\n\t *\n\t * @param {Iterable} a\n\t * @param {Iterable} b\n\t * @return {Boolean} result\n\t */\n\t\n\tfunction iterableEqual(a, b) {\n\t  if (a.length !==  b.length) return false;\n\t\n\t  var i = 0;\n\t  var match = true;\n\t\n\t  for (; i < a.length; i++) {\n\t    if (a[i] !== b[i]) {\n\t      match = false;\n\t      break;\n\t    }\n\t  }\n\t\n\t  return match;\n\t}\n\t\n\t/*!\n\t * Extension to `iterableEqual` specifically\n\t * for Node.js Buffers.\n\t *\n\t * @param {Buffer} a\n\t * @param {Mixed} b\n\t * @return {Boolean} result\n\t */\n\t\n\tfunction bufferEqual(a, b) {\n\t  if (!Buffer.isBuffer(b)) return false;\n\t  return iterableEqual(a, b);\n\t}\n\t\n\t/*!\n\t * Block for `objectEqual` ensuring non-existing\n\t * values don't get in.\n\t *\n\t * @param {Mixed} object\n\t * @return {Boolean} result\n\t */\n\t\n\tfunction isValue(a) {\n\t  return a !== null && a !== undefined;\n\t}\n\t\n\t/*!\n\t * Recursively check the equality of two objects.\n\t * Once basic sameness has been established it will\n\t * defer to `deepEqual` for each enumerable key\n\t * in the object.\n\t *\n\t * @param {Mixed} a\n\t * @param {Mixed} b\n\t * @return {Boolean} result\n\t */\n\t\n\tfunction objectEqual(a, b, m) {\n\t  if (!isValue(a) || !isValue(b)) {\n\t    return false;\n\t  }\n\t\n\t  if (a.prototype !== b.prototype) {\n\t    return false;\n\t  }\n\t\n\t  var i;\n\t  if (m) {\n\t    for (i = 0; i < m.length; i++) {\n\t      if ((m[i][0] === a && m[i][1] === b)\n\t      ||  (m[i][0] === b && m[i][1] === a)) {\n\t        return true;\n\t      }\n\t    }\n\t  } else {\n\t    m = [];\n\t  }\n\t\n\t  try {\n\t    var ka = enumerable(a);\n\t    var kb = enumerable(b);\n\t  } catch (ex) {\n\t    return false;\n\t  }\n\t\n\t  ka.sort();\n\t  kb.sort();\n\t\n\t  if (!iterableEqual(ka, kb)) {\n\t    return false;\n\t  }\n\t\n\t  m.push([ a, b ]);\n\t\n\t  var key;\n\t  for (i = ka.length - 1; i >= 0; i--) {\n\t    key = ka[i];\n\t    if (!deepEqual(a[key], b[key], m)) {\n\t      return false;\n\t    }\n\t  }\n\t\n\t  return true;\n\t}\n\n\n/***/ },\n/* 31 */\n[52, 32],\n/* 32 */\n/***/ function(module, exports) {\n\n\t/*!\n\t * type-detect\n\t * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>\n\t * MIT Licensed\n\t */\n\t\n\t/*!\n\t * Primary Exports\n\t */\n\t\n\tvar exports = module.exports = getType;\n\t\n\t/*!\n\t * Detectable javascript natives\n\t */\n\t\n\tvar natives = {\n\t    '[object Array]': 'array'\n\t  , '[object RegExp]': 'regexp'\n\t  , '[object Function]': 'function'\n\t  , '[object Arguments]': 'arguments'\n\t  , '[object Date]': 'date'\n\t};\n\t\n\t/**\n\t * ### typeOf (obj)\n\t *\n\t * Use several different techniques to determine\n\t * the type of object being tested.\n\t *\n\t *\n\t * @param {Mixed} object\n\t * @return {String} object type\n\t * @api public\n\t */\n\t\n\tfunction getType (obj) {\n\t  var str = Object.prototype.toString.call(obj);\n\t  if (natives[str]) return natives[str];\n\t  if (obj === null) return 'null';\n\t  if (obj === undefined) return 'undefined';\n\t  if (obj === Object(obj)) return 'object';\n\t  return typeof obj;\n\t}\n\t\n\texports.Library = Library;\n\t\n\t/**\n\t * ### Library\n\t *\n\t * Create a repository for custom type detection.\n\t *\n\t * ```js\n\t * var lib = new type.Library;\n\t * ```\n\t *\n\t */\n\t\n\tfunction Library () {\n\t  this.tests = {};\n\t}\n\t\n\t/**\n\t * #### .of (obj)\n\t *\n\t * Expose replacement `typeof` detection to the library.\n\t *\n\t * ```js\n\t * if ('string' === lib.of('hello world')) {\n\t *   // ...\n\t * }\n\t * ```\n\t *\n\t * @param {Mixed} object to test\n\t * @return {String} type\n\t */\n\t\n\tLibrary.prototype.of = getType;\n\t\n\t/**\n\t * #### .define (type, test)\n\t *\n\t * Add a test to for the `.test()` assertion.\n\t *\n\t * Can be defined as a regular expression:\n\t *\n\t * ```js\n\t * lib.define('int', /^[0-9]+$/);\n\t * ```\n\t *\n\t * ... or as a function:\n\t *\n\t * ```js\n\t * lib.define('bln', function (obj) {\n\t *   if ('boolean' === lib.of(obj)) return true;\n\t *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];\n\t *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();\n\t *   return !! ~blns.indexOf(obj);\n\t * });\n\t * ```\n\t *\n\t * @param {String} type\n\t * @param {RegExp|Function} test\n\t * @api public\n\t */\n\t\n\tLibrary.prototype.define = function (type, test) {\n\t  if (arguments.length === 1) return this.tests[type];\n\t  this.tests[type] = test;\n\t  return this;\n\t};\n\t\n\t/**\n\t * #### .test (obj, test)\n\t *\n\t * Assert that an object is of type. Will first\n\t * check natives, and if that does not pass it will\n\t * use the user defined custom tests.\n\t *\n\t * ```js\n\t * assert(lib.test('1', 'int'));\n\t * assert(lib.test('yes', 'bln'));\n\t * ```\n\t *\n\t * @param {Mixed} object\n\t * @param {String} type\n\t * @return {Boolean} result\n\t * @api public\n\t */\n\t\n\tLibrary.prototype.test = function (obj, type) {\n\t  if (type === getType(obj)) return true;\n\t  var test = this.tests[type];\n\t\n\t  if (test && 'regexp' === getType(test)) {\n\t    return test.test(obj);\n\t  } else if (test && 'function' === getType(test)) {\n\t    return test(obj);\n\t  } else {\n\t    throw new ReferenceError('Type test \"' + type + '\" not defined or invalid.');\n\t  }\n\t};\n\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(Buffer, global) {/*!\n\t * The buffer module from node.js, for the browser.\n\t *\n\t * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n\t * @license  MIT\n\t */\n\t/* eslint-disable no-proto */\n\t\n\tvar base64 = __webpack_require__(34)\n\tvar ieee754 = __webpack_require__(35)\n\tvar isArray = __webpack_require__(36)\n\t\n\texports.Buffer = Buffer\n\texports.SlowBuffer = SlowBuffer\n\texports.INSPECT_MAX_BYTES = 50\n\tBuffer.poolSize = 8192 // not used by this implementation\n\t\n\tvar rootParent = {}\n\t\n\t/**\n\t * If `Buffer.TYPED_ARRAY_SUPPORT`:\n\t *   === true    Use Uint8Array implementation (fastest)\n\t *   === false   Use Object implementation (most compatible, even IE6)\n\t *\n\t * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n\t * Opera 11.6+, iOS 4.2+.\n\t *\n\t * Due to various browser bugs, sometimes the Object implementation will be used even\n\t * when the browser supports typed arrays.\n\t *\n\t * Note:\n\t *\n\t *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n\t *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n\t *\n\t *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property\n\t *     on objects.\n\t *\n\t *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n\t *\n\t *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n\t *     incorrect length in some situations.\n\t\n\t * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n\t * get the Object implementation, which is slower but behaves correctly.\n\t */\n\tBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n\t  ? global.TYPED_ARRAY_SUPPORT\n\t  : typedArraySupport()\n\t\n\tfunction typedArraySupport () {\n\t  function Bar () {}\n\t  try {\n\t    var arr = new Uint8Array(1)\n\t    arr.foo = function () { return 42 }\n\t    arr.constructor = Bar\n\t    return arr.foo() === 42 && // typed array instances can be augmented\n\t        arr.constructor === Bar && // constructor can be set\n\t        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n\t        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n\t  } catch (e) {\n\t    return false\n\t  }\n\t}\n\t\n\tfunction kMaxLength () {\n\t  return Buffer.TYPED_ARRAY_SUPPORT\n\t    ? 0x7fffffff\n\t    : 0x3fffffff\n\t}\n\t\n\t/**\n\t * Class: Buffer\n\t * =============\n\t *\n\t * The Buffer constructor returns instances of `Uint8Array` that are augmented\n\t * with function properties for all the node `Buffer` API functions. We use\n\t * `Uint8Array` so that square bracket notation works as expected -- it returns\n\t * a single octet.\n\t *\n\t * By augmenting the instances, we can avoid modifying the `Uint8Array`\n\t * prototype.\n\t */\n\tfunction Buffer (arg) {\n\t  if (!(this instanceof Buffer)) {\n\t    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\n\t    if (arguments.length > 1) return new Buffer(arg, arguments[1])\n\t    return new Buffer(arg)\n\t  }\n\t\n\t  this.length = 0\n\t  this.parent = undefined\n\t\n\t  // Common case.\n\t  if (typeof arg === 'number') {\n\t    return fromNumber(this, arg)\n\t  }\n\t\n\t  // Slightly less common case.\n\t  if (typeof arg === 'string') {\n\t    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\n\t  }\n\t\n\t  // Unusual.\n\t  return fromObject(this, arg)\n\t}\n\t\n\tfunction fromNumber (that, length) {\n\t  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n\t    for (var i = 0; i < length; i++) {\n\t      that[i] = 0\n\t    }\n\t  }\n\t  return that\n\t}\n\t\n\tfunction fromString (that, string, encoding) {\n\t  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\n\t\n\t  // Assumption: byteLength() return value is always < kMaxLength.\n\t  var length = byteLength(string, encoding) | 0\n\t  that = allocate(that, length)\n\t\n\t  that.write(string, encoding)\n\t  return that\n\t}\n\t\n\tfunction fromObject (that, object) {\n\t  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\n\t\n\t  if (isArray(object)) return fromArray(that, object)\n\t\n\t  if (object == null) {\n\t    throw new TypeError('must start with number, buffer, array or string')\n\t  }\n\t\n\t  if (typeof ArrayBuffer !== 'undefined') {\n\t    if (object.buffer instanceof ArrayBuffer) {\n\t      return fromTypedArray(that, object)\n\t    }\n\t    if (object instanceof ArrayBuffer) {\n\t      return fromArrayBuffer(that, object)\n\t    }\n\t  }\n\t\n\t  if (object.length) return fromArrayLike(that, object)\n\t\n\t  return fromJsonObject(that, object)\n\t}\n\t\n\tfunction fromBuffer (that, buffer) {\n\t  var length = checked(buffer.length) | 0\n\t  that = allocate(that, length)\n\t  buffer.copy(that, 0, 0, length)\n\t  return that\n\t}\n\t\n\tfunction fromArray (that, array) {\n\t  var length = checked(array.length) | 0\n\t  that = allocate(that, length)\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255\n\t  }\n\t  return that\n\t}\n\t\n\t// Duplicate of fromArray() to keep fromArray() monomorphic.\n\tfunction fromTypedArray (that, array) {\n\t  var length = checked(array.length) | 0\n\t  that = allocate(that, length)\n\t  // Truncating the elements is probably not what people expect from typed\n\t  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\n\t  // of the old Buffer constructor.\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255\n\t  }\n\t  return that\n\t}\n\t\n\tfunction fromArrayBuffer (that, array) {\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // Return an augmented `Uint8Array` instance, for best performance\n\t    array.byteLength\n\t    that = Buffer._augment(new Uint8Array(array))\n\t  } else {\n\t    // Fallback: Return an object instance of the Buffer class\n\t    that = fromTypedArray(that, new Uint8Array(array))\n\t  }\n\t  return that\n\t}\n\t\n\tfunction fromArrayLike (that, array) {\n\t  var length = checked(array.length) | 0\n\t  that = allocate(that, length)\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255\n\t  }\n\t  return that\n\t}\n\t\n\t// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\n\t// Returns a zero-length buffer for inputs that don't conform to the spec.\n\tfunction fromJsonObject (that, object) {\n\t  var array\n\t  var length = 0\n\t\n\t  if (object.type === 'Buffer' && isArray(object.data)) {\n\t    array = object.data\n\t    length = checked(array.length) | 0\n\t  }\n\t  that = allocate(that, length)\n\t\n\t  for (var i = 0; i < length; i += 1) {\n\t    that[i] = array[i] & 255\n\t  }\n\t  return that\n\t}\n\t\n\tif (Buffer.TYPED_ARRAY_SUPPORT) {\n\t  Buffer.prototype.__proto__ = Uint8Array.prototype\n\t  Buffer.__proto__ = Uint8Array\n\t}\n\t\n\tfunction allocate (that, length) {\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // Return an augmented `Uint8Array` instance, for best performance\n\t    that = Buffer._augment(new Uint8Array(length))\n\t    that.__proto__ = Buffer.prototype\n\t  } else {\n\t    // Fallback: Return an object instance of the Buffer class\n\t    that.length = length\n\t    that._isBuffer = true\n\t  }\n\t\n\t  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\n\t  if (fromPool) that.parent = rootParent\n\t\n\t  return that\n\t}\n\t\n\tfunction checked (length) {\n\t  // Note: cannot use `length < kMaxLength` here because that fails when\n\t  // length is NaN (which is otherwise coerced to zero.)\n\t  if (length >= kMaxLength()) {\n\t    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n\t                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n\t  }\n\t  return length | 0\n\t}\n\t\n\tfunction SlowBuffer (subject, encoding) {\n\t  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n\t\n\t  var buf = new Buffer(subject, encoding)\n\t  delete buf.parent\n\t  return buf\n\t}\n\t\n\tBuffer.isBuffer = function isBuffer (b) {\n\t  return !!(b != null && b._isBuffer)\n\t}\n\t\n\tBuffer.compare = function compare (a, b) {\n\t  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n\t    throw new TypeError('Arguments must be Buffers')\n\t  }\n\t\n\t  if (a === b) return 0\n\t\n\t  var x = a.length\n\t  var y = b.length\n\t\n\t  var i = 0\n\t  var len = Math.min(x, y)\n\t  while (i < len) {\n\t    if (a[i] !== b[i]) break\n\t\n\t    ++i\n\t  }\n\t\n\t  if (i !== len) {\n\t    x = a[i]\n\t    y = b[i]\n\t  }\n\t\n\t  if (x < y) return -1\n\t  if (y < x) return 1\n\t  return 0\n\t}\n\t\n\tBuffer.isEncoding = function isEncoding (encoding) {\n\t  switch (String(encoding).toLowerCase()) {\n\t    case 'hex':\n\t    case 'utf8':\n\t    case 'utf-8':\n\t    case 'ascii':\n\t    case 'binary':\n\t    case 'base64':\n\t    case 'raw':\n\t    case 'ucs2':\n\t    case 'ucs-2':\n\t    case 'utf16le':\n\t    case 'utf-16le':\n\t      return true\n\t    default:\n\t      return false\n\t  }\n\t}\n\t\n\tBuffer.concat = function concat (list, length) {\n\t  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n\t\n\t  if (list.length === 0) {\n\t    return new Buffer(0)\n\t  }\n\t\n\t  var i\n\t  if (length === undefined) {\n\t    length = 0\n\t    for (i = 0; i < list.length; i++) {\n\t      length += list[i].length\n\t    }\n\t  }\n\t\n\t  var buf = new Buffer(length)\n\t  var pos = 0\n\t  for (i = 0; i < list.length; i++) {\n\t    var item = list[i]\n\t    item.copy(buf, pos)\n\t    pos += item.length\n\t  }\n\t  return buf\n\t}\n\t\n\tfunction byteLength (string, encoding) {\n\t  if (typeof string !== 'string') string = '' + string\n\t\n\t  var len = string.length\n\t  if (len === 0) return 0\n\t\n\t  // Use a for loop to avoid recursion\n\t  var loweredCase = false\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'ascii':\n\t      case 'binary':\n\t      // Deprecated\n\t      case 'raw':\n\t      case 'raws':\n\t        return len\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8ToBytes(string).length\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return len * 2\n\t      case 'hex':\n\t        return len >>> 1\n\t      case 'base64':\n\t        return base64ToBytes(string).length\n\t      default:\n\t        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n\t        encoding = ('' + encoding).toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\tBuffer.byteLength = byteLength\n\t\n\t// pre-set for values that may exist in the future\n\tBuffer.prototype.length = undefined\n\tBuffer.prototype.parent = undefined\n\t\n\tfunction slowToString (encoding, start, end) {\n\t  var loweredCase = false\n\t\n\t  start = start | 0\n\t  end = end === undefined || end === Infinity ? this.length : end | 0\n\t\n\t  if (!encoding) encoding = 'utf8'\n\t  if (start < 0) start = 0\n\t  if (end > this.length) end = this.length\n\t  if (end <= start) return ''\n\t\n\t  while (true) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexSlice(this, start, end)\n\t\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Slice(this, start, end)\n\t\n\t      case 'ascii':\n\t        return asciiSlice(this, start, end)\n\t\n\t      case 'binary':\n\t        return binarySlice(this, start, end)\n\t\n\t      case 'base64':\n\t        return base64Slice(this, start, end)\n\t\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return utf16leSlice(this, start, end)\n\t\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = (encoding + '').toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\t\n\tBuffer.prototype.toString = function toString () {\n\t  var length = this.length | 0\n\t  if (length === 0) return ''\n\t  if (arguments.length === 0) return utf8Slice(this, 0, length)\n\t  return slowToString.apply(this, arguments)\n\t}\n\t\n\tBuffer.prototype.equals = function equals (b) {\n\t  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n\t  if (this === b) return true\n\t  return Buffer.compare(this, b) === 0\n\t}\n\t\n\tBuffer.prototype.inspect = function inspect () {\n\t  var str = ''\n\t  var max = exports.INSPECT_MAX_BYTES\n\t  if (this.length > 0) {\n\t    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n\t    if (this.length > max) str += ' ... '\n\t  }\n\t  return '<Buffer ' + str + '>'\n\t}\n\t\n\tBuffer.prototype.compare = function compare (b) {\n\t  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n\t  if (this === b) return 0\n\t  return Buffer.compare(this, b)\n\t}\n\t\n\tBuffer.prototype.indexOf = function indexOf (val, byteOffset) {\n\t  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n\t  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n\t  byteOffset >>= 0\n\t\n\t  if (this.length === 0) return -1\n\t  if (byteOffset >= this.length) return -1\n\t\n\t  // Negative offsets start from the end of the buffer\n\t  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n\t\n\t  if (typeof val === 'string') {\n\t    if (val.length === 0) return -1 // special case: looking for empty string always fails\n\t    return String.prototype.indexOf.call(this, val, byteOffset)\n\t  }\n\t  if (Buffer.isBuffer(val)) {\n\t    return arrayIndexOf(this, val, byteOffset)\n\t  }\n\t  if (typeof val === 'number') {\n\t    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n\t      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n\t    }\n\t    return arrayIndexOf(this, [ val ], byteOffset)\n\t  }\n\t\n\t  function arrayIndexOf (arr, val, byteOffset) {\n\t    var foundIndex = -1\n\t    for (var i = 0; byteOffset + i < arr.length; i++) {\n\t      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n\t        if (foundIndex === -1) foundIndex = i\n\t        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n\t      } else {\n\t        foundIndex = -1\n\t      }\n\t    }\n\t    return -1\n\t  }\n\t\n\t  throw new TypeError('val must be string, number or Buffer')\n\t}\n\t\n\t// `get` is deprecated\n\tBuffer.prototype.get = function get (offset) {\n\t  console.log('.get() is deprecated. Access using array indexes instead.')\n\t  return this.readUInt8(offset)\n\t}\n\t\n\t// `set` is deprecated\n\tBuffer.prototype.set = function set (v, offset) {\n\t  console.log('.set() is deprecated. Access using array indexes instead.')\n\t  return this.writeUInt8(v, offset)\n\t}\n\t\n\tfunction hexWrite (buf, string, offset, length) {\n\t  offset = Number(offset) || 0\n\t  var remaining = buf.length - offset\n\t  if (!length) {\n\t    length = remaining\n\t  } else {\n\t    length = Number(length)\n\t    if (length > remaining) {\n\t      length = remaining\n\t    }\n\t  }\n\t\n\t  // must be an even number of digits\n\t  var strLen = string.length\n\t  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\t\n\t  if (length > strLen / 2) {\n\t    length = strLen / 2\n\t  }\n\t  for (var i = 0; i < length; i++) {\n\t    var parsed = parseInt(string.substr(i * 2, 2), 16)\n\t    if (isNaN(parsed)) throw new Error('Invalid hex string')\n\t    buf[offset + i] = parsed\n\t  }\n\t  return i\n\t}\n\t\n\tfunction utf8Write (buf, string, offset, length) {\n\t  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\t\n\tfunction asciiWrite (buf, string, offset, length) {\n\t  return blitBuffer(asciiToBytes(string), buf, offset, length)\n\t}\n\t\n\tfunction binaryWrite (buf, string, offset, length) {\n\t  return asciiWrite(buf, string, offset, length)\n\t}\n\t\n\tfunction base64Write (buf, string, offset, length) {\n\t  return blitBuffer(base64ToBytes(string), buf, offset, length)\n\t}\n\t\n\tfunction ucs2Write (buf, string, offset, length) {\n\t  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n\t}\n\t\n\tBuffer.prototype.write = function write (string, offset, length, encoding) {\n\t  // Buffer#write(string)\n\t  if (offset === undefined) {\n\t    encoding = 'utf8'\n\t    length = this.length\n\t    offset = 0\n\t  // Buffer#write(string, encoding)\n\t  } else if (length === undefined && typeof offset === 'string') {\n\t    encoding = offset\n\t    length = this.length\n\t    offset = 0\n\t  // Buffer#write(string, offset[, length][, encoding])\n\t  } else if (isFinite(offset)) {\n\t    offset = offset | 0\n\t    if (isFinite(length)) {\n\t      length = length | 0\n\t      if (encoding === undefined) encoding = 'utf8'\n\t    } else {\n\t      encoding = length\n\t      length = undefined\n\t    }\n\t  // legacy write(string, encoding, offset, length) - remove in v0.13\n\t  } else {\n\t    var swap = encoding\n\t    encoding = offset\n\t    offset = length | 0\n\t    length = swap\n\t  }\n\t\n\t  var remaining = this.length - offset\n\t  if (length === undefined || length > remaining) length = remaining\n\t\n\t  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n\t    throw new RangeError('attempt to write outside buffer bounds')\n\t  }\n\t\n\t  if (!encoding) encoding = 'utf8'\n\t\n\t  var loweredCase = false\n\t  for (;;) {\n\t    switch (encoding) {\n\t      case 'hex':\n\t        return hexWrite(this, string, offset, length)\n\t\n\t      case 'utf8':\n\t      case 'utf-8':\n\t        return utf8Write(this, string, offset, length)\n\t\n\t      case 'ascii':\n\t        return asciiWrite(this, string, offset, length)\n\t\n\t      case 'binary':\n\t        return binaryWrite(this, string, offset, length)\n\t\n\t      case 'base64':\n\t        // Warning: maxLength not taken into account in base64Write\n\t        return base64Write(this, string, offset, length)\n\t\n\t      case 'ucs2':\n\t      case 'ucs-2':\n\t      case 'utf16le':\n\t      case 'utf-16le':\n\t        return ucs2Write(this, string, offset, length)\n\t\n\t      default:\n\t        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n\t        encoding = ('' + encoding).toLowerCase()\n\t        loweredCase = true\n\t    }\n\t  }\n\t}\n\t\n\tBuffer.prototype.toJSON = function toJSON () {\n\t  return {\n\t    type: 'Buffer',\n\t    data: Array.prototype.slice.call(this._arr || this, 0)\n\t  }\n\t}\n\t\n\tfunction base64Slice (buf, start, end) {\n\t  if (start === 0 && end === buf.length) {\n\t    return base64.fromByteArray(buf)\n\t  } else {\n\t    return base64.fromByteArray(buf.slice(start, end))\n\t  }\n\t}\n\t\n\tfunction utf8Slice (buf, start, end) {\n\t  end = Math.min(buf.length, end)\n\t  var res = []\n\t\n\t  var i = start\n\t  while (i < end) {\n\t    var firstByte = buf[i]\n\t    var codePoint = null\n\t    var bytesPerSequence = (firstByte > 0xEF) ? 4\n\t      : (firstByte > 0xDF) ? 3\n\t      : (firstByte > 0xBF) ? 2\n\t      : 1\n\t\n\t    if (i + bytesPerSequence <= end) {\n\t      var secondByte, thirdByte, fourthByte, tempCodePoint\n\t\n\t      switch (bytesPerSequence) {\n\t        case 1:\n\t          if (firstByte < 0x80) {\n\t            codePoint = firstByte\n\t          }\n\t          break\n\t        case 2:\n\t          secondByte = buf[i + 1]\n\t          if ((secondByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n\t            if (tempCodePoint > 0x7F) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t          break\n\t        case 3:\n\t          secondByte = buf[i + 1]\n\t          thirdByte = buf[i + 2]\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n\t            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t          break\n\t        case 4:\n\t          secondByte = buf[i + 1]\n\t          thirdByte = buf[i + 2]\n\t          fourthByte = buf[i + 3]\n\t          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n\t            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n\t            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n\t              codePoint = tempCodePoint\n\t            }\n\t          }\n\t      }\n\t    }\n\t\n\t    if (codePoint === null) {\n\t      // we did not generate a valid codePoint so insert a\n\t      // replacement char (U+FFFD) and advance only 1 byte\n\t      codePoint = 0xFFFD\n\t      bytesPerSequence = 1\n\t    } else if (codePoint > 0xFFFF) {\n\t      // encode to utf16 (surrogate pair dance)\n\t      codePoint -= 0x10000\n\t      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n\t      codePoint = 0xDC00 | codePoint & 0x3FF\n\t    }\n\t\n\t    res.push(codePoint)\n\t    i += bytesPerSequence\n\t  }\n\t\n\t  return decodeCodePointsArray(res)\n\t}\n\t\n\t// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n\t// the lowest limit is Chrome, with 0x10000 args.\n\t// We go 1 magnitude less, for safety\n\tvar MAX_ARGUMENTS_LENGTH = 0x1000\n\t\n\tfunction decodeCodePointsArray (codePoints) {\n\t  var len = codePoints.length\n\t  if (len <= MAX_ARGUMENTS_LENGTH) {\n\t    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n\t  }\n\t\n\t  // Decode in chunks to avoid \"call stack size exceeded\".\n\t  var res = ''\n\t  var i = 0\n\t  while (i < len) {\n\t    res += String.fromCharCode.apply(\n\t      String,\n\t      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n\t    )\n\t  }\n\t  return res\n\t}\n\t\n\tfunction asciiSlice (buf, start, end) {\n\t  var ret = ''\n\t  end = Math.min(buf.length, end)\n\t\n\t  for (var i = start; i < end; i++) {\n\t    ret += String.fromCharCode(buf[i] & 0x7F)\n\t  }\n\t  return ret\n\t}\n\t\n\tfunction binarySlice (buf, start, end) {\n\t  var ret = ''\n\t  end = Math.min(buf.length, end)\n\t\n\t  for (var i = start; i < end; i++) {\n\t    ret += String.fromCharCode(buf[i])\n\t  }\n\t  return ret\n\t}\n\t\n\tfunction hexSlice (buf, start, end) {\n\t  var len = buf.length\n\t\n\t  if (!start || start < 0) start = 0\n\t  if (!end || end < 0 || end > len) end = len\n\t\n\t  var out = ''\n\t  for (var i = start; i < end; i++) {\n\t    out += toHex(buf[i])\n\t  }\n\t  return out\n\t}\n\t\n\tfunction utf16leSlice (buf, start, end) {\n\t  var bytes = buf.slice(start, end)\n\t  var res = ''\n\t  for (var i = 0; i < bytes.length; i += 2) {\n\t    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n\t  }\n\t  return res\n\t}\n\t\n\tBuffer.prototype.slice = function slice (start, end) {\n\t  var len = this.length\n\t  start = ~~start\n\t  end = end === undefined ? len : ~~end\n\t\n\t  if (start < 0) {\n\t    start += len\n\t    if (start < 0) start = 0\n\t  } else if (start > len) {\n\t    start = len\n\t  }\n\t\n\t  if (end < 0) {\n\t    end += len\n\t    if (end < 0) end = 0\n\t  } else if (end > len) {\n\t    end = len\n\t  }\n\t\n\t  if (end < start) end = start\n\t\n\t  var newBuf\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    newBuf = Buffer._augment(this.subarray(start, end))\n\t  } else {\n\t    var sliceLen = end - start\n\t    newBuf = new Buffer(sliceLen, undefined)\n\t    for (var i = 0; i < sliceLen; i++) {\n\t      newBuf[i] = this[i + start]\n\t    }\n\t  }\n\t\n\t  if (newBuf.length) newBuf.parent = this.parent || this\n\t\n\t  return newBuf\n\t}\n\t\n\t/*\n\t * Need to make sure that buffer isn't trying to write out of bounds.\n\t */\n\tfunction checkOffset (offset, ext, length) {\n\t  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n\t  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n\t}\n\t\n\tBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var val = this[offset]\n\t  var mul = 1\n\t  var i = 0\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul\n\t  }\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) {\n\t    checkOffset(offset, byteLength, this.length)\n\t  }\n\t\n\t  var val = this[offset + --byteLength]\n\t  var mul = 1\n\t  while (byteLength > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --byteLength] * mul\n\t  }\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 1, this.length)\n\t  return this[offset]\n\t}\n\t\n\tBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  return this[offset] | (this[offset + 1] << 8)\n\t}\n\t\n\tBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  return (this[offset] << 8) | this[offset + 1]\n\t}\n\t\n\tBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return ((this[offset]) |\n\t      (this[offset + 1] << 8) |\n\t      (this[offset + 2] << 16)) +\n\t      (this[offset + 3] * 0x1000000)\n\t}\n\t\n\tBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset] * 0x1000000) +\n\t    ((this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    this[offset + 3])\n\t}\n\t\n\tBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var val = this[offset]\n\t  var mul = 1\n\t  var i = 0\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    val += this[offset + i] * mul\n\t  }\n\t  mul *= 0x80\n\t\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\t\n\t  var i = byteLength\n\t  var mul = 1\n\t  var val = this[offset + --i]\n\t  while (i > 0 && (mul *= 0x100)) {\n\t    val += this[offset + --i] * mul\n\t  }\n\t  mul *= 0x80\n\t\n\t  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\t\n\t  return val\n\t}\n\t\n\tBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 1, this.length)\n\t  if (!(this[offset] & 0x80)) return (this[offset])\n\t  return ((0xff - this[offset] + 1) * -1)\n\t}\n\t\n\tBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  var val = this[offset] | (this[offset + 1] << 8)\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t}\n\t\n\tBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 2, this.length)\n\t  var val = this[offset + 1] | (this[offset] << 8)\n\t  return (val & 0x8000) ? val | 0xFFFF0000 : val\n\t}\n\t\n\tBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset]) |\n\t    (this[offset + 1] << 8) |\n\t    (this[offset + 2] << 16) |\n\t    (this[offset + 3] << 24)\n\t}\n\t\n\tBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t\n\t  return (this[offset] << 24) |\n\t    (this[offset + 1] << 16) |\n\t    (this[offset + 2] << 8) |\n\t    (this[offset + 3])\n\t}\n\t\n\tBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t  return ieee754.read(this, offset, true, 23, 4)\n\t}\n\t\n\tBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 4, this.length)\n\t  return ieee754.read(this, offset, false, 23, 4)\n\t}\n\t\n\tBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 8, this.length)\n\t  return ieee754.read(this, offset, true, 52, 8)\n\t}\n\t\n\tBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n\t  if (!noAssert) checkOffset(offset, 8, this.length)\n\t  return ieee754.read(this, offset, false, 52, 8)\n\t}\n\t\n\tfunction checkInt (buf, value, offset, ext, max, min) {\n\t  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n\t  if (value > max || value < min) throw new RangeError('value is out of bounds')\n\t  if (offset + ext > buf.length) throw new RangeError('index out of range')\n\t}\n\t\n\tBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\t\n\t  var mul = 1\n\t  var i = 0\n\t  this[offset] = value & 0xFF\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  byteLength = byteLength | 0\n\t  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\t\n\t  var i = byteLength - 1\n\t  var mul = 1\n\t  this[offset + i] = value & 0xFF\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    this[offset + i] = (value / mul) & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n\t  this[offset] = (value & 0xff)\n\t  return offset + 1\n\t}\n\t\n\tfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffff + value + 1\n\t  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n\t    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n\t      (littleEndian ? i : 1 - i) * 8\n\t  }\n\t}\n\t\n\tBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, true)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8)\n\t    this[offset + 1] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, false)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n\t  if (value < 0) value = 0xffffffff + value + 1\n\t  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n\t    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n\t  }\n\t}\n\t\n\tBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset + 3] = (value >>> 24)\n\t    this[offset + 2] = (value >>> 16)\n\t    this[offset + 1] = (value >>> 8)\n\t    this[offset] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, true)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24)\n\t    this[offset + 1] = (value >>> 16)\n\t    this[offset + 2] = (value >>> 8)\n\t    this[offset + 3] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, false)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) {\n\t    var limit = Math.pow(2, 8 * byteLength - 1)\n\t\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n\t  }\n\t\n\t  var i = 0\n\t  var mul = 1\n\t  var sub = value < 0 ? 1 : 0\n\t  this[offset] = value & 0xFF\n\t  while (++i < byteLength && (mul *= 0x100)) {\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) {\n\t    var limit = Math.pow(2, 8 * byteLength - 1)\n\t\n\t    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n\t  }\n\t\n\t  var i = byteLength - 1\n\t  var mul = 1\n\t  var sub = value < 0 ? 1 : 0\n\t  this[offset + i] = value & 0xFF\n\t  while (--i >= 0 && (mul *= 0x100)) {\n\t    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n\t  }\n\t\n\t  return offset + byteLength\n\t}\n\t\n\tBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n\t  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n\t  if (value < 0) value = 0xff + value + 1\n\t  this[offset] = (value & 0xff)\n\t  return offset + 1\n\t}\n\t\n\tBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, true)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 8)\n\t    this[offset + 1] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt16(this, value, offset, false)\n\t  }\n\t  return offset + 2\n\t}\n\t\n\tBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value & 0xff)\n\t    this[offset + 1] = (value >>> 8)\n\t    this[offset + 2] = (value >>> 16)\n\t    this[offset + 3] = (value >>> 24)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, true)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n\t  value = +value\n\t  offset = offset | 0\n\t  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n\t  if (value < 0) value = 0xffffffff + value + 1\n\t  if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t    this[offset] = (value >>> 24)\n\t    this[offset + 1] = (value >>> 16)\n\t    this[offset + 2] = (value >>> 8)\n\t    this[offset + 3] = (value & 0xff)\n\t  } else {\n\t    objectWriteUInt32(this, value, offset, false)\n\t  }\n\t  return offset + 4\n\t}\n\t\n\tfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n\t  if (value > max || value < min) throw new RangeError('value is out of bounds')\n\t  if (offset + ext > buf.length) throw new RangeError('index out of range')\n\t  if (offset < 0) throw new RangeError('index out of range')\n\t}\n\t\n\tfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n\t  }\n\t  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n\t  return offset + 4\n\t}\n\t\n\tBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, true, noAssert)\n\t}\n\t\n\tBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n\t  return writeFloat(this, value, offset, false, noAssert)\n\t}\n\t\n\tfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n\t  if (!noAssert) {\n\t    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n\t  }\n\t  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n\t  return offset + 8\n\t}\n\t\n\tBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, true, noAssert)\n\t}\n\t\n\tBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n\t  return writeDouble(this, value, offset, false, noAssert)\n\t}\n\t\n\t// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\tBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n\t  if (!start) start = 0\n\t  if (!end && end !== 0) end = this.length\n\t  if (targetStart >= target.length) targetStart = target.length\n\t  if (!targetStart) targetStart = 0\n\t  if (end > 0 && end < start) end = start\n\t\n\t  // Copy 0 bytes; we're done\n\t  if (end === start) return 0\n\t  if (target.length === 0 || this.length === 0) return 0\n\t\n\t  // Fatal error conditions\n\t  if (targetStart < 0) {\n\t    throw new RangeError('targetStart out of bounds')\n\t  }\n\t  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n\t  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\t\n\t  // Are we oob?\n\t  if (end > this.length) end = this.length\n\t  if (target.length - targetStart < end - start) {\n\t    end = target.length - targetStart + start\n\t  }\n\t\n\t  var len = end - start\n\t  var i\n\t\n\t  if (this === target && start < targetStart && targetStart < end) {\n\t    // descending copy from end\n\t    for (i = len - 1; i >= 0; i--) {\n\t      target[i + targetStart] = this[i + start]\n\t    }\n\t  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n\t    // ascending copy from start\n\t    for (i = 0; i < len; i++) {\n\t      target[i + targetStart] = this[i + start]\n\t    }\n\t  } else {\n\t    target._set(this.subarray(start, start + len), targetStart)\n\t  }\n\t\n\t  return len\n\t}\n\t\n\t// fill(value, start=0, end=buffer.length)\n\tBuffer.prototype.fill = function fill (value, start, end) {\n\t  if (!value) value = 0\n\t  if (!start) start = 0\n\t  if (!end) end = this.length\n\t\n\t  if (end < start) throw new RangeError('end < start')\n\t\n\t  // Fill 0 bytes; we're done\n\t  if (end === start) return\n\t  if (this.length === 0) return\n\t\n\t  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n\t  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n\t\n\t  var i\n\t  if (typeof value === 'number') {\n\t    for (i = start; i < end; i++) {\n\t      this[i] = value\n\t    }\n\t  } else {\n\t    var bytes = utf8ToBytes(value.toString())\n\t    var len = bytes.length\n\t    for (i = start; i < end; i++) {\n\t      this[i] = bytes[i % len]\n\t    }\n\t  }\n\t\n\t  return this\n\t}\n\t\n\t/**\n\t * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n\t * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n\t */\n\tBuffer.prototype.toArrayBuffer = function toArrayBuffer () {\n\t  if (typeof Uint8Array !== 'undefined') {\n\t    if (Buffer.TYPED_ARRAY_SUPPORT) {\n\t      return (new Buffer(this)).buffer\n\t    } else {\n\t      var buf = new Uint8Array(this.length)\n\t      for (var i = 0, len = buf.length; i < len; i += 1) {\n\t        buf[i] = this[i]\n\t      }\n\t      return buf.buffer\n\t    }\n\t  } else {\n\t    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')\n\t  }\n\t}\n\t\n\t// HELPER FUNCTIONS\n\t// ================\n\t\n\tvar BP = Buffer.prototype\n\t\n\t/**\n\t * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n\t */\n\tBuffer._augment = function _augment (arr) {\n\t  arr.constructor = Buffer\n\t  arr._isBuffer = true\n\t\n\t  // save reference to original Uint8Array set method before overwriting\n\t  arr._set = arr.set\n\t\n\t  // deprecated\n\t  arr.get = BP.get\n\t  arr.set = BP.set\n\t\n\t  arr.write = BP.write\n\t  arr.toString = BP.toString\n\t  arr.toLocaleString = BP.toString\n\t  arr.toJSON = BP.toJSON\n\t  arr.equals = BP.equals\n\t  arr.compare = BP.compare\n\t  arr.indexOf = BP.indexOf\n\t  arr.copy = BP.copy\n\t  arr.slice = BP.slice\n\t  arr.readUIntLE = BP.readUIntLE\n\t  arr.readUIntBE = BP.readUIntBE\n\t  arr.readUInt8 = BP.readUInt8\n\t  arr.readUInt16LE = BP.readUInt16LE\n\t  arr.readUInt16BE = BP.readUInt16BE\n\t  arr.readUInt32LE = BP.readUInt32LE\n\t  arr.readUInt32BE = BP.readUInt32BE\n\t  arr.readIntLE = BP.readIntLE\n\t  arr.readIntBE = BP.readIntBE\n\t  arr.readInt8 = BP.readInt8\n\t  arr.readInt16LE = BP.readInt16LE\n\t  arr.readInt16BE = BP.readInt16BE\n\t  arr.readInt32LE = BP.readInt32LE\n\t  arr.readInt32BE = BP.readInt32BE\n\t  arr.readFloatLE = BP.readFloatLE\n\t  arr.readFloatBE = BP.readFloatBE\n\t  arr.readDoubleLE = BP.readDoubleLE\n\t  arr.readDoubleBE = BP.readDoubleBE\n\t  arr.writeUInt8 = BP.writeUInt8\n\t  arr.writeUIntLE = BP.writeUIntLE\n\t  arr.writeUIntBE = BP.writeUIntBE\n\t  arr.writeUInt16LE = BP.writeUInt16LE\n\t  arr.writeUInt16BE = BP.writeUInt16BE\n\t  arr.writeUInt32LE = BP.writeUInt32LE\n\t  arr.writeUInt32BE = BP.writeUInt32BE\n\t  arr.writeIntLE = BP.writeIntLE\n\t  arr.writeIntBE = BP.writeIntBE\n\t  arr.writeInt8 = BP.writeInt8\n\t  arr.writeInt16LE = BP.writeInt16LE\n\t  arr.writeInt16BE = BP.writeInt16BE\n\t  arr.writeInt32LE = BP.writeInt32LE\n\t  arr.writeInt32BE = BP.writeInt32BE\n\t  arr.writeFloatLE = BP.writeFloatLE\n\t  arr.writeFloatBE = BP.writeFloatBE\n\t  arr.writeDoubleLE = BP.writeDoubleLE\n\t  arr.writeDoubleBE = BP.writeDoubleBE\n\t  arr.fill = BP.fill\n\t  arr.inspect = BP.inspect\n\t  arr.toArrayBuffer = BP.toArrayBuffer\n\t\n\t  return arr\n\t}\n\t\n\tvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\t\n\tfunction base64clean (str) {\n\t  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n\t  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n\t  // Node converts strings with length < 2 to ''\n\t  if (str.length < 2) return ''\n\t  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\t  while (str.length % 4 !== 0) {\n\t    str = str + '='\n\t  }\n\t  return str\n\t}\n\t\n\tfunction stringtrim (str) {\n\t  if (str.trim) return str.trim()\n\t  return str.replace(/^\\s+|\\s+$/g, '')\n\t}\n\t\n\tfunction toHex (n) {\n\t  if (n < 16) return '0' + n.toString(16)\n\t  return n.toString(16)\n\t}\n\t\n\tfunction utf8ToBytes (string, units) {\n\t  units = units || Infinity\n\t  var codePoint\n\t  var length = string.length\n\t  var leadSurrogate = null\n\t  var bytes = []\n\t\n\t  for (var i = 0; i < length; i++) {\n\t    codePoint = string.charCodeAt(i)\n\t\n\t    // is surrogate component\n\t    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n\t      // last char was a lead\n\t      if (!leadSurrogate) {\n\t        // no lead yet\n\t        if (codePoint > 0xDBFF) {\n\t          // unexpected trail\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t          continue\n\t        } else if (i + 1 === length) {\n\t          // unpaired lead\n\t          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t          continue\n\t        }\n\t\n\t        // valid lead\n\t        leadSurrogate = codePoint\n\t\n\t        continue\n\t      }\n\t\n\t      // 2 leads in a row\n\t      if (codePoint < 0xDC00) {\n\t        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t        leadSurrogate = codePoint\n\t        continue\n\t      }\n\t\n\t      // valid surrogate pair\n\t      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n\t    } else if (leadSurrogate) {\n\t      // valid bmp char, but last char was a lead\n\t      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n\t    }\n\t\n\t    leadSurrogate = null\n\t\n\t    // encode utf8\n\t    if (codePoint < 0x80) {\n\t      if ((units -= 1) < 0) break\n\t      bytes.push(codePoint)\n\t    } else if (codePoint < 0x800) {\n\t      if ((units -= 2) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x6 | 0xC0,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else if (codePoint < 0x10000) {\n\t      if ((units -= 3) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0xC | 0xE0,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else if (codePoint < 0x110000) {\n\t      if ((units -= 4) < 0) break\n\t      bytes.push(\n\t        codePoint >> 0x12 | 0xF0,\n\t        codePoint >> 0xC & 0x3F | 0x80,\n\t        codePoint >> 0x6 & 0x3F | 0x80,\n\t        codePoint & 0x3F | 0x80\n\t      )\n\t    } else {\n\t      throw new Error('Invalid code point')\n\t    }\n\t  }\n\t\n\t  return bytes\n\t}\n\t\n\tfunction asciiToBytes (str) {\n\t  var byteArray = []\n\t  for (var i = 0; i < str.length; i++) {\n\t    // Node's code seems to be doing this and not & 0x7F..\n\t    byteArray.push(str.charCodeAt(i) & 0xFF)\n\t  }\n\t  return byteArray\n\t}\n\t\n\tfunction utf16leToBytes (str, units) {\n\t  var c, hi, lo\n\t  var byteArray = []\n\t  for (var i = 0; i < str.length; i++) {\n\t    if ((units -= 2) < 0) break\n\t\n\t    c = str.charCodeAt(i)\n\t    hi = c >> 8\n\t    lo = c % 256\n\t    byteArray.push(lo)\n\t    byteArray.push(hi)\n\t  }\n\t\n\t  return byteArray\n\t}\n\t\n\tfunction base64ToBytes (str) {\n\t  return base64.toByteArray(base64clean(str))\n\t}\n\t\n\tfunction blitBuffer (src, dst, offset, length) {\n\t  for (var i = 0; i < length; i++) {\n\t    if ((i + offset >= dst.length) || (i >= src.length)) break\n\t    dst[i + offset] = src[i]\n\t  }\n\t  return i\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(33).Buffer, (function() { return this; }())))\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\t\n\t;(function (exports) {\n\t\t'use strict';\n\t\n\t  var Arr = (typeof Uint8Array !== 'undefined')\n\t    ? Uint8Array\n\t    : Array\n\t\n\t\tvar PLUS   = '+'.charCodeAt(0)\n\t\tvar SLASH  = '/'.charCodeAt(0)\n\t\tvar NUMBER = '0'.charCodeAt(0)\n\t\tvar LOWER  = 'a'.charCodeAt(0)\n\t\tvar UPPER  = 'A'.charCodeAt(0)\n\t\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\n\t\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\n\t\n\t\tfunction decode (elt) {\n\t\t\tvar code = elt.charCodeAt(0)\n\t\t\tif (code === PLUS ||\n\t\t\t    code === PLUS_URL_SAFE)\n\t\t\t\treturn 62 // '+'\n\t\t\tif (code === SLASH ||\n\t\t\t    code === SLASH_URL_SAFE)\n\t\t\t\treturn 63 // '/'\n\t\t\tif (code < NUMBER)\n\t\t\t\treturn -1 //no match\n\t\t\tif (code < NUMBER + 10)\n\t\t\t\treturn code - NUMBER + 26 + 26\n\t\t\tif (code < UPPER + 26)\n\t\t\t\treturn code - UPPER\n\t\t\tif (code < LOWER + 26)\n\t\t\t\treturn code - LOWER + 26\n\t\t}\n\t\n\t\tfunction b64ToByteArray (b64) {\n\t\t\tvar i, j, l, tmp, placeHolders, arr\n\t\n\t\t\tif (b64.length % 4 > 0) {\n\t\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t\t}\n\t\n\t\t\t// the number of equal signs (place holders)\n\t\t\t// if there are two placeholders, than the two characters before it\n\t\t\t// represent one byte\n\t\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t\t// this is just a cheap hack to not do indexOf twice\n\t\t\tvar len = b64.length\n\t\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\t\n\t\t\t// base64 is 4/3 + up to two characters of the original data\n\t\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\t\n\t\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\t\n\t\t\tvar L = 0\n\t\n\t\t\tfunction push (v) {\n\t\t\t\tarr[L++] = v\n\t\t\t}\n\t\n\t\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\t\tpush(tmp & 0xFF)\n\t\t\t}\n\t\n\t\t\tif (placeHolders === 2) {\n\t\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\t\tpush(tmp & 0xFF)\n\t\t\t} else if (placeHolders === 1) {\n\t\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\t\tpush(tmp & 0xFF)\n\t\t\t}\n\t\n\t\t\treturn arr\n\t\t}\n\t\n\t\tfunction uint8ToBase64 (uint8) {\n\t\t\tvar i,\n\t\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\t\toutput = \"\",\n\t\t\t\ttemp, length\n\t\n\t\t\tfunction encode (num) {\n\t\t\t\treturn lookup.charAt(num)\n\t\t\t}\n\t\n\t\t\tfunction tripletToBase64 (num) {\n\t\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t\t}\n\t\n\t\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\t\toutput += tripletToBase64(temp)\n\t\t\t}\n\t\n\t\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\t\tswitch (extraBytes) {\n\t\t\t\tcase 1:\n\t\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\t\toutput += '=='\n\t\t\t\t\tbreak\n\t\t\t\tcase 2:\n\t\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\t\toutput += '='\n\t\t\t\t\tbreak\n\t\t\t}\n\t\n\t\t\treturn output\n\t\t}\n\t\n\t\texports.toByteArray = b64ToByteArray\n\t\texports.fromByteArray = uint8ToBase64\n\t}( false ? (this.base64js = {}) : exports))\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports) {\n\n\texports.read = function (buffer, offset, isLE, mLen, nBytes) {\n\t  var e, m\n\t  var eLen = nBytes * 8 - mLen - 1\n\t  var eMax = (1 << eLen) - 1\n\t  var eBias = eMax >> 1\n\t  var nBits = -7\n\t  var i = isLE ? (nBytes - 1) : 0\n\t  var d = isLE ? -1 : 1\n\t  var s = buffer[offset + i]\n\t\n\t  i += d\n\t\n\t  e = s & ((1 << (-nBits)) - 1)\n\t  s >>= (-nBits)\n\t  nBits += eLen\n\t  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\t\n\t  m = e & ((1 << (-nBits)) - 1)\n\t  e >>= (-nBits)\n\t  nBits += mLen\n\t  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\t\n\t  if (e === 0) {\n\t    e = 1 - eBias\n\t  } else if (e === eMax) {\n\t    return m ? NaN : ((s ? -1 : 1) * Infinity)\n\t  } else {\n\t    m = m + Math.pow(2, mLen)\n\t    e = e - eBias\n\t  }\n\t  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n\t}\n\t\n\texports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n\t  var e, m, c\n\t  var eLen = nBytes * 8 - mLen - 1\n\t  var eMax = (1 << eLen) - 1\n\t  var eBias = eMax >> 1\n\t  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n\t  var i = isLE ? 0 : (nBytes - 1)\n\t  var d = isLE ? 1 : -1\n\t  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\t\n\t  value = Math.abs(value)\n\t\n\t  if (isNaN(value) || value === Infinity) {\n\t    m = isNaN(value) ? 1 : 0\n\t    e = eMax\n\t  } else {\n\t    e = Math.floor(Math.log(value) / Math.LN2)\n\t    if (value * (c = Math.pow(2, -e)) < 1) {\n\t      e--\n\t      c *= 2\n\t    }\n\t    if (e + eBias >= 1) {\n\t      value += rt / c\n\t    } else {\n\t      value += rt * Math.pow(2, 1 - eBias)\n\t    }\n\t    if (value * c >= 2) {\n\t      e++\n\t      c /= 2\n\t    }\n\t\n\t    if (e + eBias >= eMax) {\n\t      m = 0\n\t      e = eMax\n\t    } else if (e + eBias >= 1) {\n\t      m = (value * c - 1) * Math.pow(2, mLen)\n\t      e = e + eBias\n\t    } else {\n\t      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n\t      e = 0\n\t    }\n\t  }\n\t\n\t  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\t\n\t  e = (e << mLen) | m\n\t  eLen += mLen\n\t  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\t\n\t  buffer[offset + i - d] |= s * 128\n\t}\n\n\n/***/ },\n/* 36 */\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t * isArray\n\t */\n\t\n\tvar isArray = Array.isArray;\n\t\n\t/**\n\t * toString\n\t */\n\t\n\tvar str = Object.prototype.toString;\n\t\n\t/**\n\t * Whether or not the given `val`\n\t * is an array.\n\t *\n\t * example:\n\t *\n\t *        isArray([]);\n\t *        // > true\n\t *        isArray(arguments);\n\t *        // > false\n\t *        isArray('');\n\t *        // > false\n\t *\n\t * @param {mixed} val\n\t * @return {bool}\n\t */\n\t\n\tmodule.exports = isArray || function (val) {\n\t  return !! val && '[object Array]' == str.call(val);\n\t};\n\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * Chai - getPathValue utility\n\t * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n\t * @see https://github.com/logicalparadox/filtr\n\t * MIT Licensed\n\t */\n\t\n\tvar getPathInfo = __webpack_require__(38);\n\t\n\t/**\n\t * ### .getPathValue(path, object)\n\t *\n\t * This allows the retrieval of values in an\n\t * object given a string path.\n\t *\n\t *     var obj = {\n\t *         prop1: {\n\t *             arr: ['a', 'b', 'c']\n\t *           , str: 'Hello'\n\t *         }\n\t *       , prop2: {\n\t *             arr: [ { nested: 'Universe' } ]\n\t *           , str: 'Hello again!'\n\t *         }\n\t *     }\n\t *\n\t * The following would be the results.\n\t *\n\t *     getPathValue('prop1.str', obj); // Hello\n\t *     getPathValue('prop1.att[2]', obj); // b\n\t *     getPathValue('prop2.arr[0].nested', obj); // Universe\n\t *\n\t * @param {String} path\n\t * @param {Object} object\n\t * @returns {Object} value or `undefined`\n\t * @name getPathValue\n\t * @api public\n\t */\n\tmodule.exports = function(path, obj) {\n\t  var info = getPathInfo(path, obj);\n\t  return info.value;\n\t}; \n\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * Chai - getPathInfo utility\n\t * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n\t * MIT Licensed\n\t */\n\t\n\tvar hasProperty = __webpack_require__(39);\n\t\n\t/**\n\t * ### .getPathInfo(path, object)\n\t *\n\t * This allows the retrieval of property info in an\n\t * object given a string path.\n\t *\n\t * The path info consists of an object with the\n\t * following properties:\n\t *\n\t * * parent - The parent object of the property referenced by `path`\n\t * * name - The name of the final property, a number if it was an array indexer\n\t * * value - The value of the property, if it exists, otherwise `undefined`\n\t * * exists - Whether the property exists or not\n\t *\n\t * @param {String} path\n\t * @param {Object} object\n\t * @returns {Object} info\n\t * @name getPathInfo\n\t * @api public\n\t */\n\t\n\tmodule.exports = function getPathInfo(path, obj) {\n\t  var parsed = parsePath(path),\n\t      last = parsed[parsed.length - 1];\n\t\n\t  var info = {\n\t    parent: parsed.length > 1 ? _getPathValue(parsed, obj, parsed.length - 1) : obj,\n\t    name: last.p || last.i,\n\t    value: _getPathValue(parsed, obj)\n\t  };\n\t  info.exists = hasProperty(info.name, info.parent);\n\t\n\t  return info;\n\t};\n\t\n\t\n\t/*!\n\t * ## parsePath(path)\n\t *\n\t * Helper function used to parse string object\n\t * paths. Use in conjunction with `_getPathValue`.\n\t *\n\t *      var parsed = parsePath('myobject.property.subprop');\n\t *\n\t * ### Paths:\n\t *\n\t * * Can be as near infinitely deep and nested\n\t * * Arrays are also valid using the formal `myobject.document[3].property`.\n\t * * Literal dots and brackets (not delimiter) must be backslash-escaped.\n\t *\n\t * @param {String} path\n\t * @returns {Object} parsed\n\t * @api private\n\t */\n\t\n\tfunction parsePath (path) {\n\t  var str = path.replace(/([^\\\\])\\[/g, '$1.[')\n\t    , parts = str.match(/(\\\\\\.|[^.]+?)+/g);\n\t  return parts.map(function (value) {\n\t    var re = /^\\[(\\d+)\\]$/\n\t      , mArr = re.exec(value);\n\t    if (mArr) return { i: parseFloat(mArr[1]) };\n\t    else return { p: value.replace(/\\\\([.\\[\\]])/g, '$1') };\n\t  });\n\t}\n\t\n\t\n\t/*!\n\t * ## _getPathValue(parsed, obj)\n\t *\n\t * Helper companion function for `.parsePath` that returns\n\t * the value located at the parsed address.\n\t *\n\t *      var value = getPathValue(parsed, obj);\n\t *\n\t * @param {Object} parsed definition from `parsePath`.\n\t * @param {Object} object to search against\n\t * @param {Number} object to search against\n\t * @returns {Object|Undefined} value\n\t * @api private\n\t */\n\t\n\tfunction _getPathValue (parsed, obj, index) {\n\t  var tmp = obj\n\t    , res;\n\t\n\t  index = (index === undefined ? parsed.length : index);\n\t\n\t  for (var i = 0, l = index; i < l; i++) {\n\t    var part = parsed[i];\n\t    if (tmp) {\n\t      if ('undefined' !== typeof part.p)\n\t        tmp = tmp[part.p];\n\t      else if ('undefined' !== typeof part.i)\n\t        tmp = tmp[part.i];\n\t      if (i == (l - 1)) res = tmp;\n\t    } else {\n\t      res = undefined;\n\t    }\n\t  }\n\t  return res;\n\t}\n\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * Chai - hasProperty utility\n\t * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n\t * MIT Licensed\n\t */\n\t\n\tvar type = __webpack_require__(17);\n\t\n\t/**\n\t * ### .hasProperty(object, name)\n\t *\n\t * This allows checking whether an object has\n\t * named property or numeric array index.\n\t *\n\t * Basically does the same thing as the `in`\n\t * operator but works properly with natives\n\t * and null/undefined values.\n\t *\n\t *     var obj = {\n\t *         arr: ['a', 'b', 'c']\n\t *       , str: 'Hello'\n\t *     }\n\t *\n\t * The following would be the results.\n\t *\n\t *     hasProperty('str', obj);  // true\n\t *     hasProperty('constructor', obj);  // true\n\t *     hasProperty('bar', obj);  // false\n\t *     \n\t *     hasProperty('length', obj.str); // true\n\t *     hasProperty(1, obj.str);  // true\n\t *     hasProperty(5, obj.str);  // false\n\t *\n\t *     hasProperty('length', obj.arr);  // true\n\t *     hasProperty(2, obj.arr);  // true\n\t *     hasProperty(3, obj.arr);  // false\n\t *\n\t * @param {Objuect} object\n\t * @param {String|Number} name\n\t * @returns {Boolean} whether it exists\n\t * @name getPathInfo\n\t * @api public\n\t */\n\t\n\tvar literals = {\n\t    'number': Number\n\t  , 'string': String\n\t};\n\t\n\tmodule.exports = function hasProperty(name, obj) {\n\t  var ot = type(obj);\n\t\n\t  // Bad Object, obviously no props at all\n\t  if(ot === 'null' || ot === 'undefined')\n\t    return false;\n\t\n\t  // The `in` operator does not work with certain literals\n\t  // box these before the check\n\t  if(literals[ot] && typeof obj !== 'object')\n\t    obj = new literals[ot](obj);\n\t\n\t  return name in obj;\n\t};\n\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * Chai - addProperty utility\n\t * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n\t * MIT Licensed\n\t */\n\t\n\tvar config = __webpack_require__(27);\n\tvar flag = __webpack_require__(16);\n\t\n\t/**\n\t * ### addProperty (ctx, name, getter)\n\t *\n\t * Adds a property to the prototype of an object.\n\t *\n\t *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {\n\t *       var obj = utils.flag(this, 'object');\n\t *       new chai.Assertion(obj).to.be.instanceof(Foo);\n\t *     });\n\t *\n\t * Can also be accessed directly from `chai.Assertion`.\n\t *\n\t *     chai.Assertion.addProperty('foo', fn);\n\t *\n\t * Then can be used as any other assertion.\n\t *\n\t *     expect(myFoo).to.be.foo;\n\t *\n\t * @param {Object} ctx object to which the property is added\n\t * @param {String} name of property to add\n\t * @param {Function} getter function to be used for name\n\t * @name addProperty\n\t * @api public\n\t */\n\t\n\tmodule.exports = function (ctx, name, getter) {\n\t  Object.defineProperty(ctx, name,\n\t    { get: function addProperty() {\n\t        var old_ssfi = flag(this, 'ssfi');\n\t        if (old_ssfi && config.includeStack === false)\n\t          flag(this, 'ssfi', addProperty);\n\t\n\t        var result = getter.call(this);\n\t        return result === undefined ? this : result;\n\t      }\n\t    , configurable: true\n\t  });\n\t};\n\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * Chai - addMethod utility\n\t * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n\t * MIT Licensed\n\t */\n\t\n\tvar config = __webpack_require__(27);\n\t\n\t/**\n\t * ### .addMethod (ctx, name, method)\n\t *\n\t * Adds a method to the prototype of an object.\n\t *\n\t *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {\n\t *       var obj = utils.flag(this, 'object');\n\t *       new chai.Assertion(obj).to.be.equal(str);\n\t *     });\n\t *\n\t * Can also be accessed directly from `chai.Assertion`.\n\t *\n\t *     chai.Assertion.addMethod('foo', fn);\n\t *\n\t * Then can be used as any other assertion.\n\t *\n\t *     expect(fooStr).to.be.foo('bar');\n\t *\n\t * @param {Object} ctx object to which the method is added\n\t * @param {String} name of method to add\n\t * @param {Function} method function to be used for name\n\t * @name addMethod\n\t * @api public\n\t */\n\tvar flag = __webpack_require__(16);\n\t\n\tmodule.exports = function (ctx, name, method) {\n\t  ctx[name] = function () {\n\t    var old_ssfi = flag(this, 'ssfi');\n\t    if (old_ssfi && config.includeStack === false)\n\t      flag(this, 'ssfi', ctx[name]);\n\t    var result = method.apply(this, arguments);\n\t    return result === undefined ? this : result;\n\t  };\n\t};\n\n\n/***/ },\n/* 42 */\n/***/ function(module, exports) {\n\n\t/*!\n\t * Chai - overwriteProperty utility\n\t * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n\t * MIT Licensed\n\t */\n\t\n\t/**\n\t * ### overwriteProperty (ctx, name, fn)\n\t *\n\t * Overwites an already existing property getter and provides\n\t * access to previous value. Must return function to use as getter.\n\t *\n\t *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {\n\t *       return function () {\n\t *         var obj = utils.flag(this, 'object');\n\t *         if (obj instanceof Foo) {\n\t *           new chai.Assertion(obj.name).to.equal('bar');\n\t *         } else {\n\t *           _super.call(this);\n\t *         }\n\t *       }\n\t *     });\n\t *\n\t *\n\t * Can also be accessed directly from `chai.Assertion`.\n\t *\n\t *     chai.Assertion.overwriteProperty('foo', fn);\n\t *\n\t * Then can be used as any other assertion.\n\t *\n\t *     expect(myFoo).to.be.ok;\n\t *\n\t * @param {Object} ctx object whose property is to be overwritten\n\t * @param {String} name of property to overwrite\n\t * @param {Function} getter function that returns a getter function to be used for name\n\t * @name overwriteProperty\n\t * @api public\n\t */\n\t\n\tmodule.exports = function (ctx, name, getter) {\n\t  var _get = Object.getOwnPropertyDescriptor(ctx, name)\n\t    , _super = function () {};\n\t\n\t  if (_get && 'function' === typeof _get.get)\n\t    _super = _get.get\n\t\n\t  Object.defineProperty(ctx, name,\n\t    { get: function () {\n\t        var result = getter(_super).call(this);\n\t        return result === undefined ? this : result;\n\t      }\n\t    , configurable: true\n\t  });\n\t};\n\n\n/***/ },\n/* 43 */\n/***/ function(module, exports) {\n\n\t/*!\n\t * Chai - overwriteMethod utility\n\t * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n\t * MIT Licensed\n\t */\n\t\n\t/**\n\t * ### overwriteMethod (ctx, name, fn)\n\t *\n\t * Overwites an already existing method and provides\n\t * access to previous function. Must return function\n\t * to be used for name.\n\t *\n\t *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {\n\t *       return function (str) {\n\t *         var obj = utils.flag(this, 'object');\n\t *         if (obj instanceof Foo) {\n\t *           new chai.Assertion(obj.value).to.equal(str);\n\t *         } else {\n\t *           _super.apply(this, arguments);\n\t *         }\n\t *       }\n\t *     });\n\t *\n\t * Can also be accessed directly from `chai.Assertion`.\n\t *\n\t *     chai.Assertion.overwriteMethod('foo', fn);\n\t *\n\t * Then can be used as any other assertion.\n\t *\n\t *     expect(myFoo).to.equal('bar');\n\t *\n\t * @param {Object} ctx object whose method is to be overwritten\n\t * @param {String} name of method to overwrite\n\t * @param {Function} method function that returns a function to be used for name\n\t * @name overwriteMethod\n\t * @api public\n\t */\n\t\n\tmodule.exports = function (ctx, name, method) {\n\t  var _method = ctx[name]\n\t    , _super = function () { return this; };\n\t\n\t  if (_method && 'function' === typeof _method)\n\t    _super = _method;\n\t\n\t  ctx[name] = function () {\n\t    var result = method(_super).apply(this, arguments);\n\t    return result === undefined ? this : result;\n\t  }\n\t};\n\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * Chai - addChainingMethod utility\n\t * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n\t * MIT Licensed\n\t */\n\t\n\t/*!\n\t * Module dependencies\n\t */\n\t\n\tvar transferFlags = __webpack_require__(28);\n\tvar flag = __webpack_require__(16);\n\tvar config = __webpack_require__(27);\n\t\n\t/*!\n\t * Module variables\n\t */\n\t\n\t// Check whether `__proto__` is supported\n\tvar hasProtoSupport = '__proto__' in Object;\n\t\n\t// Without `__proto__` support, this module will need to add properties to a function.\n\t// However, some Function.prototype methods cannot be overwritten,\n\t// and there seems no easy cross-platform way to detect them (@see chaijs/chai/issues/69).\n\tvar excludeNames = /^(?:length|name|arguments|caller)$/;\n\t\n\t// Cache `Function` properties\n\tvar call  = Function.prototype.call,\n\t    apply = Function.prototype.apply;\n\t\n\t/**\n\t * ### addChainableMethod (ctx, name, method, chainingBehavior)\n\t *\n\t * Adds a method to an object, such that the method can also be chained.\n\t *\n\t *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {\n\t *       var obj = utils.flag(this, 'object');\n\t *       new chai.Assertion(obj).to.be.equal(str);\n\t *     });\n\t *\n\t * Can also be accessed directly from `chai.Assertion`.\n\t *\n\t *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);\n\t *\n\t * The result can then be used as both a method assertion, executing both `method` and\n\t * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.\n\t *\n\t *     expect(fooStr).to.be.foo('bar');\n\t *     expect(fooStr).to.be.foo.equal('foo');\n\t *\n\t * @param {Object} ctx object to which the method is added\n\t * @param {String} name of method to add\n\t * @param {Function} method function to be used for `name`, when called\n\t * @param {Function} chainingBehavior function to be called every time the property is accessed\n\t * @name addChainableMethod\n\t * @api public\n\t */\n\t\n\tmodule.exports = function (ctx, name, method, chainingBehavior) {\n\t  if (typeof chainingBehavior !== 'function') {\n\t    chainingBehavior = function () { };\n\t  }\n\t\n\t  var chainableBehavior = {\n\t      method: method\n\t    , chainingBehavior: chainingBehavior\n\t  };\n\t\n\t  // save the methods so we can overwrite them later, if we need to.\n\t  if (!ctx.__methods) {\n\t    ctx.__methods = {};\n\t  }\n\t  ctx.__methods[name] = chainableBehavior;\n\t\n\t  Object.defineProperty(ctx, name,\n\t    { get: function () {\n\t        chainableBehavior.chainingBehavior.call(this);\n\t\n\t        var assert = function assert() {\n\t          var old_ssfi = flag(this, 'ssfi');\n\t          if (old_ssfi && config.includeStack === false)\n\t            flag(this, 'ssfi', assert);\n\t          var result = chainableBehavior.method.apply(this, arguments);\n\t          return result === undefined ? this : result;\n\t        };\n\t\n\t        // Use `__proto__` if available\n\t        if (hasProtoSupport) {\n\t          // Inherit all properties from the object by replacing the `Function` prototype\n\t          var prototype = assert.__proto__ = Object.create(this);\n\t          // Restore the `call` and `apply` methods from `Function`\n\t          prototype.call = call;\n\t          prototype.apply = apply;\n\t        }\n\t        // Otherwise, redefine all properties (slow!)\n\t        else {\n\t          var asserterNames = Object.getOwnPropertyNames(ctx);\n\t          asserterNames.forEach(function (asserterName) {\n\t            if (!excludeNames.test(asserterName)) {\n\t              var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);\n\t              Object.defineProperty(assert, asserterName, pd);\n\t            }\n\t          });\n\t        }\n\t\n\t        transferFlags(this, assert);\n\t        return assert;\n\t      }\n\t    , configurable: true\n\t  });\n\t};\n\n\n/***/ },\n/* 45 */\n/***/ function(module, exports) {\n\n\t/*!\n\t * Chai - overwriteChainableMethod utility\n\t * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n\t * MIT Licensed\n\t */\n\t\n\t/**\n\t * ### overwriteChainableMethod (ctx, name, method, chainingBehavior)\n\t *\n\t * Overwites an already existing chainable method\n\t * and provides access to the previous function or\n\t * property.  Must return functions to be used for\n\t * name.\n\t *\n\t *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'length',\n\t *       function (_super) {\n\t *       }\n\t *     , function (_super) {\n\t *       }\n\t *     );\n\t *\n\t * Can also be accessed directly from `chai.Assertion`.\n\t *\n\t *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);\n\t *\n\t * Then can be used as any other assertion.\n\t *\n\t *     expect(myFoo).to.have.length(3);\n\t *     expect(myFoo).to.have.length.above(3);\n\t *\n\t * @param {Object} ctx object whose method / property is to be overwritten\n\t * @param {String} name of method / property to overwrite\n\t * @param {Function} method function that returns a function to be used for name\n\t * @param {Function} chainingBehavior function that returns a function to be used for property\n\t * @name overwriteChainableMethod\n\t * @api public\n\t */\n\t\n\tmodule.exports = function (ctx, name, method, chainingBehavior) {\n\t  var chainableBehavior = ctx.__methods[name];\n\t\n\t  var _chainingBehavior = chainableBehavior.chainingBehavior;\n\t  chainableBehavior.chainingBehavior = function () {\n\t    var result = chainingBehavior(_chainingBehavior).call(this);\n\t    return result === undefined ? this : result;\n\t  };\n\t\n\t  var _method = chainableBehavior.method;\n\t  chainableBehavior.method = function () {\n\t    var result = method(_method).apply(this, arguments);\n\t    return result === undefined ? this : result;\n\t  };\n\t};\n\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*!\n\t * chai\n\t * http://chaijs.com\n\t * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n\t * MIT Licensed\n\t */\n\t\n\tvar config = __webpack_require__(27);\n\t\n\tmodule.exports = function (_chai, util) {\n\t  /*!\n\t   * Module dependencies.\n\t   */\n\t\n\t  var AssertionError = _chai.AssertionError\n\t    , flag = util.flag;\n\t\n\t  /*!\n\t   * Module export.\n\t   */\n\t\n\t  _chai.Assertion = Assertion;\n\t\n\t  /*!\n\t   * Assertion Constructor\n\t   *\n\t   * Creates object for chaining.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  function Assertion (obj, msg, stack) {\n\t    flag(this, 'ssfi', stack || arguments.callee);\n\t    flag(this, 'object', obj);\n\t    flag(this, 'message', msg);\n\t  }\n\t\n\t  Object.defineProperty(Assertion, 'includeStack', {\n\t    get: function() {\n\t      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');\n\t      return config.includeStack;\n\t    },\n\t    set: function(value) {\n\t      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');\n\t      config.includeStack = value;\n\t    }\n\t  });\n\t\n\t  Object.defineProperty(Assertion, 'showDiff', {\n\t    get: function() {\n\t      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');\n\t      return config.showDiff;\n\t    },\n\t    set: function(value) {\n\t      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');\n\t      config.showDiff = value;\n\t    }\n\t  });\n\t\n\t  Assertion.addProperty = function (name, fn) {\n\t    util.addProperty(this.prototype, name, fn);\n\t  };\n\t\n\t  Assertion.addMethod = function (name, fn) {\n\t    util.addMethod(this.prototype, name, fn);\n\t  };\n\t\n\t  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {\n\t    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);\n\t  };\n\t\n\t  Assertion.overwriteProperty = function (name, fn) {\n\t    util.overwriteProperty(this.prototype, name, fn);\n\t  };\n\t\n\t  Assertion.overwriteMethod = function (name, fn) {\n\t    util.overwriteMethod(this.prototype, name, fn);\n\t  };\n\t\n\t  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {\n\t    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);\n\t  };\n\t\n\t  /**\n\t   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)\n\t   *\n\t   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.\n\t   *\n\t   * @name assert\n\t   * @param {Philosophical} expression to be tested\n\t   * @param {String|Function} message or function that returns message to display if expression fails\n\t   * @param {String|Function} negatedMessage or function that returns negatedMessage to display if negated expression fails\n\t   * @param {Mixed} expected value (remember to check for negation)\n\t   * @param {Mixed} actual (optional) will default to `this.obj`\n\t   * @param {Boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails\n\t   * @api private\n\t   */\n\t\n\t  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {\n\t    var ok = util.test(this, arguments);\n\t    if (true !== showDiff) showDiff = false;\n\t    if (true !== config.showDiff) showDiff = false;\n\t\n\t    if (!ok) {\n\t      var msg = util.getMessage(this, arguments)\n\t        , actual = util.getActual(this, arguments);\n\t      throw new AssertionError(msg, {\n\t          actual: actual\n\t        , expected: expected\n\t        , showDiff: showDiff\n\t      }, (config.includeStack) ? this.assert : flag(this, 'ssfi'));\n\t    }\n\t  };\n\t\n\t  /*!\n\t   * ### ._obj\n\t   *\n\t   * Quick reference to stored `actual` value for plugin developers.\n\t   *\n\t   * @api private\n\t   */\n\t\n\t  Object.defineProperty(Assertion.prototype, '_obj',\n\t    { get: function () {\n\t        return flag(this, 'object');\n\t      }\n\t    , set: function (val) {\n\t        flag(this, 'object', val);\n\t      }\n\t  });\n\t};\n\n\n/***/ },\n/* 47 */\n/***/ function(module, exports) {\n\n\t/*!\n\t * chai\n\t * http://chaijs.com\n\t * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n\t * MIT Licensed\n\t */\n\t\n\tmodule.exports = function (chai, _) {\n\t  var Assertion = chai.Assertion\n\t    , toString = Object.prototype.toString\n\t    , flag = _.flag;\n\t\n\t  /**\n\t   * ### Language Chains\n\t   *\n\t   * The following are provided as chainable getters to\n\t   * improve the readability of your assertions. They\n\t   * do not provide testing capabilities unless they\n\t   * have been overwritten by a plugin.\n\t   *\n\t   * **Chains**\n\t   *\n\t   * - to\n\t   * - be\n\t   * - been\n\t   * - is\n\t   * - that\n\t   * - which\n\t   * - and\n\t   * - has\n\t   * - have\n\t   * - with\n\t   * - at\n\t   * - of\n\t   * - same\n\t   *\n\t   * @name language chains\n\t   * @api public\n\t   */\n\t\n\t  [ 'to', 'be', 'been'\n\t  , 'is', 'and', 'has', 'have'\n\t  , 'with', 'that', 'which', 'at'\n\t  , 'of', 'same' ].forEach(function (chain) {\n\t    Assertion.addProperty(chain, function () {\n\t      return this;\n\t    });\n\t  });\n\t\n\t  /**\n\t   * ### .not\n\t   *\n\t   * Negates any of assertions following in the chain.\n\t   *\n\t   *     expect(foo).to.not.equal('bar');\n\t   *     expect(goodFn).to.not.throw(Error);\n\t   *     expect({ foo: 'baz' }).to.have.property('foo')\n\t   *       .and.not.equal('bar');\n\t   *\n\t   * @name not\n\t   * @api public\n\t   */\n\t\n\t  Assertion.addProperty('not', function () {\n\t    flag(this, 'negate', true);\n\t  });\n\t\n\t  /**\n\t   * ### .deep\n\t   *\n\t   * Sets the `deep` flag, later used by the `equal` and\n\t   * `property` assertions.\n\t   *\n\t   *     expect(foo).to.deep.equal({ bar: 'baz' });\n\t   *     expect({ foo: { bar: { baz: 'quux' } } })\n\t   *       .to.have.deep.property('foo.bar.baz', 'quux');\n\t   *\n\t   * `.deep.property` special characters can be escaped\n\t   * by adding two slashes before the `.` or `[]`.\n\t   *\n\t   *     var deepCss = { '.link': { '[target]': 42 }};\n\t   *     expect(deepCss).to.have.deep.property('\\\\.link.\\\\[target\\\\]', 42);\n\t   *\n\t   * @name deep\n\t   * @api public\n\t   */\n\t\n\t  Assertion.addProperty('deep', function () {\n\t    flag(this, 'deep', true);\n\t  });\n\t\n\t  /**\n\t   * ### .any\n\t   *\n\t   * Sets the `any` flag, (opposite of the `all` flag)\n\t   * later used in the `keys` assertion.\n\t   *\n\t   *     expect(foo).to.have.any.keys('bar', 'baz');\n\t   *\n\t   * @name any\n\t   * @api public\n\t   */\n\t\n\t  Assertion.addProperty('any', function () {\n\t    flag(this, 'any', true);\n\t    flag(this, 'all', false)\n\t  });\n\t\n\t\n\t  /**\n\t   * ### .all\n\t   *\n\t   * Sets the `all` flag (opposite of the `any` flag)\n\t   * later used by the `keys` assertion.\n\t   *\n\t   *     expect(foo).to.have.all.keys('bar', 'baz');\n\t   *\n\t   * @name all\n\t   * @api public\n\t   */\n\t\n\t  Assertion.addProperty('all', function () {\n\t    flag(this, 'all', true);\n\t    flag(this, 'any', false);\n\t  });\n\t\n\t  /**\n\t   * ### .a(type)\n\t   *\n\t   * The `a` and `an` assertions are aliases that can be\n\t   * used either as language chains or to assert a value's\n\t   * type.\n\t   *\n\t   *     // typeof\n\t   *     expect('test').to.be.a('string');\n\t   *     expect({ foo: 'bar' }).to.be.an('object');\n\t   *     expect(null).to.be.a('null');\n\t   *     expect(undefined).to.be.an('undefined');\n\t   *     expect(new Error).to.be.an('error');\n\t   *     expect(new Promise).to.be.a('promise');\n\t   *     expect(new Float32Array()).to.be.a('float32array');\n\t   *     expect(Symbol()).to.be.a('symbol');\n\t   *\n\t   *     // es6 overrides\n\t   *     expect({[Symbol.toStringTag]:()=>'foo'}).to.be.a('foo');\n\t   *\n\t   *     // language chain\n\t   *     expect(foo).to.be.an.instanceof(Foo);\n\t   *\n\t   * @name a\n\t   * @alias an\n\t   * @param {String} type\n\t   * @param {String} message _optional_\n\t   * @api public\n\t   */\n\t\n\t  function an (type, msg) {\n\t    if (msg) flag(this, 'message', msg);\n\t    type = type.toLowerCase();\n\t    var obj = flag(this, 'object')\n\t      , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';\n\t\n\t    this.assert(\n\t        type === _.type(obj)\n\t      , 'expected #{this} to be ' + article + type\n\t      , 'expected #{this} not to be ' + article + type\n\t    );\n\t  }\n\t\n\t  Assertion.addChainableMethod('an', an);\n\t  Assertion.addChainableMethod('a', an);\n\t\n\t  /**\n\t   * ### .include(value)\n\t   *\n\t   * The `include` and `contain` assertions can be used as either property\n\t   * based language chains or as methods to assert the inclusion of an object\n\t   * in an array or a substring in a string. When used as language chains,\n\t   * they toggle the `contains` flag for the `keys` assertion.\n\t   *\n\t   *     expect([1,2,3]).to.include(2);\n\t   *     expect('foobar').to.contain('foo');\n\t   *     expect({ foo: 'bar', hello: 'universe' }).to.include.keys('foo');\n\t   *\n\t   * @name include\n\t   * @alias contain\n\t   * @alias includes\n\t   * @alias contains\n\t   * @param {Object|String|Number} obj\n\t   * @param {String} message _optional_\n\t   * @api public\n\t   */\n\t\n\t  function includeChainingBehavior () {\n\t    flag(this, 'contains', true);\n\t  }\n\t\n\t  function include (val, msg) {\n\t    _.expectTypes(this, ['array', 'object', 'string']);\n\t\n\t    if (msg) flag(this, 'message', msg);\n\t    var obj = flag(this, 'object');\n\t    var expected = false;\n\t\n\t    if (_.type(obj) === 'array' && _.type(val) === 'object') {\n\t      for (var i in obj) {\n\t        if (_.eql(obj[i], val)) {\n\t          expected = true;\n\t          break;\n\t        }\n\t      }\n\t    } else if (_.type(val) === 'object') {\n\t      if (!flag(this, 'negate')) {\n\t        for (var k in val) new Assertion(obj).property(k, val[k]);\n\t        return;\n\t      }\n\t      var subset = {};\n\t      for (var k in val) subset[k] = obj[k];\n\t      expected = _.eql(subset, val);\n\t    } else {\n\t      expected = (obj != undefined) && ~obj.indexOf(val);\n\t    }\n\t    this.assert(\n\t        expected\n\t      , 'expected #{this} to include ' + _.inspect(val)\n\t      , 'expected #{this} to not include ' + _.inspect(val));\n\t  }\n\t\n\t  Assertion.addChainableMethod('include', include, includeChainingBehavior);\n\t  Assertion.addChainableMethod('contain', include, includeChainingBehavior);\n\t  Assertion.addChainableMethod('contains', include, includeChainingBehavior);\n\t  Assertion.addChainableMethod('includes', include, includeChainingBehavior);\n\t\n\t  /**\n\t   * ### .ok\n\t   *\n\t   * Asserts that the target is truthy.\n\t   *\n\t   *     expect('everything').to.be.ok;\n\t   *     expect(1).to.be.ok;\n\t   *     expect(false).to.not.be.ok;\n\t   *     expect(undefined).to.not.be.ok;\n\t   *     expect(null).to.not.be.ok;\n\t   *\n\t   * @name ok\n\t   * @api public\n\t   */\n\t\n\t  Assertion.addProperty('ok', function () {\n\t    this.assert(\n\t        flag(this, 'object')\n\t      , 'expected #{this} to be truthy'\n\t      , 'expected #{this} to be falsy');\n\t  });\n\t\n\t  /**\n\t   * ### .true\n\t   *\n\t   * Asserts that the target is `true`.\n\t   *\n\t   *     expect(true).to.be.true;\n\t   *     expect(1).to.not.be.true;\n\t   *\n\t   * @name true\n\t   * @api public\n\t   */\n\t\n\t  Assertion.addProperty('true', function () {\n\t    this.assert(\n\t        true === flag(this, 'object')\n\t      , 'expected #{this} to be true'\n\t      , 'expected #{this} to be false'\n\t      , this.negate ? false : true\n\t    );\n\t  });\n\t\n\t  /**\n\t   * ### .false\n\t   *\n\t   * Asserts that the target is `false`.\n\t   *\n\t   *     expect(false).to.be.false;\n\t   *     expect(0).to.not.be.false;\n\t   *\n\t   * @name false\n\t   * @api public\n\t   */\n\t\n\t  Assertion.addProperty('false', function () {\n\t    this.assert(\n\t        false === flag(this, 'object')\n\t      , 'expected #{this} to be false'\n\t      , 'expected #{this} to be true'\n\t      , this.negate ? true : false\n\t    );\n\t  });\n\t\n\t  /**\n\t   * ### .null\n\t   *\n\t   * Asserts that the target is `null`.\n\t   *\n\t   *     expect(null).to.be.null;\n\t   *     expect(undefined).to.not.be.null;\n\t   *\n\t   * @name null\n\t   * @api public\n\t   */\n\t\n\t  Assertion.addProperty('null', function () {\n\t    this.assert(\n\t        null === flag(this, 'object')\n\t      , 'expected #{this} to be null'\n\t      , 'expected #{this} not to be null'\n\t    );\n\t  });\n\t\n\t  /**\n\t   * ### .undefined\n\t   *\n\t   * Asserts that the target is `undefined`.\n\t   *\n\t   *     expect(undefined).to.be.undefined;\n\t   *     expect(null).to.not.be.undefined;\n\t   *\n\t   * @name undefined\n\t   * @api public\n\t   */\n\t\n\t  Assertion.addProperty('undefined', function () {\n\t    this.assert(\n\t        undefined === flag(this, 'object')\n\t      , 'expected #{this} to be undefined'\n\t      , 'expected #{this} not to be undefined'\n\t    );\n\t  });\n\t\n\t  /**\n\t   * ### .NaN\n\t   * Asserts that the target is `NaN`.\n\t   *\n\t   *     expect('foo').to.be.NaN;\n\t   *     expect(4).not.to.be.NaN;\n\t   *\n\t   * @name NaN\n\t   * @api public\n\t   */\n\t\n\t  Assertion.addProperty('NaN', function () {\n\t    this.assert(\n\t        isNaN(flag(this, 'object'))\n\t        , 'expected #{this} to be NaN'\n\t        , 'expected #{this} not to be NaN'\n\t    );\n\t  });\n\t\n\t  /**\n\t   * ### .exist\n\t   *\n\t   * Asserts that the target is neither `null` nor `undefined`.\n\t   *\n\t   *     var foo = 'hi'\n\t   *       , bar = null\n\t   *       , baz;\n\t   *\n\t   *     expect(foo).to.exist;\n\t   *     expect(bar).to.not.exist;\n\t   *     expect(baz).to.not.exist;\n\t   *\n\t   * @name exist\n\t   * @api public\n\t   */\n\t\n\t  Assertion.addProperty('exist', function () {\n\t    this.assert(\n\t        null != flag(this, 'object')\n\t      , 'expected #{this} to exist'\n\t      , 'expected #{this} to not exist'\n\t    );\n\t  });\n\t\n\t\n\t  /**\n\t   * ### .empty\n\t   *\n\t   * Asserts that the target's length is `0`. For arrays and strings, it checks\n\t   * the `length` property. For objects, it gets the count of\n\t   * enumerable keys.\n\t   *\n\t   *     expect([]).to.be.empty;\n\t   *     expect('').to.be.empty;\n\t   *     expect({}).to.be.empty;\n\t   *\n\t   * @name empty\n\t   * @api public\n\t   */\n\t\n\t  Assertion.addProperty('empty', function () {\n\t    var obj = flag(this, 'object')\n\t      , expected = obj;\n\t\n\t    if (Array.isArray(obj) || 'string' === typeof object) {\n\t      expected = obj.length;\n\t    } else if (typeof obj === 'object') {\n\t      expected = Object.keys(obj).length;\n\t    }\n\t\n\t    this.assert(\n\t        !expected\n\t      , 'expected #{this} to be empty'\n\t      , 'expected #{this} not to be empty'\n\t    );\n\t  });\n\t\n\t  /**\n\t   * ### .arguments\n\t   *\n\t   * Asserts that the target is an arguments object.\n\t   *\n\t   *     function test () {\n\t   *       expect(arguments).to.be.arguments;\n\t   *     }\n\t   *\n\t   * @name arguments\n\t   * @alias Arguments\n\t   * @api public\n\t   */\n\t\n\t  function checkArguments () {\n\t    var obj = flag(this, 'object')\n\t      , type = Object.prototype.toString.call(obj);\n\t    this.assert(\n\t        '[object Arguments]' === type\n\t      , 'expected #{this} to be arguments but got ' + type\n\t      , 'expected #{this} to not be arguments'\n\t    );\n\t  }\n\t\n\t  Assertion.addProperty('arguments', checkArguments);\n\t  Assertion.addProperty('Arguments', checkArguments);\n\t\n\t  /**\n\t   * ### .equal(value)\n\t   *\n\t   * Asserts that the target is strictly equal (`===`) to `value`.\n\t   * Alternately, if the `deep` flag is set, asserts that\n\t   * the target is deeply equal to `value`.\n\t   *\n\t   *     expect('hello').to.equal('hello');\n\t   *     expect(42).to.equal(42);\n\t   *     expect(1).to.not.equal(true);\n\t   *     expect({ foo: 'bar' }).to.not.equal({ foo: 'bar' });\n\t   *     expect({ foo: 'bar' }).to.deep.equal({ foo: 'bar' });\n\t   *\n\t   * @name equal\n\t   * @alias equals\n\t   * @alias eq\n\t   * @alias deep.equal\n\t   * @param {Mixed} value\n\t   * @param {String} message _optional_\n\t   * @api public\n\t   */\n\t\n\t  function assertEqual (val, msg) {\n\t    if (msg) flag(this, 'message', msg);\n\t    var obj = flag(this, 'object');\n\t    if (flag(this, 'deep')) {\n\t      return this.eql(val);\n\t    } else {\n\t      this.assert(\n\t          val === obj\n\t        , 'expected #{this} to equal #{exp}'\n\t        , 'expected #{this} to not equal #{exp}'\n\t        , val\n\t        , this._obj\n\t        , true\n\t      );\n\t    }\n\t  }\n\t\n\t  Assertion.addMethod('equal', assertEqual);\n\t  Assertion.addMethod('equals', assertEqual);\n\t  Assertion.addMethod('eq', assertEqual);\n\t\n\t  /**\n\t   * ### .eql(value)\n\t   *\n\t   * Asserts that the target is deeply equal to `value`.\n\t   *\n\t   *     expect({ foo: 'bar' }).to.eql({ foo: 'bar' });\n\t   *     expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);\n\t   *\n\t   * @name eql\n\t   * @alias eqls\n\t   * @param {Mixed} value\n\t   * @param {String} message _optional_\n\t   * @api public\n\t   */\n\t\n\t  function assertEql(obj, msg) {\n\t    if (msg) flag(this, 'message', msg);\n\t    this.assert(\n\t        _.eql(obj, flag(this, 'object'))\n\t      , 'expected #{this} to deeply equal #{exp}'\n\t      , 'expected #{this} to not deeply equal #{exp}'\n\t      , obj\n\t      , this._obj\n\t      , true\n\t    );\n\t  }\n\t\n\t  Assertion.addMethod('eql', assertEql);\n\t  Assertion.addMethod('eqls', assertEql);\n\t\n\t  /**\n\t   * ### .above(value)\n\t   *\n\t   * Asserts that the target is greater than `value`.\n\t   *\n\t   *     expect(10).to.be.above(5);\n\t   *\n\t   * Can also be used in conjunction with `length` to\n\t   * assert a minimum length. The benefit being a\n\t   * more informative error message than if the length\n\t   * was supplied directly.\n\t   *\n\t   *     expect('foo').to.have.length.above(2);\n\t   *     expect([ 1, 2, 3 ]).to.have.length.above(2);\n\t   *\n\t   * @name above\n\t   * @alias gt\n\t   * @alias greaterThan\n\t   * @param {Number} value\n\t   * @param {String} message _optional_\n\t   * @api public\n\t   */\n\t\n\t  function assertAbove (n, msg) {\n\t    if (msg) flag(this, 'message', msg);\n\t    var obj = flag(this, 'object');\n\t    if (flag(this, 'doLength')) {\n\t      new Assertion(obj, msg).to.have.property('length');\n\t      var len = obj.length;\n\t      this.assert(\n\t          len > n\n\t        , 'expected #{this} to have a length above #{exp} but got #{act}'\n\t        , 'expected #{this} to not have a length above #{exp}'\n\t        , n\n\t        , len\n\t      );\n\t    } else {\n\t      this.assert(\n\t          obj > n\n\t        , 'expected #{this} to be above ' + n\n\t        , 'expected #{this} to be at most ' + n\n\t      );\n\t    }\n\t  }\n\t\n\t  Assertion.addMethod('above', assertAbove);\n\t  Assertion.addMethod('gt', assertAbove);\n\t  Assertion.addMethod('greaterThan', assertAbove);\n\t\n\t  /**\n\t   * ### .least(value)\n\t   *\n\t   * Asserts that the target is greater than or equal to `value`.\n\t   *\n\t   *     expect(10).to.be.at.least(10);\n\t   *\n\t   * Can also be used in conjunction with `length` to\n\t   * assert a minimum length. The benefit being a\n\t   * more informative error message than if the length\n\t   * was supplied directly.\n\t   *\n\t   *     expect('foo').to.have.length.of.at.least(2);\n\t   *     expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);\n\t   *\n\t   * @name least\n\t   * @alias gte\n\t   * @param {Number} value\n\t   * @param {String} message _optional_\n\t   * @api public\n\t   */\n\t\n\t  function assertLeast (n, msg) {\n\t    if (msg) flag(this, 'message', msg);\n\t    var obj = flag(this, 'object');\n\t    if (flag(this, 'doLength')) {\n\t      new Assertion(obj, msg).to.have.property('length');\n\t      var len = obj.length;\n\t      this.assert(\n\t          len >= n\n\t        , 'expected #{this} to have a length at least #{exp} but got #{act}'\n\t        , 'expected #{this} to have a length below #{exp}'\n\t        , n\n\t        , len\n\t      );\n\t    } else {\n\t      this.assert(\n\t          obj >= n\n\t        , 'expected #{this} to be at least ' + n\n\t        , 'expected #{this} to be below ' + n\n\t      );\n\t    }\n\t  }\n\t\n\t  Assertion.addMethod('least', assertLeast);\n\t  Assertion.addMethod('gte', assertLeast);\n\t\n\t  /**\n\t   * ### .below(value)\n\t   *\n\t   * Asserts that the target is less than `value`.\n\t   *\n\t   *     expect(5).to.be.below(10);\n\t   *\n\t   * Can also be used in conjunction with `length` to\n\t   * assert a maximum length. The benefit being a\n\t   * more informative error message than if the length\n\t   * was supplied directly.\n\t   *\n\t   *     expect('foo').to.have.length.below(4);\n\t   *     expect([ 1, 2, 3 ]).to.have.length.below(4);\n\t   *\n\t   * @name below\n\t   * @alias lt\n\t   * @alias lessThan\n\t   * @param {Number} value\n\t   * @param {String} message _optional_\n\t   * @api public\n\t   */\n\t\n\t  function assertBelow (n, msg) {\n\t    if (msg) flag(this, 'message', msg);\n\t    var obj = flag(this, 'object');\n\t    if (flag(this, 'doLength')) {\n\t      new Assertion(obj, msg).to.have.property('length');\n\t      var len = obj.length;\n\t      this.assert(\n\t          len < n\n\t        , 'expected #{this} to have a length below #{exp} but got #{act}'\n\t        , 'expected #{this} to not have a length below #{exp}'\n\t        , n\n\t        , len\n\t      );\n\t    } else {\n\t      this.assert(\n\t          obj < n\n\t        , 'expected #{this} to be below ' + n\n\t        , 'expected #{this} to be at least ' + n\n\t      );\n\t    }\n\t  }\n\t\n\t  Assertion.addMethod('below', assertBelow);\n\t  Assertion.addMethod('lt', assertBelow);\n\t  Assertion.addMethod('lessThan', assertBelow);\n\t\n\t  /**\n\t   * ### .most(value)\n\t   *\n\t   * Asserts that the target is less than or equal to `value`.\n\t   *\n\t   *     expect(5).to.be.at.most(5);\n\t   *\n\t   * Can also be used in conjunction with `length` to\n\t   * assert a maximum length. The benefit being a\n\t   * more informative error message than if the length\n\t   * was supplied directly.\n\t   *\n\t   *     expect('foo').to.have.length.of.at.most(4);\n\t   *     expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);\n\t   *\n\t   * @name most\n\t   * @alias lte\n\t   * @param {Number} value\n\t   * @param {String} message _optional_\n\t   * @api public\n\t   */\n\t\n\t  function assertMost (n, msg) {\n\t    if (msg) flag(this, 'message', msg);\n\t    var obj = flag(this, 'object');\n\t    if (flag(this, 'doLength')) {\n\t      new Assertion(obj, msg).to.have.property('length');\n\t      var len = obj.length;\n\t      this.assert(\n\t          len <= n\n\t        , 'expected #{this} to have a length at most #{exp} but got #{act}'\n\t        , 'expected #{this} to have a length above #{exp}'\n\t        , n\n\t        , len\n\t      );\n\t    } else {\n\t      this.assert(\n\t          obj <= n\n\t        , 'expected #{this} to be at most ' + n\n\t        , 'expected #{this} to be above ' + n\n\t      );\n\t    }\n\t  }\n\t\n\t  Assertion.addMethod('most', assertMost);\n\t  Assertion.addMethod('lte', assertMost);\n\t\n\t  /**\n\t   * ### .within(start, finish)\n\t   *\n\t   * Asserts that the target is within a range.\n\t   *\n\t   *     expect(7).to.be.within(5,10);\n\t   *\n\t   * Can also be used in conjunction with `length` to\n\t   * assert a length range. The benefit being a\n\t   * more informative error message than if the length\n\t   * was supplied directly.\n\t   *\n\t   *     expect('foo').to.have.length.within(2,4);\n\t   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);\n\t   *\n\t   * @name within\n\t   * @param {Number} start lowerbound inclusive\n\t   * @param {Number} finish upperbound inclusive\n\t   * @param {String} message _optional_\n\t   * @api public\n\t   */\n\t\n\t  Assertion.addMethod('within', function (start, finish, msg) {\n\t    if (msg) flag(this, 'message', msg);\n\t    var obj = flag(this, 'object')\n\t      , range = start + '..' + finish;\n\t    if (flag(this, 'doLength')) {\n\t      new Assertion(obj, msg).to.have.property('length');\n\t      var len = obj.length;\n\t      this.assert(\n\t          len >= start && len <= finish\n\t        , 'expected #{this} to have a length within ' + range\n\t        , 'expected #{this} to not have a length within ' + range\n\t      );\n\t    } else {\n\t      this.assert(\n\t          obj >= start && obj <= finish\n\t        , 'expected #{this} to be within ' + range\n\t        , 'expected #{this} to not be within ' + range\n\t      );\n\t    }\n\t  });\n\t\n\t  /**\n\t   * ### .instanceof(constructor)\n\t   *\n\t   * Asserts that the target is an instance of `constructor`.\n\t   *\n\t   *     var Tea = function (name) { this.name = name; }\n\t   *       , Chai = new Tea('chai');\n\t   *\n\t   *     expect(Chai).to.be.an.instanceof(Tea);\n\t   *     expect([ 1, 2, 3 ]).to.be.instanceof(Array);\n\t   *\n\t   * @name instanceof\n\t   * @param {Constructor} constructor\n\t   * @param {String} message _optional_\n\t   * @alias instanceOf\n\t   * @api public\n\t   */\n\t\n\t  function assertInstanceOf (constructor, msg) {\n\t    if (msg) flag(this, 'message', msg);\n\t    var name = _.getName(constructor);\n\t    this.assert(\n\t        flag(this, 'object') instanceof constructor\n\t      , 'expected #{this} to be an instance of ' + name\n\t      , 'expected #{this} to not be an instance of ' + name\n\t    );\n\t  };\n\t\n\t  Assertion.addMethod('instanceof', assertInstanceOf);\n\t  Assertion.addMethod('instanceOf', assertInstanceOf);\n\t\n\t  /**\n\t   * ### .property(name, [value])\n\t   *\n\t   * Asserts that the target has a property `name`, optionally asserting that\n\t   * the value of that property is strictly equal to  `value`.\n\t   * If the `deep` flag is set, you can use dot- and bracket-notation for deep\n\t   * references into objects and arrays.\n\t   *\n\t   *     // simple referencing\n\t   *     var obj = { foo: 'bar' };\n\t   *     expect(obj).to.have.property('foo');\n\t   *     expect(obj).to.have.property('foo', 'bar');\n\t   *\n\t   *     // deep referencing\n\t   *     var deepObj = {\n\t   *         green: { tea: 'matcha' }\n\t   *       , teas: [ 'chai', 'matcha', { tea: 'konacha' } ]\n\t   *     };\n\t   *\n\t   *     expect(deepObj).to.have.deep.property('green.tea', 'matcha');\n\t   *     expect(deepObj).to.have.deep.property('teas[1]', 'matcha');\n\t   *     expect(deepObj).to.have.deep.property('teas[2].tea', 'konacha');\n\t   *\n\t   * You can also use an array as the starting point of a `deep.property`\n\t   * assertion, or traverse nested arrays.\n\t   *\n\t   *     var arr = [\n\t   *         [ 'chai', 'matcha', 'konacha' ]\n\t   *       , [ { tea: 'chai' }\n\t   *         , { tea: 'matcha' }\n\t   *         , { tea: 'konacha' } ]\n\t   *     ];\n\t   *\n\t   *     expect(arr).to.have.deep.property('[0][1]', 'matcha');\n\t   *     expect(arr).to.have.deep.property('[1][2].tea', 'konacha');\n\t   *\n\t   * Furthermore, `property` changes the subject of the assertion\n\t   * to be the value of that property from the original object. This\n\t   * permits for further chainable assertions on that property.\n\t   *\n\t   *     expect(obj).to.have.property('foo')\n\t   *       .that.is.a('string');\n\t   *     expect(deepObj).to.have.property('green')\n\t   *       .that.is.an('object')\n\t   *       .that.deep.equals({ tea: 'matcha' });\n\t   *     expect(deepObj).to.have.property('teas')\n\t   *       .that.is.an('array')\n\t   *       .with.deep.property('[2]')\n\t   *         .that.deep.equals({ tea: 'konacha' });\n\t   *\n\t   * Note that dots and bracket in `name` must be backslash-escaped when\n\t   * the `deep` flag is set, while they must NOT be escaped when the `deep`\n\t   * flag is not set.\n\t   *\n\t   *     // simple referencing\n\t   *     var css = { '.link[target]': 42 };\n\t   *     expect(css).to.have.property('.link[target]', 42);\n\t   *\n\t   *     // deep referencing\n\t   *     var deepCss = { '.link': { '[target]': 42 }};\n\t   *     expect(deepCss).to.have.deep.property('\\\\.link.\\\\[target\\\\]', 42);\n\t   *\n\t   * @name property\n\t   * @alias deep.property\n\t   * @param {String} name\n\t   * @param {Mixed} value (optional)\n\t   * @param {String} message _optional_\n\t   * @returns value of property for chaining\n\t   * @api public\n\t   */\n\t\n\t  Assertion.addMethod('property', function (name, val, msg) {\n\t    if (msg) flag(this, 'message', msg);\n\t\n\t    var isDeep = !!flag(this, 'deep')\n\t      , descriptor = isDeep ? 'deep property ' : 'property '\n\t      , negate = flag(this, 'negate')\n\t      , obj = flag(this, 'object')\n\t      , pathInfo = isDeep ? _.getPathInfo(name, obj) : null\n\t      , hasProperty = isDeep\n\t        ? pathInfo.exists\n\t        : _.hasProperty(name, obj)\n\t      , value = isDeep\n\t        ? pathInfo.value\n\t        : obj[name];\n\t\n\t    if (negate && arguments.length > 1) {\n\t      if (undefined === value) {\n\t        msg = (msg != null) ? msg + ': ' : '';\n\t        throw new Error(msg + _.inspect(obj) + ' has no ' + descriptor + _.inspect(name));\n\t      }\n\t    } else {\n\t      this.assert(\n\t          hasProperty\n\t        , 'expected #{this} to have a ' + descriptor + _.inspect(name)\n\t        , 'expected #{this} to not have ' + descriptor + _.inspect(name));\n\t    }\n\t\n\t    if (arguments.length > 1) {\n\t      this.assert(\n\t          val === value\n\t        , 'expected #{this} to have a ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'\n\t        , 'expected #{this} to not have a ' + descriptor + _.inspect(name) + ' of #{act}'\n\t        , val\n\t        , value\n\t      );\n\t    }\n\t\n\t    flag(this, 'object', value);\n\t  });\n\t\n\t\n\t  /**\n\t   * ### .ownProperty(name)\n\t   *\n\t   * Asserts that the target has an own property `name`.\n\t   *\n\t   *     expect('test').to.have.ownProperty('length');\n\t   *\n\t   * @name ownProperty\n\t   * @alias haveOwnProperty\n\t   * @param {String} name\n\t   * @param {String} message _optional_\n\t   * @api public\n\t   */\n\t\n\t  function assertOwnProperty (name, msg) {\n\t    if (msg) flag(this, 'message', msg);\n\t    var obj = flag(this, 'object');\n\t    this.assert(\n\t        obj.hasOwnProperty(name)\n\t      , 'expected #{this} to have own property ' + _.inspect(name)\n\t      , 'expected #{this} to not have own property ' + _.inspect(name)\n\t    );\n\t  }\n\t\n\t  Assertion.addMethod('ownProperty', assertOwnProperty);\n\t  Assertion.addMethod('haveOwnProperty', assertOwnProperty);\n\t\n\t  /**\n\t   * ### .ownPropertyDescriptor(name[, descriptor[, message]])\n\t   *\n\t   * Asserts that the target has an own property descriptor `name`, that optionally matches `descriptor`.\n\t   *\n\t   *     expect('test').to.have.ownPropertyDescriptor('length');\n\t   *     expect('test').to.have.ownPropertyDescriptor('length', { enumerable: false, configurable: false, writable: false, value: 4 });\n\t   *     expect('test').not.to.have.ownPropertyDescriptor('length', { enumerable: false, configurable: false, writable: false, value: 3 });\n\t   *     expect('test').ownPropertyDescriptor('length').to.have.property('enumerable', false);\n\t   *     expect('test').ownPropertyDescriptor('length').to.have.keys('value');\n\t   *\n\t   * @name ownPropertyDescriptor\n\t   * @alias haveOwnPropertyDescriptor\n\t   * @param {String} name\n\t   * @param {Object} descriptor _optional_\n\t   * @param {String} message _optional_\n\t   * @api public\n\t   */\n\t\n\t  function assertOwnPropertyDescriptor (name, descriptor, msg) {\n\t    if (typeof descriptor === 'string') {\n\t      msg = descriptor;\n\t      descriptor = null;\n\t    }\n\t    if (msg) flag(this, 'message', msg);\n\t    var obj = flag(this, 'object');\n\t    var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);\n\t    if (actualDescriptor && descriptor) {\n\t      this.assert(\n\t          _.eql(descriptor, actualDescriptor)\n\t        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to match ' + _.inspect(descriptor) + ', got ' + _.inspect(actualDescriptor)\n\t        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to not match ' + _.inspect(descriptor)\n\t        , descriptor\n\t        , actualDescriptor\n\t        , true\n\t      );\n\t    } else {\n\t      this.assert(\n\t          actualDescriptor\n\t        , 'expected #{this} to have an own property descriptor for ' + _.inspect(name)\n\t        , 'expected #{this} to not have an own property descriptor for ' + _.inspect(name)\n\t      );\n\t    }\n\t    flag(this, 'object', actualDescriptor);\n\t  }\n\t\n\t  Assertion.addMethod('ownPropertyDescriptor', assertOwnPropertyDescriptor);\n\t  Assertion.addMethod('haveOwnPropertyDescriptor', assertOwnPropertyDescriptor);\n\t\n\t  /**\n\t   * ### .length\n\t   *\n\t   * Sets the `doLength` flag later used as a chain precursor to a value\n\t   * comparison for the `length` property.\n\t   *\n\t   *     expect('foo').to.have.length.above(2);\n\t   *     expect([ 1, 2, 3 ]).to.have.length.above(2);\n\t   *     expect('foo').to.have.length.below(4);\n\t   *     expect([ 1, 2, 3 ]).to.have.length.below(4);\n\t   *     expect('foo').to.have.length.within(2,4);\n\t   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);\n\t   *\n\t   * *Deprecation notice:* Using `length` as an assertion will be deprecated\n\t   * in version 2.4.0 and removed in 3.0.0. Code using the old style of\n\t   * asserting for `length` property value using `length(value)` should be\n\t   * switched to use `lengthOf(value)` instead.\n\t   *\n\t   * @name length\n\t   * @api public\n\t   */\n\t\n\t  /**\n\t   * ### .lengthOf(value[, message])\n\t   *\n\t   * Asserts that the target's `length` property has\n\t   * the expected value.\n\t   *\n\t   *     expect([ 1, 2, 3]).to.have.lengthOf(3);\n\t   *     expect('foobar').to.have.lengthOf(6);\n\t   *\n\t   * @name lengthOf\n\t   * @param {Number} length\n\t   * @param {String} message _optional_\n\t   * @api public\n\t   */\n\t\n\t  function assertLengthChain () {\n\t    flag(this, 'doLength', true);\n\t  }\n\t\n\t  function assertLength (n, msg) {\n\t    if (msg) flag(this, 'message', msg);\n\t    var obj = flag(this, 'object');\n\t    new Assertion(obj, msg).to.have.property('length');\n\t    var len = obj.length;\n\t\n\t    this.assert(\n\t        len == n\n\t      , 'expected #{this} to have a length of #{exp} but got #{act}'\n\t      , 'expected #{this} to not have a length of #{act}'\n\t      , n\n\t      , len\n\t    );\n\t  }\n\t\n\t  Assertion.addChainableMethod('length', assertLength, assertLengthChain);\n\t  Assertion.addMethod('lengthOf', assertLength);\n\t\n\t  /**\n\t   * ### .match(regexp)\n\t   *\n\t   * Asserts that the target matches a regular expression.\n\t   *\n\t   *     expect('foobar').to.match(/^foo/);\n\t   *\n\t   * @name match\n\t   * @alias matches\n\t   * @param {RegExp} RegularExpression\n\t   * @param {String} message _optional_\n\t   * @api public\n\t   */\n\t  function assertMatch(re, msg) {\n\t    if (msg) flag(this, 'message', msg);\n\t    var obj = flag(this, 'object');\n\t    this.assert(\n\t        re.exec(obj)\n\t      , 'expected #{this} to match ' + re\n\t      , 'expected #{this} not to match ' + re\n\t    );\n\t  }\n\t\n\t  Assertion.addMethod('match', assertMatch);\n\t  Assertion.addMethod('matches', assertMatch);\n\t\n\t  /**\n\t   * ### .string(string)\n\t   *\n\t   * Asserts that the string target contains another string.\n\t   *\n\t   *     expect('foobar').to.have.string('bar');\n\t   *\n\t   * @name string\n\t   * @param {String} string\n\t   * @param {String} message _optional_\n\t   * @api public\n\t   */\n\t\n\t  Assertion.addMethod('string', function (str, msg) {\n\t    if (msg) flag(this, 'message', msg);\n\t    var obj = flag(this, 'object');\n\t    new Assertion(obj, msg).is.a('string');\n\t\n\t    this.assert(\n\t        ~obj.indexOf(str)\n\t      , 'expected #{this} to contain ' + _.inspect(str)\n\t      , 'expected #{this} to not contain ' + _.inspect(str)\n\t    );\n\t  });\n\t\n\t\n\t  /**\n\t   * ### .keys(key1, [key2], [...])\n\t   *\n\t   * Asserts that the target contains any or all of the passed-in keys.\n\t   * Use in combination with `any`, `all`, `contains`, or `have` will affect\n\t   * what will pass.\n\t   *\n\t   * When used in conjunction with `any`, at least one key that is passed\n\t   * in must exist in the target object. This is regardless whether or not\n\t   * the `have` or `contain` qualifiers are used. Note, either `any` or `all`\n\t   * should be used in the assertion. If neither are used, the assertion is\n\t   * defaulted to `all`.\n\t   *\n\t   * When both `all` and `contain` are used, the target object must have at\n\t   * least all of the passed-in keys but may have more keys not listed.\n\t   *\n\t   * When both `all` and `have` are used, the target object must both contain\n\t   * all of the passed-in keys AND the number of keys in the target object must\n\t   * match the number of keys passed in (in other words, a target object must\n\t   * have all and only all of the passed-in keys).\n\t   *\n\t   *     expect({ foo: 1, bar: 2 }).to.have.any.keys('foo', 'baz');\n\t   *     expect({ foo: 1, bar: 2 }).to.have.any.keys('foo');\n\t   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys('bar', 'baz');\n\t   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys(['foo']);\n\t   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys({'foo': 6});\n\t   *     expect({ foo: 1, bar: 2 }).to.have.all.keys(['bar', 'foo']);\n\t   *     expect({ foo: 1, bar: 2 }).to.have.all.keys({'bar': 6, 'foo': 7});\n\t   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys(['bar', 'foo']);\n\t   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys({'bar': 6});\n\t   *\n\t   *\n\t   * @name keys\n\t   * @alias key\n\t   * @param {...String|Array|Object} keys\n\t   * @api public\n\t   */\n\t\n\t  function assertKeys (keys) {\n\t    var obj = flag(this, 'object')\n\t      , str\n\t      , ok = true\n\t      , mixedArgsMsg = 'keys must be given single argument of Array|Object|String, or multiple String arguments';\n\t\n\t    switch (_.type(keys)) {\n\t      case \"array\":\n\t        if (arguments.length > 1) throw (new Error(mixedArgsMsg));\n\t        break;\n\t      case \"object\":\n\t        if (arguments.length > 1) throw (new Error(mixedArgsMsg));\n\t        keys = Object.keys(keys);\n\t        break;\n\t      default:\n\t        keys = Array.prototype.slice.call(arguments);\n\t    }\n\t\n\t    if (!keys.length) throw new Error('keys required');\n\t\n\t    var actual = Object.keys(obj)\n\t      , expected = keys\n\t      , len = keys.length\n\t      , any = flag(this, 'any')\n\t      , all = flag(this, 'all');\n\t\n\t    if (!any && !all) {\n\t      all = true;\n\t    }\n\t\n\t    // Has any\n\t    if (any) {\n\t      var intersection = expected.filter(function(key) {\n\t        return ~actual.indexOf(key);\n\t      });\n\t      ok = intersection.length > 0;\n\t    }\n\t\n\t    // Has all\n\t    if (all) {\n\t      ok = keys.every(function(key){\n\t        return ~actual.indexOf(key);\n\t      });\n\t      if (!flag(this, 'negate') && !flag(this, 'contains')) {\n\t        ok = ok && keys.length == actual.length;\n\t      }\n\t    }\n\t\n\t    // Key string\n\t    if (len > 1) {\n\t      keys = keys.map(function(key){\n\t        return _.inspect(key);\n\t      });\n\t      var last = keys.pop();\n\t      if (all) {\n\t        str = keys.join(', ') + ', and ' + last;\n\t      }\n\t      if (any) {\n\t        str = keys.join(', ') + ', or ' + last;\n\t      }\n\t    } else {\n\t      str = _.inspect(keys[0]);\n\t    }\n\t\n\t    // Form\n\t    str = (len > 1 ? 'keys ' : 'key ') + str;\n\t\n\t    // Have / include\n\t    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;\n\t\n\t    // Assertion\n\t    this.assert(\n\t        ok\n\t      , 'expected #{this} to ' + str\n\t      , 'expected #{this} to not ' + str\n\t      , expected.slice(0).sort()\n\t      , actual.sort()\n\t      , true\n\t    );\n\t  }\n\t\n\t  Assertion.addMethod('keys', assertKeys);\n\t  Assertion.addMethod('key', assertKeys);\n\t\n\t  /**\n\t   * ### .throw(constructor)\n\t   *\n\t   * Asserts that the function target will throw a specific error, or specific type of error\n\t   * (as determined using `instanceof`), optionally with a RegExp or string inclusion test\n\t   * for the error's message.\n\t   *\n\t   *     var err = new ReferenceError('This is a bad function.');\n\t   *     var fn = function () { throw err; }\n\t   *     expect(fn).to.throw(ReferenceError);\n\t   *     expect(fn).to.throw(Error);\n\t   *     expect(fn).to.throw(/bad function/);\n\t   *     expect(fn).to.not.throw('good function');\n\t   *     expect(fn).to.throw(ReferenceError, /bad function/);\n\t   *     expect(fn).to.throw(err);\n\t   *\n\t   * Please note that when a throw expectation is negated, it will check each\n\t   * parameter independently, starting with error constructor type. The appropriate way\n\t   * to check for the existence of a type of error but for a message that does not match\n\t   * is to use `and`.\n\t   *\n\t   *     expect(fn).to.throw(ReferenceError)\n\t   *        .and.not.throw(/good function/);\n\t   *\n\t   * @name throw\n\t   * @alias throws\n\t   * @alias Throw\n\t   * @param {ErrorConstructor} constructor\n\t   * @param {String|RegExp} expected error message\n\t   * @param {String} message _optional_\n\t   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n\t   * @returns error for chaining (null if no error)\n\t   * @api public\n\t   */\n\t\n\t  function assertThrows (constructor, errMsg, msg) {\n\t    if (msg) flag(this, 'message', msg);\n\t    var obj = flag(this, 'object');\n\t    new Assertion(obj, msg).is.a('function');\n\t\n\t    var thrown = false\n\t      , desiredError = null\n\t      , name = null\n\t      , thrownError = null;\n\t\n\t    if (arguments.length === 0) {\n\t      errMsg = null;\n\t      constructor = null;\n\t    } else if (constructor && (constructor instanceof RegExp || 'string' === typeof constructor)) {\n\t      errMsg = constructor;\n\t      constructor = null;\n\t    } else if (constructor && constructor instanceof Error) {\n\t      desiredError = constructor;\n\t      constructor = null;\n\t      errMsg = null;\n\t    } else if (typeof constructor === 'function') {\n\t      name = constructor.prototype.name;\n\t      if (!name || (name === 'Error' && constructor !== Error)) {\n\t        name = constructor.name || (new constructor()).name;\n\t      }\n\t    } else {\n\t      constructor = null;\n\t    }\n\t\n\t    try {\n\t      obj();\n\t    } catch (err) {\n\t      // first, check desired error\n\t      if (desiredError) {\n\t        this.assert(\n\t            err === desiredError\n\t          , 'expected #{this} to throw #{exp} but #{act} was thrown'\n\t          , 'expected #{this} to not throw #{exp}'\n\t          , (desiredError instanceof Error ? desiredError.toString() : desiredError)\n\t          , (err instanceof Error ? err.toString() : err)\n\t        );\n\t\n\t        flag(this, 'object', err);\n\t        return this;\n\t      }\n\t\n\t      // next, check constructor\n\t      if (constructor) {\n\t        this.assert(\n\t            err instanceof constructor\n\t          , 'expected #{this} to throw #{exp} but #{act} was thrown'\n\t          , 'expected #{this} to not throw #{exp} but #{act} was thrown'\n\t          , name\n\t          , (err instanceof Error ? err.toString() : err)\n\t        );\n\t\n\t        if (!errMsg) {\n\t          flag(this, 'object', err);\n\t          return this;\n\t        }\n\t      }\n\t\n\t      // next, check message\n\t      var message = 'error' === _.type(err) && \"message\" in err\n\t        ? err.message\n\t        : '' + err;\n\t\n\t      if ((message != null) && errMsg && errMsg instanceof RegExp) {\n\t        this.assert(\n\t            errMsg.exec(message)\n\t          , 'expected #{this} to throw error matching #{exp} but got #{act}'\n\t          , 'expected #{this} to throw error not matching #{exp}'\n\t          , errMsg\n\t          , message\n\t        );\n\t\n\t        flag(this, 'object', err);\n\t        return this;\n\t      } else if ((message != null) && errMsg && 'string' === typeof errMsg) {\n\t        this.assert(\n\t            ~message.indexOf(errMsg)\n\t          , 'expected #{this} to throw error including #{exp} but got #{act}'\n\t          , 'expected #{this} to throw error not including #{act}'\n\t          , errMsg\n\t          , message\n\t        );\n\t\n\t        flag(this, 'object', err);\n\t        return this;\n\t      } else {\n\t        thrown = true;\n\t        thrownError = err;\n\t      }\n\t    }\n\t\n\t    var actuallyGot = ''\n\t      , expectedThrown = name !== null\n\t        ? name\n\t        : desiredError\n\t          ? '#{exp}' //_.inspect(desiredError)\n\t          : 'an error';\n\t\n\t    if (thrown) {\n\t      actuallyGot = ' but #{act} was thrown'\n\t    }\n\t\n\t    this.assert(\n\t        thrown === true\n\t      , 'expected #{this} to throw ' + expectedThrown + actuallyGot\n\t      , 'expected #{this} to not throw ' + expectedThrown + actuallyGot\n\t      , (desiredError instanceof Error ? desiredError.toString() : desiredError)\n\t      , (thrownError instanceof Error ? thrownError.toString() : thrownError)\n\t    );\n\t\n\t    flag(this, 'object', thrownError);\n\t  };\n\t\n\t  Assertion.addMethod('throw', assertThrows);\n\t  Assertion.addMethod('throws', assertThrows);\n\t  Assertion.addMethod('Throw', assertThrows);\n\t\n\t  /**\n\t   * ### .respondTo(method)\n\t   *\n\t   * Asserts that the object or class target will respond to a method.\n\t   *\n\t   *     Klass.prototype.bar = function(){};\n\t   *     expect(Klass).to.respondTo('bar');\n\t   *     expect(obj).to.respondTo('bar');\n\t   *\n\t   * To check if a constructor will respond to a static function,\n\t   * set the `itself` flag.\n\t   *\n\t   *     Klass.baz = function(){};\n\t   *     expect(Klass).itself.to.respondTo('baz');\n\t   *\n\t   * @name respondTo\n\t   * @alias respondsTo\n\t   * @param {String} method\n\t   * @param {String} message _optional_\n\t   * @api public\n\t   */\n\t\n\t  function respondTo (method, msg) {\n\t    if (msg) flag(this, 'message', msg);\n\t    var obj = flag(this, 'object')\n\t      , itself = flag(this, 'itself')\n\t      , context = ('function' === _.type(obj) && !itself)\n\t        ? obj.prototype[method]\n\t        : obj[method];\n\t\n\t    this.assert(\n\t        'function' === typeof context\n\t      , 'expected #{this} to respond to ' + _.inspect(method)\n\t      , 'expected #{this} to not respond to ' + _.inspect(method)\n\t    );\n\t  }\n\t\n\t  Assertion.addMethod('respondTo', respondTo);\n\t  Assertion.addMethod('respondsTo', respondTo);\n\t\n\t  /**\n\t   * ### .itself\n\t   *\n\t   * Sets the `itself` flag, later used by the `respondTo` assertion.\n\t   *\n\t   *     function Foo() {}\n\t   *     Foo.bar = function() {}\n\t   *     Foo.prototype.baz = function() {}\n\t   *\n\t   *     expect(Foo).itself.to.respondTo('bar');\n\t   *     expect(Foo).itself.not.to.respondTo('baz');\n\t   *\n\t   * @name itself\n\t   * @api public\n\t   */\n\t\n\t  Assertion.addProperty('itself', function () {\n\t    flag(this, 'itself', true);\n\t  });\n\t\n\t  /**\n\t   * ### .satisfy(method)\n\t   *\n\t   * Asserts that the target passes a given truth test.\n\t   *\n\t   *     expect(1).to.satisfy(function(num) { return num > 0; });\n\t   *\n\t   * @name satisfy\n\t   * @alias satisfies\n\t   * @param {Function} matcher\n\t   * @param {String} message _optional_\n\t   * @api public\n\t   */\n\t\n\t  function satisfy (matcher, msg) {\n\t    if (msg) flag(this, 'message', msg);\n\t    var obj = flag(this, 'object');\n\t    var result = matcher(obj);\n\t    this.assert(\n\t        result\n\t      , 'expected #{this} to satisfy ' + _.objDisplay(matcher)\n\t      , 'expected #{this} to not satisfy' + _.objDisplay(matcher)\n\t      , this.negate ? false : true\n\t      , result\n\t    );\n\t  }\n\t\n\t  Assertion.addMethod('satisfy', satisfy);\n\t  Assertion.addMethod('satisfies', satisfy);\n\t\n\t  /**\n\t   * ### .closeTo(expected, delta)\n\t   *\n\t   * Asserts that the target is equal `expected`, to within a +/- `delta` range.\n\t   *\n\t   *     expect(1.5).to.be.closeTo(1, 0.5);\n\t   *\n\t   * @name closeTo\n\t   * @alias approximately\n\t   * @param {Number} expected\n\t   * @param {Number} delta\n\t   * @param {String} message _optional_\n\t   * @api public\n\t   */\n\t\n\t  function closeTo(expected, delta, msg) {\n\t    if (msg) flag(this, 'message', msg);\n\t    var obj = flag(this, 'object');\n\t\n\t    new Assertion(obj, msg).is.a('number');\n\t    if (_.type(expected) !== 'number' || _.type(delta) !== 'number') {\n\t      throw new Error('the arguments to closeTo or approximately must be numbers');\n\t    }\n\t\n\t    this.assert(\n\t        Math.abs(obj - expected) <= delta\n\t      , 'expected #{this} to be close to ' + expected + ' +/- ' + delta\n\t      , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta\n\t    );\n\t  }\n\t\n\t  Assertion.addMethod('closeTo', closeTo);\n\t  Assertion.addMethod('approximately', closeTo);\n\t\n\t  function isSubsetOf(subset, superset, cmp) {\n\t    return subset.every(function(elem) {\n\t      if (!cmp) return superset.indexOf(elem) !== -1;\n\t\n\t      return superset.some(function(elem2) {\n\t        return cmp(elem, elem2);\n\t      });\n\t    })\n\t  }\n\t\n\t  /**\n\t   * ### .members(set)\n\t   *\n\t   * Asserts that the target is a superset of `set`,\n\t   * or that the target and `set` have the same strictly-equal (===) members.\n\t   * Alternately, if the `deep` flag is set, set members are compared for deep\n\t   * equality.\n\t   *\n\t   *     expect([1, 2, 3]).to.include.members([3, 2]);\n\t   *     expect([1, 2, 3]).to.not.include.members([3, 2, 8]);\n\t   *\n\t   *     expect([4, 2]).to.have.members([2, 4]);\n\t   *     expect([5, 2]).to.not.have.members([5, 2, 1]);\n\t   *\n\t   *     expect([{ id: 1 }]).to.deep.include.members([{ id: 1 }]);\n\t   *\n\t   * @name members\n\t   * @param {Array} set\n\t   * @param {String} message _optional_\n\t   * @api public\n\t   */\n\t\n\t  Assertion.addMethod('members', function (subset, msg) {\n\t    if (msg) flag(this, 'message', msg);\n\t    var obj = flag(this, 'object');\n\t\n\t    new Assertion(obj).to.be.an('array');\n\t    new Assertion(subset).to.be.an('array');\n\t\n\t    var cmp = flag(this, 'deep') ? _.eql : undefined;\n\t\n\t    if (flag(this, 'contains')) {\n\t      return this.assert(\n\t          isSubsetOf(subset, obj, cmp)\n\t        , 'expected #{this} to be a superset of #{act}'\n\t        , 'expected #{this} to not be a superset of #{act}'\n\t        , obj\n\t        , subset\n\t      );\n\t    }\n\t\n\t    this.assert(\n\t        isSubsetOf(obj, subset, cmp) && isSubsetOf(subset, obj, cmp)\n\t        , 'expected #{this} to have the same members as #{act}'\n\t        , 'expected #{this} to not have the same members as #{act}'\n\t        , obj\n\t        , subset\n\t    );\n\t  });\n\t\n\t  /**\n\t   * ### .oneOf(list)\n\t   *\n\t   * Assert that a value appears somewhere in the top level of array `list`.\n\t   *\n\t   *     expect('a').to.be.oneOf(['a', 'b', 'c']);\n\t   *     expect(9).to.not.be.oneOf(['z']);\n\t   *     expect([3]).to.not.be.oneOf([1, 2, [3]]);\n\t   *\n\t   *     var three = [3];\n\t   *     // for object-types, contents are not compared\n\t   *     expect(three).to.not.be.oneOf([1, 2, [3]]);\n\t   *     // comparing references works\n\t   *     expect(three).to.be.oneOf([1, 2, three]);\n\t   *\n\t   * @name oneOf\n\t   * @param {Array<*>} list\n\t   * @param {String} message _optional_\n\t   * @api public\n\t   */\n\t\n\t  function oneOf (list, msg) {\n\t    if (msg) flag(this, 'message', msg);\n\t    var expected = flag(this, 'object');\n\t    new Assertion(list).to.be.an('array');\n\t\n\t    this.assert(\n\t        list.indexOf(expected) > -1\n\t      , 'expected #{this} to be one of #{exp}'\n\t      , 'expected #{this} to not be one of #{exp}'\n\t      , list\n\t      , expected\n\t    );\n\t  }\n\t\n\t  Assertion.addMethod('oneOf', oneOf);\n\t\n\t\n\t  /**\n\t   * ### .change(function)\n\t   *\n\t   * Asserts that a function changes an object property\n\t   *\n\t   *     var obj = { val: 10 };\n\t   *     var fn = function() { obj.val += 3 };\n\t   *     var noChangeFn = function() { return 'foo' + 'bar'; }\n\t   *     expect(fn).to.change(obj, 'val');\n\t   *     expect(noChangFn).to.not.change(obj, 'val')\n\t   *\n\t   * @name change\n\t   * @alias changes\n\t   * @alias Change\n\t   * @param {String} object\n\t   * @param {String} property name\n\t   * @param {String} message _optional_\n\t   * @api public\n\t   */\n\t\n\t  function assertChanges (object, prop, msg) {\n\t    if (msg) flag(this, 'message', msg);\n\t    var fn = flag(this, 'object');\n\t    new Assertion(object, msg).to.have.property(prop);\n\t    new Assertion(fn).is.a('function');\n\t\n\t    var initial = object[prop];\n\t    fn();\n\t\n\t    this.assert(\n\t      initial !== object[prop]\n\t      , 'expected .' + prop + ' to change'\n\t      , 'expected .' + prop + ' to not change'\n\t    );\n\t  }\n\t\n\t  Assertion.addChainableMethod('change', assertChanges);\n\t  Assertion.addChainableMethod('changes', assertChanges);\n\t\n\t  /**\n\t   * ### .increase(function)\n\t   *\n\t   * Asserts that a function increases an object property\n\t   *\n\t   *     var obj = { val: 10 };\n\t   *     var fn = function() { obj.val = 15 };\n\t   *     expect(fn).to.increase(obj, 'val');\n\t   *\n\t   * @name increase\n\t   * @alias increases\n\t   * @alias Increase\n\t   * @param {String} object\n\t   * @param {String} property name\n\t   * @param {String} message _optional_\n\t   * @api public\n\t   */\n\t\n\t  function assertIncreases (object, prop, msg) {\n\t    if (msg) flag(this, 'message', msg);\n\t    var fn = flag(this, 'object');\n\t    new Assertion(object, msg).to.have.property(prop);\n\t    new Assertion(fn).is.a('function');\n\t\n\t    var initial = object[prop];\n\t    fn();\n\t\n\t    this.assert(\n\t      object[prop] - initial > 0\n\t      , 'expected .' + prop + ' to increase'\n\t      , 'expected .' + prop + ' to not increase'\n\t    );\n\t  }\n\t\n\t  Assertion.addChainableMethod('increase', assertIncreases);\n\t  Assertion.addChainableMethod('increases', assertIncreases);\n\t\n\t  /**\n\t   * ### .decrease(function)\n\t   *\n\t   * Asserts that a function decreases an object property\n\t   *\n\t   *     var obj = { val: 10 };\n\t   *     var fn = function() { obj.val = 5 };\n\t   *     expect(fn).to.decrease(obj, 'val');\n\t   *\n\t   * @name decrease\n\t   * @alias decreases\n\t   * @alias Decrease\n\t   * @param {String} object\n\t   * @param {String} property name\n\t   * @param {String} message _optional_\n\t   * @api public\n\t   */\n\t\n\t  function assertDecreases (object, prop, msg) {\n\t    if (msg) flag(this, 'message', msg);\n\t    var fn = flag(this, 'object');\n\t    new Assertion(object, msg).to.have.property(prop);\n\t    new Assertion(fn).is.a('function');\n\t\n\t    var initial = object[prop];\n\t    fn();\n\t\n\t    this.assert(\n\t      object[prop] - initial < 0\n\t      , 'expected .' + prop + ' to decrease'\n\t      , 'expected .' + prop + ' to not decrease'\n\t    );\n\t  }\n\t\n\t  Assertion.addChainableMethod('decrease', assertDecreases);\n\t  Assertion.addChainableMethod('decreases', assertDecreases);\n\t\n\t  /**\n\t   * ### .extensible\n\t   *\n\t   * Asserts that the target is extensible (can have new properties added to\n\t   * it).\n\t   *\n\t   *     var nonExtensibleObject = Object.preventExtensions({});\n\t   *     var sealedObject = Object.seal({});\n\t   *     var frozenObject = Object.freeze({});\n\t   *\n\t   *     expect({}).to.be.extensible;\n\t   *     expect(nonExtensibleObject).to.not.be.extensible;\n\t   *     expect(sealedObject).to.not.be.extensible;\n\t   *     expect(frozenObject).to.not.be.extensible;\n\t   *\n\t   * @name extensible\n\t   * @api public\n\t   */\n\t\n\t  Assertion.addProperty('extensible', function() {\n\t    var obj = flag(this, 'object');\n\t\n\t    // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.\n\t    // In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.\n\t    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible\n\t    // The following provides ES6 behavior when a TypeError is thrown under ES5.\n\t\n\t    var isExtensible;\n\t\n\t    try {\n\t      isExtensible = Object.isExtensible(obj);\n\t    } catch (err) {\n\t      if (err instanceof TypeError) isExtensible = false;\n\t      else throw err;\n\t    }\n\t\n\t    this.assert(\n\t      isExtensible\n\t      , 'expected #{this} to be extensible'\n\t      , 'expected #{this} to not be extensible'\n\t    );\n\t  });\n\t\n\t  /**\n\t   * ### .sealed\n\t   *\n\t   * Asserts that the target is sealed (cannot have new properties added to it\n\t   * and its existing properties cannot be removed).\n\t   *\n\t   *     var sealedObject = Object.seal({});\n\t   *     var frozenObject = Object.freeze({});\n\t   *\n\t   *     expect(sealedObject).to.be.sealed;\n\t   *     expect(frozenObject).to.be.sealed;\n\t   *     expect({}).to.not.be.sealed;\n\t   *\n\t   * @name sealed\n\t   * @api public\n\t   */\n\t\n\t  Assertion.addProperty('sealed', function() {\n\t    var obj = flag(this, 'object');\n\t\n\t    // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.\n\t    // In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.\n\t    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed\n\t    // The following provides ES6 behavior when a TypeError is thrown under ES5.\n\t\n\t    var isSealed;\n\t\n\t    try {\n\t      isSealed = Object.isSealed(obj);\n\t    } catch (err) {\n\t      if (err instanceof TypeError) isSealed = true;\n\t      else throw err;\n\t    }\n\t\n\t    this.assert(\n\t      isSealed\n\t      , 'expected #{this} to be sealed'\n\t      , 'expected #{this} to not be sealed'\n\t    );\n\t  });\n\t\n\t  /**\n\t   * ### .frozen\n\t   *\n\t   * Asserts that the target is frozen (cannot have new properties added to it\n\t   * and its existing properties cannot be modified).\n\t   *\n\t   *     var frozenObject = Object.freeze({});\n\t   *\n\t   *     expect(frozenObject).to.be.frozen;\n\t   *     expect({}).to.not.be.frozen;\n\t   *\n\t   * @name frozen\n\t   * @api public\n\t   */\n\t\n\t  Assertion.addProperty('frozen', function() {\n\t    var obj = flag(this, 'object');\n\t\n\t    // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.\n\t    // In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.\n\t    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen\n\t    // The following provides ES6 behavior when a TypeError is thrown under ES5.\n\t\n\t    var isFrozen;\n\t\n\t    try {\n\t      isFrozen = Object.isFrozen(obj);\n\t    } catch (err) {\n\t      if (err instanceof TypeError) isFrozen = true;\n\t      else throw err;\n\t    }\n\t\n\t    this.assert(\n\t      isFrozen\n\t      , 'expected #{this} to be frozen'\n\t      , 'expected #{this} to not be frozen'\n\t    );\n\t  });\n\t};\n\n\n/***/ },\n/* 48 */\n/***/ function(module, exports) {\n\n\t/*!\n\t * chai\n\t * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n\t * MIT Licensed\n\t */\n\t\n\tmodule.exports = function (chai, util) {\n\t  chai.expect = function (val, message) {\n\t    return new chai.Assertion(val, message);\n\t  };\n\t\n\t  /**\n\t   * ### .fail(actual, expected, [message], [operator])\n\t   *\n\t   * Throw a failure.\n\t   *\n\t   * @name fail\n\t   * @param {Mixed} actual\n\t   * @param {Mixed} expected\n\t   * @param {String} message\n\t   * @param {String} operator\n\t   * @api public\n\t   */\n\t\n\t  chai.expect.fail = function (actual, expected, message, operator) {\n\t    message = message || 'expect.fail()';\n\t    throw new chai.AssertionError(message, {\n\t        actual: actual\n\t      , expected: expected\n\t      , operator: operator\n\t    }, chai.expect.fail);\n\t  };\n\t};\n\n\n/***/ },\n/* 49 */\n/***/ function(module, exports) {\n\n\t/*!\n\t * chai\n\t * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n\t * MIT Licensed\n\t */\n\t\n\tmodule.exports = function (chai, util) {\n\t  var Assertion = chai.Assertion;\n\t\n\t  function loadShould () {\n\t    // explicitly define this method as function as to have it's name to include as `ssfi`\n\t    function shouldGetter() {\n\t      if (this instanceof String || this instanceof Number || this instanceof Boolean ) {\n\t        return new Assertion(this.valueOf(), null, shouldGetter);\n\t      }\n\t      return new Assertion(this, null, shouldGetter);\n\t    }\n\t    function shouldSetter(value) {\n\t      // See https://github.com/chaijs/chai/issues/86: this makes\n\t      // `whatever.should = someValue` actually set `someValue`, which is\n\t      // especially useful for `global.should = require('chai').should()`.\n\t      //\n\t      // Note that we have to use [[DefineProperty]] instead of [[Put]]\n\t      // since otherwise we would trigger this very setter!\n\t      Object.defineProperty(this, 'should', {\n\t        value: value,\n\t        enumerable: true,\n\t        configurable: true,\n\t        writable: true\n\t      });\n\t    }\n\t    // modify Object.prototype to have `should`\n\t    Object.defineProperty(Object.prototype, 'should', {\n\t      set: shouldSetter\n\t      , get: shouldGetter\n\t      , configurable: true\n\t    });\n\t\n\t    var should = {};\n\t\n\t    /**\n\t     * ### .fail(actual, expected, [message], [operator])\n\t     *\n\t     * Throw a failure.\n\t     *\n\t     * @name fail\n\t     * @param {Mixed} actual\n\t     * @param {Mixed} expected\n\t     * @param {String} message\n\t     * @param {String} operator\n\t     * @api public\n\t     */\n\t\n\t    should.fail = function (actual, expected, message, operator) {\n\t      message = message || 'should.fail()';\n\t      throw new chai.AssertionError(message, {\n\t          actual: actual\n\t        , expected: expected\n\t        , operator: operator\n\t      }, should.fail);\n\t    };\n\t\n\t    should.equal = function (val1, val2, msg) {\n\t      new Assertion(val1, msg).to.equal(val2);\n\t    };\n\t\n\t    should.Throw = function (fn, errt, errs, msg) {\n\t      new Assertion(fn, msg).to.Throw(errt, errs);\n\t    };\n\t\n\t    should.exist = function (val, msg) {\n\t      new Assertion(val, msg).to.exist;\n\t    }\n\t\n\t    // negation\n\t    should.not = {}\n\t\n\t    should.not.equal = function (val1, val2, msg) {\n\t      new Assertion(val1, msg).to.not.equal(val2);\n\t    };\n\t\n\t    should.not.Throw = function (fn, errt, errs, msg) {\n\t      new Assertion(fn, msg).to.not.Throw(errt, errs);\n\t    };\n\t\n\t    should.not.exist = function (val, msg) {\n\t      new Assertion(val, msg).to.not.exist;\n\t    }\n\t\n\t    should['throw'] = should['Throw'];\n\t    should.not['throw'] = should.not['Throw'];\n\t\n\t    return should;\n\t  };\n\t\n\t  chai.should = loadShould;\n\t  chai.Should = loadShould;\n\t};\n\n\n/***/ },\n/* 50 */\n/***/ function(module, exports) {\n\n\t/*!\n\t * chai\n\t * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n\t * MIT Licensed\n\t */\n\t\n\t\n\tmodule.exports = function (chai, util) {\n\t\n\t  /*!\n\t   * Chai dependencies.\n\t   */\n\t\n\t  var Assertion = chai.Assertion\n\t    , flag = util.flag;\n\t\n\t  /*!\n\t   * Module export.\n\t   */\n\t\n\t  /**\n\t   * ### assert(expression, message)\n\t   *\n\t   * Write your own test expressions.\n\t   *\n\t   *     assert('foo' !== 'bar', 'foo is not bar');\n\t   *     assert(Array.isArray([]), 'empty arrays are arrays');\n\t   *\n\t   * @param {Mixed} expression to test for truthiness\n\t   * @param {String} message to display on error\n\t   * @name assert\n\t   * @api public\n\t   */\n\t\n\t  var assert = chai.assert = function (express, errmsg) {\n\t    var test = new Assertion(null, null, chai.assert);\n\t    test.assert(\n\t        express\n\t      , errmsg\n\t      , '[ negation message unavailable ]'\n\t    );\n\t  };\n\t\n\t  /**\n\t   * ### .fail(actual, expected, [message], [operator])\n\t   *\n\t   * Throw a failure. Node.js `assert` module-compatible.\n\t   *\n\t   * @name fail\n\t   * @param {Mixed} actual\n\t   * @param {Mixed} expected\n\t   * @param {String} message\n\t   * @param {String} operator\n\t   * @api public\n\t   */\n\t\n\t  assert.fail = function (actual, expected, message, operator) {\n\t    message = message || 'assert.fail()';\n\t    throw new chai.AssertionError(message, {\n\t        actual: actual\n\t      , expected: expected\n\t      , operator: operator\n\t    }, assert.fail);\n\t  };\n\t\n\t  /**\n\t   * ### .isOk(object, [message])\n\t   *\n\t   * Asserts that `object` is truthy.\n\t   *\n\t   *     assert.isOk('everything', 'everything is ok');\n\t   *     assert.isOk(false, 'this will fail');\n\t   *\n\t   * @name isOk\n\t   * @alias ok\n\t   * @param {Mixed} object to test\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.isOk = function (val, msg) {\n\t    new Assertion(val, msg).is.ok;\n\t  };\n\t\n\t  /**\n\t   * ### .isNotOk(object, [message])\n\t   *\n\t   * Asserts that `object` is falsy.\n\t   *\n\t   *     assert.isNotOk('everything', 'this will fail');\n\t   *     assert.isNotOk(false, 'this will pass');\n\t   *\n\t   * @name isNotOk\n\t   * @alias notOk\n\t   * @param {Mixed} object to test\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.isNotOk = function (val, msg) {\n\t    new Assertion(val, msg).is.not.ok;\n\t  };\n\t\n\t  /**\n\t   * ### .equal(actual, expected, [message])\n\t   *\n\t   * Asserts non-strict equality (`==`) of `actual` and `expected`.\n\t   *\n\t   *     assert.equal(3, '3', '== coerces values to strings');\n\t   *\n\t   * @name equal\n\t   * @param {Mixed} actual\n\t   * @param {Mixed} expected\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.equal = function (act, exp, msg) {\n\t    var test = new Assertion(act, msg, assert.equal);\n\t\n\t    test.assert(\n\t        exp == flag(test, 'object')\n\t      , 'expected #{this} to equal #{exp}'\n\t      , 'expected #{this} to not equal #{act}'\n\t      , exp\n\t      , act\n\t    );\n\t  };\n\t\n\t  /**\n\t   * ### .notEqual(actual, expected, [message])\n\t   *\n\t   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.\n\t   *\n\t   *     assert.notEqual(3, 4, 'these numbers are not equal');\n\t   *\n\t   * @name notEqual\n\t   * @param {Mixed} actual\n\t   * @param {Mixed} expected\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.notEqual = function (act, exp, msg) {\n\t    var test = new Assertion(act, msg, assert.notEqual);\n\t\n\t    test.assert(\n\t        exp != flag(test, 'object')\n\t      , 'expected #{this} to not equal #{exp}'\n\t      , 'expected #{this} to equal #{act}'\n\t      , exp\n\t      , act\n\t    );\n\t  };\n\t\n\t  /**\n\t   * ### .strictEqual(actual, expected, [message])\n\t   *\n\t   * Asserts strict equality (`===`) of `actual` and `expected`.\n\t   *\n\t   *     assert.strictEqual(true, true, 'these booleans are strictly equal');\n\t   *\n\t   * @name strictEqual\n\t   * @param {Mixed} actual\n\t   * @param {Mixed} expected\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.strictEqual = function (act, exp, msg) {\n\t    new Assertion(act, msg).to.equal(exp);\n\t  };\n\t\n\t  /**\n\t   * ### .notStrictEqual(actual, expected, [message])\n\t   *\n\t   * Asserts strict inequality (`!==`) of `actual` and `expected`.\n\t   *\n\t   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');\n\t   *\n\t   * @name notStrictEqual\n\t   * @param {Mixed} actual\n\t   * @param {Mixed} expected\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.notStrictEqual = function (act, exp, msg) {\n\t    new Assertion(act, msg).to.not.equal(exp);\n\t  };\n\t\n\t  /**\n\t   * ### .deepEqual(actual, expected, [message])\n\t   *\n\t   * Asserts that `actual` is deeply equal to `expected`.\n\t   *\n\t   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });\n\t   *\n\t   * @name deepEqual\n\t   * @param {Mixed} actual\n\t   * @param {Mixed} expected\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.deepEqual = function (act, exp, msg) {\n\t    new Assertion(act, msg).to.eql(exp);\n\t  };\n\t\n\t  /**\n\t   * ### .notDeepEqual(actual, expected, [message])\n\t   *\n\t   * Assert that `actual` is not deeply equal to `expected`.\n\t   *\n\t   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });\n\t   *\n\t   * @name notDeepEqual\n\t   * @param {Mixed} actual\n\t   * @param {Mixed} expected\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.notDeepEqual = function (act, exp, msg) {\n\t    new Assertion(act, msg).to.not.eql(exp);\n\t  };\n\t\n\t   /**\n\t   * ### .isAbove(valueToCheck, valueToBeAbove, [message])\n\t   *\n\t   * Asserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`\n\t   *\n\t   *     assert.isAbove(5, 2, '5 is strictly greater than 2');\n\t   *\n\t   * @name isAbove\n\t   * @param {Mixed} valueToCheck\n\t   * @param {Mixed} valueToBeAbove\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.isAbove = function (val, abv, msg) {\n\t    new Assertion(val, msg).to.be.above(abv);\n\t  };\n\t\n\t   /**\n\t   * ### .isAtLeast(valueToCheck, valueToBeAtLeast, [message])\n\t   *\n\t   * Asserts `valueToCheck` is greater than or equal to (>=) `valueToBeAtLeast`\n\t   *\n\t   *     assert.isAtLeast(5, 2, '5 is greater or equal to 2');\n\t   *     assert.isAtLeast(3, 3, '3 is greater or equal to 3');\n\t   *\n\t   * @name isAtLeast\n\t   * @param {Mixed} valueToCheck\n\t   * @param {Mixed} valueToBeAtLeast\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.isAtLeast = function (val, atlst, msg) {\n\t    new Assertion(val, msg).to.be.least(atlst);\n\t  };\n\t\n\t   /**\n\t   * ### .isBelow(valueToCheck, valueToBeBelow, [message])\n\t   *\n\t   * Asserts `valueToCheck` is strictly less than (<) `valueToBeBelow`\n\t   *\n\t   *     assert.isBelow(3, 6, '3 is strictly less than 6');\n\t   *\n\t   * @name isBelow\n\t   * @param {Mixed} valueToCheck\n\t   * @param {Mixed} valueToBeBelow\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.isBelow = function (val, blw, msg) {\n\t    new Assertion(val, msg).to.be.below(blw);\n\t  };\n\t\n\t   /**\n\t   * ### .isAtMost(valueToCheck, valueToBeAtMost, [message])\n\t   *\n\t   * Asserts `valueToCheck` is less than or equal to (<=) `valueToBeAtMost`\n\t   *\n\t   *     assert.isAtMost(3, 6, '3 is less than or equal to 6');\n\t   *     assert.isAtMost(4, 4, '4 is less than or equal to 4');\n\t   *\n\t   * @name isAtMost\n\t   * @param {Mixed} valueToCheck\n\t   * @param {Mixed} valueToBeAtMost\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.isAtMost = function (val, atmst, msg) {\n\t    new Assertion(val, msg).to.be.most(atmst);\n\t  };\n\t\n\t  /**\n\t   * ### .isTrue(value, [message])\n\t   *\n\t   * Asserts that `value` is true.\n\t   *\n\t   *     var teaServed = true;\n\t   *     assert.isTrue(teaServed, 'the tea has been served');\n\t   *\n\t   * @name isTrue\n\t   * @param {Mixed} value\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.isTrue = function (val, msg) {\n\t    new Assertion(val, msg).is['true'];\n\t  };\n\t\n\t  /**\n\t   * ### .isNotTrue(value, [message])\n\t   *\n\t   * Asserts that `value` is not true.\n\t   *\n\t   *     var tea = 'tasty chai';\n\t   *     assert.isNotTrue(tea, 'great, time for tea!');\n\t   *\n\t   * @name isNotTrue\n\t   * @param {Mixed} value\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.isNotTrue = function (val, msg) {\n\t    new Assertion(val, msg).to.not.equal(true);\n\t  };\n\t\n\t  /**\n\t   * ### .isFalse(value, [message])\n\t   *\n\t   * Asserts that `value` is false.\n\t   *\n\t   *     var teaServed = false;\n\t   *     assert.isFalse(teaServed, 'no tea yet? hmm...');\n\t   *\n\t   * @name isFalse\n\t   * @param {Mixed} value\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.isFalse = function (val, msg) {\n\t    new Assertion(val, msg).is['false'];\n\t  };\n\t\n\t  /**\n\t   * ### .isNotFalse(value, [message])\n\t   *\n\t   * Asserts that `value` is not false.\n\t   *\n\t   *     var tea = 'tasty chai';\n\t   *     assert.isNotFalse(tea, 'great, time for tea!');\n\t   *\n\t   * @name isNotFalse\n\t   * @param {Mixed} value\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.isNotFalse = function (val, msg) {\n\t    new Assertion(val, msg).to.not.equal(false);\n\t  };\n\t\n\t  /**\n\t   * ### .isNull(value, [message])\n\t   *\n\t   * Asserts that `value` is null.\n\t   *\n\t   *     assert.isNull(err, 'there was no error');\n\t   *\n\t   * @name isNull\n\t   * @param {Mixed} value\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.isNull = function (val, msg) {\n\t    new Assertion(val, msg).to.equal(null);\n\t  };\n\t\n\t  /**\n\t   * ### .isNotNull(value, [message])\n\t   *\n\t   * Asserts that `value` is not null.\n\t   *\n\t   *     var tea = 'tasty chai';\n\t   *     assert.isNotNull(tea, 'great, time for tea!');\n\t   *\n\t   * @name isNotNull\n\t   * @param {Mixed} value\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.isNotNull = function (val, msg) {\n\t    new Assertion(val, msg).to.not.equal(null);\n\t  };\n\t\n\t  /**\n\t   * ### .isNaN\n\t   * Asserts that value is NaN\n\t   *\n\t   *    assert.isNaN('foo', 'foo is NaN');\n\t   *\n\t   * @name isNaN\n\t   * @param {Mixed} value\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.isNaN = function (val, msg) {\n\t    new Assertion(val, msg).to.be.NaN;\n\t  };\n\t\n\t  /**\n\t   * ### .isNotNaN\n\t   * Asserts that value is not NaN\n\t   *\n\t   *    assert.isNotNaN(4, '4 is not NaN');\n\t   *\n\t   * @name isNotNaN\n\t   * @param {Mixed} value\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t  assert.isNotNaN = function (val, msg) {\n\t    new Assertion(val, msg).not.to.be.NaN;\n\t  };\n\t\n\t  /**\n\t   * ### .isUndefined(value, [message])\n\t   *\n\t   * Asserts that `value` is `undefined`.\n\t   *\n\t   *     var tea;\n\t   *     assert.isUndefined(tea, 'no tea defined');\n\t   *\n\t   * @name isUndefined\n\t   * @param {Mixed} value\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.isUndefined = function (val, msg) {\n\t    new Assertion(val, msg).to.equal(undefined);\n\t  };\n\t\n\t  /**\n\t   * ### .isDefined(value, [message])\n\t   *\n\t   * Asserts that `value` is not `undefined`.\n\t   *\n\t   *     var tea = 'cup of chai';\n\t   *     assert.isDefined(tea, 'tea has been defined');\n\t   *\n\t   * @name isDefined\n\t   * @param {Mixed} value\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.isDefined = function (val, msg) {\n\t    new Assertion(val, msg).to.not.equal(undefined);\n\t  };\n\t\n\t  /**\n\t   * ### .isFunction(value, [message])\n\t   *\n\t   * Asserts that `value` is a function.\n\t   *\n\t   *     function serveTea() { return 'cup of tea'; };\n\t   *     assert.isFunction(serveTea, 'great, we can have tea now');\n\t   *\n\t   * @name isFunction\n\t   * @param {Mixed} value\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.isFunction = function (val, msg) {\n\t    new Assertion(val, msg).to.be.a('function');\n\t  };\n\t\n\t  /**\n\t   * ### .isNotFunction(value, [message])\n\t   *\n\t   * Asserts that `value` is _not_ a function.\n\t   *\n\t   *     var serveTea = [ 'heat', 'pour', 'sip' ];\n\t   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');\n\t   *\n\t   * @name isNotFunction\n\t   * @param {Mixed} value\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.isNotFunction = function (val, msg) {\n\t    new Assertion(val, msg).to.not.be.a('function');\n\t  };\n\t\n\t  /**\n\t   * ### .isObject(value, [message])\n\t   *\n\t   * Asserts that `value` is an object (as revealed by\n\t   * `Object.prototype.toString`).\n\t   *\n\t   *     var selection = { name: 'Chai', serve: 'with spices' };\n\t   *     assert.isObject(selection, 'tea selection is an object');\n\t   *\n\t   * @name isObject\n\t   * @param {Mixed} value\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.isObject = function (val, msg) {\n\t    new Assertion(val, msg).to.be.a('object');\n\t  };\n\t\n\t  /**\n\t   * ### .isNotObject(value, [message])\n\t   *\n\t   * Asserts that `value` is _not_ an object.\n\t   *\n\t   *     var selection = 'chai'\n\t   *     assert.isNotObject(selection, 'tea selection is not an object');\n\t   *     assert.isNotObject(null, 'null is not an object');\n\t   *\n\t   * @name isNotObject\n\t   * @param {Mixed} value\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.isNotObject = function (val, msg) {\n\t    new Assertion(val, msg).to.not.be.a('object');\n\t  };\n\t\n\t  /**\n\t   * ### .isArray(value, [message])\n\t   *\n\t   * Asserts that `value` is an array.\n\t   *\n\t   *     var menu = [ 'green', 'chai', 'oolong' ];\n\t   *     assert.isArray(menu, 'what kind of tea do we want?');\n\t   *\n\t   * @name isArray\n\t   * @param {Mixed} value\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.isArray = function (val, msg) {\n\t    new Assertion(val, msg).to.be.an('array');\n\t  };\n\t\n\t  /**\n\t   * ### .isNotArray(value, [message])\n\t   *\n\t   * Asserts that `value` is _not_ an array.\n\t   *\n\t   *     var menu = 'green|chai|oolong';\n\t   *     assert.isNotArray(menu, 'what kind of tea do we want?');\n\t   *\n\t   * @name isNotArray\n\t   * @param {Mixed} value\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.isNotArray = function (val, msg) {\n\t    new Assertion(val, msg).to.not.be.an('array');\n\t  };\n\t\n\t  /**\n\t   * ### .isString(value, [message])\n\t   *\n\t   * Asserts that `value` is a string.\n\t   *\n\t   *     var teaOrder = 'chai';\n\t   *     assert.isString(teaOrder, 'order placed');\n\t   *\n\t   * @name isString\n\t   * @param {Mixed} value\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.isString = function (val, msg) {\n\t    new Assertion(val, msg).to.be.a('string');\n\t  };\n\t\n\t  /**\n\t   * ### .isNotString(value, [message])\n\t   *\n\t   * Asserts that `value` is _not_ a string.\n\t   *\n\t   *     var teaOrder = 4;\n\t   *     assert.isNotString(teaOrder, 'order placed');\n\t   *\n\t   * @name isNotString\n\t   * @param {Mixed} value\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.isNotString = function (val, msg) {\n\t    new Assertion(val, msg).to.not.be.a('string');\n\t  };\n\t\n\t  /**\n\t   * ### .isNumber(value, [message])\n\t   *\n\t   * Asserts that `value` is a number.\n\t   *\n\t   *     var cups = 2;\n\t   *     assert.isNumber(cups, 'how many cups');\n\t   *\n\t   * @name isNumber\n\t   * @param {Number} value\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.isNumber = function (val, msg) {\n\t    new Assertion(val, msg).to.be.a('number');\n\t  };\n\t\n\t  /**\n\t   * ### .isNotNumber(value, [message])\n\t   *\n\t   * Asserts that `value` is _not_ a number.\n\t   *\n\t   *     var cups = '2 cups please';\n\t   *     assert.isNotNumber(cups, 'how many cups');\n\t   *\n\t   * @name isNotNumber\n\t   * @param {Mixed} value\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.isNotNumber = function (val, msg) {\n\t    new Assertion(val, msg).to.not.be.a('number');\n\t  };\n\t\n\t  /**\n\t   * ### .isBoolean(value, [message])\n\t   *\n\t   * Asserts that `value` is a boolean.\n\t   *\n\t   *     var teaReady = true\n\t   *       , teaServed = false;\n\t   *\n\t   *     assert.isBoolean(teaReady, 'is the tea ready');\n\t   *     assert.isBoolean(teaServed, 'has tea been served');\n\t   *\n\t   * @name isBoolean\n\t   * @param {Mixed} value\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.isBoolean = function (val, msg) {\n\t    new Assertion(val, msg).to.be.a('boolean');\n\t  };\n\t\n\t  /**\n\t   * ### .isNotBoolean(value, [message])\n\t   *\n\t   * Asserts that `value` is _not_ a boolean.\n\t   *\n\t   *     var teaReady = 'yep'\n\t   *       , teaServed = 'nope';\n\t   *\n\t   *     assert.isNotBoolean(teaReady, 'is the tea ready');\n\t   *     assert.isNotBoolean(teaServed, 'has tea been served');\n\t   *\n\t   * @name isNotBoolean\n\t   * @param {Mixed} value\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.isNotBoolean = function (val, msg) {\n\t    new Assertion(val, msg).to.not.be.a('boolean');\n\t  };\n\t\n\t  /**\n\t   * ### .typeOf(value, name, [message])\n\t   *\n\t   * Asserts that `value`'s type is `name`, as determined by\n\t   * `Object.prototype.toString`.\n\t   *\n\t   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');\n\t   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');\n\t   *     assert.typeOf('tea', 'string', 'we have a string');\n\t   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');\n\t   *     assert.typeOf(null, 'null', 'we have a null');\n\t   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');\n\t   *\n\t   * @name typeOf\n\t   * @param {Mixed} value\n\t   * @param {String} name\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.typeOf = function (val, type, msg) {\n\t    new Assertion(val, msg).to.be.a(type);\n\t  };\n\t\n\t  /**\n\t   * ### .notTypeOf(value, name, [message])\n\t   *\n\t   * Asserts that `value`'s type is _not_ `name`, as determined by\n\t   * `Object.prototype.toString`.\n\t   *\n\t   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');\n\t   *\n\t   * @name notTypeOf\n\t   * @param {Mixed} value\n\t   * @param {String} typeof name\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.notTypeOf = function (val, type, msg) {\n\t    new Assertion(val, msg).to.not.be.a(type);\n\t  };\n\t\n\t  /**\n\t   * ### .instanceOf(object, constructor, [message])\n\t   *\n\t   * Asserts that `value` is an instance of `constructor`.\n\t   *\n\t   *     var Tea = function (name) { this.name = name; }\n\t   *       , chai = new Tea('chai');\n\t   *\n\t   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');\n\t   *\n\t   * @name instanceOf\n\t   * @param {Object} object\n\t   * @param {Constructor} constructor\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.instanceOf = function (val, type, msg) {\n\t    new Assertion(val, msg).to.be.instanceOf(type);\n\t  };\n\t\n\t  /**\n\t   * ### .notInstanceOf(object, constructor, [message])\n\t   *\n\t   * Asserts `value` is not an instance of `constructor`.\n\t   *\n\t   *     var Tea = function (name) { this.name = name; }\n\t   *       , chai = new String('chai');\n\t   *\n\t   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');\n\t   *\n\t   * @name notInstanceOf\n\t   * @param {Object} object\n\t   * @param {Constructor} constructor\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.notInstanceOf = function (val, type, msg) {\n\t    new Assertion(val, msg).to.not.be.instanceOf(type);\n\t  };\n\t\n\t  /**\n\t   * ### .include(haystack, needle, [message])\n\t   *\n\t   * Asserts that `haystack` includes `needle`. Works\n\t   * for strings and arrays.\n\t   *\n\t   *     assert.include('foobar', 'bar', 'foobar contains string \"bar\"');\n\t   *     assert.include([ 1, 2, 3 ], 3, 'array contains value');\n\t   *\n\t   * @name include\n\t   * @param {Array|String} haystack\n\t   * @param {Mixed} needle\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.include = function (exp, inc, msg) {\n\t    new Assertion(exp, msg, assert.include).include(inc);\n\t  };\n\t\n\t  /**\n\t   * ### .notInclude(haystack, needle, [message])\n\t   *\n\t   * Asserts that `haystack` does not include `needle`. Works\n\t   * for strings and arrays.\n\t   *\n\t   *     assert.notInclude('foobar', 'baz', 'string not include substring');\n\t   *     assert.notInclude([ 1, 2, 3 ], 4, 'array not include contain value');\n\t   *\n\t   * @name notInclude\n\t   * @param {Array|String} haystack\n\t   * @param {Mixed} needle\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.notInclude = function (exp, inc, msg) {\n\t    new Assertion(exp, msg, assert.notInclude).not.include(inc);\n\t  };\n\t\n\t  /**\n\t   * ### .match(value, regexp, [message])\n\t   *\n\t   * Asserts that `value` matches the regular expression `regexp`.\n\t   *\n\t   *     assert.match('foobar', /^foo/, 'regexp matches');\n\t   *\n\t   * @name match\n\t   * @param {Mixed} value\n\t   * @param {RegExp} regexp\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.match = function (exp, re, msg) {\n\t    new Assertion(exp, msg).to.match(re);\n\t  };\n\t\n\t  /**\n\t   * ### .notMatch(value, regexp, [message])\n\t   *\n\t   * Asserts that `value` does not match the regular expression `regexp`.\n\t   *\n\t   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');\n\t   *\n\t   * @name notMatch\n\t   * @param {Mixed} value\n\t   * @param {RegExp} regexp\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.notMatch = function (exp, re, msg) {\n\t    new Assertion(exp, msg).to.not.match(re);\n\t  };\n\t\n\t  /**\n\t   * ### .property(object, property, [message])\n\t   *\n\t   * Asserts that `object` has a property named by `property`.\n\t   *\n\t   *     assert.property({ tea: { green: 'matcha' }}, 'tea');\n\t   *\n\t   * @name property\n\t   * @param {Object} object\n\t   * @param {String} property\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.property = function (obj, prop, msg) {\n\t    new Assertion(obj, msg).to.have.property(prop);\n\t  };\n\t\n\t  /**\n\t   * ### .notProperty(object, property, [message])\n\t   *\n\t   * Asserts that `object` does _not_ have a property named by `property`.\n\t   *\n\t   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');\n\t   *\n\t   * @name notProperty\n\t   * @param {Object} object\n\t   * @param {String} property\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.notProperty = function (obj, prop, msg) {\n\t    new Assertion(obj, msg).to.not.have.property(prop);\n\t  };\n\t\n\t  /**\n\t   * ### .deepProperty(object, property, [message])\n\t   *\n\t   * Asserts that `object` has a property named by `property`, which can be a\n\t   * string using dot- and bracket-notation for deep reference.\n\t   *\n\t   *     assert.deepProperty({ tea: { green: 'matcha' }}, 'tea.green');\n\t   *\n\t   * @name deepProperty\n\t   * @param {Object} object\n\t   * @param {String} property\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.deepProperty = function (obj, prop, msg) {\n\t    new Assertion(obj, msg).to.have.deep.property(prop);\n\t  };\n\t\n\t  /**\n\t   * ### .notDeepProperty(object, property, [message])\n\t   *\n\t   * Asserts that `object` does _not_ have a property named by `property`, which\n\t   * can be a string using dot- and bracket-notation for deep reference.\n\t   *\n\t   *     assert.notDeepProperty({ tea: { green: 'matcha' }}, 'tea.oolong');\n\t   *\n\t   * @name notDeepProperty\n\t   * @param {Object} object\n\t   * @param {String} property\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.notDeepProperty = function (obj, prop, msg) {\n\t    new Assertion(obj, msg).to.not.have.deep.property(prop);\n\t  };\n\t\n\t  /**\n\t   * ### .propertyVal(object, property, value, [message])\n\t   *\n\t   * Asserts that `object` has a property named by `property` with value given\n\t   * by `value`.\n\t   *\n\t   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');\n\t   *\n\t   * @name propertyVal\n\t   * @param {Object} object\n\t   * @param {String} property\n\t   * @param {Mixed} value\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.propertyVal = function (obj, prop, val, msg) {\n\t    new Assertion(obj, msg).to.have.property(prop, val);\n\t  };\n\t\n\t  /**\n\t   * ### .propertyNotVal(object, property, value, [message])\n\t   *\n\t   * Asserts that `object` has a property named by `property`, but with a value\n\t   * different from that given by `value`.\n\t   *\n\t   *     assert.propertyNotVal({ tea: 'is good' }, 'tea', 'is bad');\n\t   *\n\t   * @name propertyNotVal\n\t   * @param {Object} object\n\t   * @param {String} property\n\t   * @param {Mixed} value\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.propertyNotVal = function (obj, prop, val, msg) {\n\t    new Assertion(obj, msg).to.not.have.property(prop, val);\n\t  };\n\t\n\t  /**\n\t   * ### .deepPropertyVal(object, property, value, [message])\n\t   *\n\t   * Asserts that `object` has a property named by `property` with value given\n\t   * by `value`. `property` can use dot- and bracket-notation for deep\n\t   * reference.\n\t   *\n\t   *     assert.deepPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');\n\t   *\n\t   * @name deepPropertyVal\n\t   * @param {Object} object\n\t   * @param {String} property\n\t   * @param {Mixed} value\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.deepPropertyVal = function (obj, prop, val, msg) {\n\t    new Assertion(obj, msg).to.have.deep.property(prop, val);\n\t  };\n\t\n\t  /**\n\t   * ### .deepPropertyNotVal(object, property, value, [message])\n\t   *\n\t   * Asserts that `object` has a property named by `property`, but with a value\n\t   * different from that given by `value`. `property` can use dot- and\n\t   * bracket-notation for deep reference.\n\t   *\n\t   *     assert.deepPropertyNotVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');\n\t   *\n\t   * @name deepPropertyNotVal\n\t   * @param {Object} object\n\t   * @param {String} property\n\t   * @param {Mixed} value\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.deepPropertyNotVal = function (obj, prop, val, msg) {\n\t    new Assertion(obj, msg).to.not.have.deep.property(prop, val);\n\t  };\n\t\n\t  /**\n\t   * ### .lengthOf(object, length, [message])\n\t   *\n\t   * Asserts that `object` has a `length` property with the expected value.\n\t   *\n\t   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');\n\t   *     assert.lengthOf('foobar', 6, 'string has length of 6');\n\t   *\n\t   * @name lengthOf\n\t   * @param {Mixed} object\n\t   * @param {Number} length\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.lengthOf = function (exp, len, msg) {\n\t    new Assertion(exp, msg).to.have.length(len);\n\t  };\n\t\n\t  /**\n\t   * ### .throws(function, [constructor/string/regexp], [string/regexp], [message])\n\t   *\n\t   * Asserts that `function` will throw an error that is an instance of\n\t   * `constructor`, or alternately that it will throw an error with message\n\t   * matching `regexp`.\n\t   *\n\t   *     assert.throws(fn, 'function throws a reference error');\n\t   *     assert.throws(fn, /function throws a reference error/);\n\t   *     assert.throws(fn, ReferenceError);\n\t   *     assert.throws(fn, ReferenceError, 'function throws a reference error');\n\t   *     assert.throws(fn, ReferenceError, /function throws a reference error/);\n\t   *\n\t   * @name throws\n\t   * @alias throw\n\t   * @alias Throw\n\t   * @param {Function} function\n\t   * @param {ErrorConstructor} constructor\n\t   * @param {RegExp} regexp\n\t   * @param {String} message\n\t   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n\t   * @api public\n\t   */\n\t\n\t  assert.throws = function (fn, errt, errs, msg) {\n\t    if ('string' === typeof errt || errt instanceof RegExp) {\n\t      errs = errt;\n\t      errt = null;\n\t    }\n\t\n\t    var assertErr = new Assertion(fn, msg).to.throw(errt, errs);\n\t    return flag(assertErr, 'object');\n\t  };\n\t\n\t  /**\n\t   * ### .doesNotThrow(function, [constructor/regexp], [message])\n\t   *\n\t   * Asserts that `function` will _not_ throw an error that is an instance of\n\t   * `constructor`, or alternately that it will not throw an error with message\n\t   * matching `regexp`.\n\t   *\n\t   *     assert.doesNotThrow(fn, Error, 'function does not throw');\n\t   *\n\t   * @name doesNotThrow\n\t   * @param {Function} function\n\t   * @param {ErrorConstructor} constructor\n\t   * @param {RegExp} regexp\n\t   * @param {String} message\n\t   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n\t   * @api public\n\t   */\n\t\n\t  assert.doesNotThrow = function (fn, type, msg) {\n\t    if ('string' === typeof type) {\n\t      msg = type;\n\t      type = null;\n\t    }\n\t\n\t    new Assertion(fn, msg).to.not.Throw(type);\n\t  };\n\t\n\t  /**\n\t   * ### .operator(val1, operator, val2, [message])\n\t   *\n\t   * Compares two values using `operator`.\n\t   *\n\t   *     assert.operator(1, '<', 2, 'everything is ok');\n\t   *     assert.operator(1, '>', 2, 'this will fail');\n\t   *\n\t   * @name operator\n\t   * @param {Mixed} val1\n\t   * @param {String} operator\n\t   * @param {Mixed} val2\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.operator = function (val, operator, val2, msg) {\n\t    var ok;\n\t    switch(operator) {\n\t      case '==':\n\t        ok = val == val2;\n\t        break;\n\t      case '===':\n\t        ok = val === val2;\n\t        break;\n\t      case '>':\n\t        ok = val > val2;\n\t        break;\n\t      case '>=':\n\t        ok = val >= val2;\n\t        break;\n\t      case '<':\n\t        ok = val < val2;\n\t        break;\n\t      case '<=':\n\t        ok = val <= val2;\n\t        break;\n\t      case '!=':\n\t        ok = val != val2;\n\t        break;\n\t      case '!==':\n\t        ok = val !== val2;\n\t        break;\n\t      default:\n\t        throw new Error('Invalid operator \"' + operator + '\"');\n\t    }\n\t    var test = new Assertion(ok, msg);\n\t    test.assert(\n\t        true === flag(test, 'object')\n\t      , 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2)\n\t      , 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2) );\n\t  };\n\t\n\t  /**\n\t   * ### .closeTo(actual, expected, delta, [message])\n\t   *\n\t   * Asserts that the target is equal `expected`, to within a +/- `delta` range.\n\t   *\n\t   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');\n\t   *\n\t   * @name closeTo\n\t   * @param {Number} actual\n\t   * @param {Number} expected\n\t   * @param {Number} delta\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.closeTo = function (act, exp, delta, msg) {\n\t    new Assertion(act, msg).to.be.closeTo(exp, delta);\n\t  };\n\t\n\t  /**\n\t   * ### .approximately(actual, expected, delta, [message])\n\t   *\n\t   * Asserts that the target is equal `expected`, to within a +/- `delta` range.\n\t   *\n\t   *     assert.approximately(1.5, 1, 0.5, 'numbers are close');\n\t   *\n\t   * @name approximately\n\t   * @param {Number} actual\n\t   * @param {Number} expected\n\t   * @param {Number} delta\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.approximately = function (act, exp, delta, msg) {\n\t    new Assertion(act, msg).to.be.approximately(exp, delta);\n\t  };\n\t\n\t  /**\n\t   * ### .sameMembers(set1, set2, [message])\n\t   *\n\t   * Asserts that `set1` and `set2` have the same members.\n\t   * Order is not taken into account.\n\t   *\n\t   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');\n\t   *\n\t   * @name sameMembers\n\t   * @param {Array} set1\n\t   * @param {Array} set2\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.sameMembers = function (set1, set2, msg) {\n\t    new Assertion(set1, msg).to.have.same.members(set2);\n\t  }\n\t\n\t  /**\n\t   * ### .sameDeepMembers(set1, set2, [message])\n\t   *\n\t   * Asserts that `set1` and `set2` have the same members - using a deep equality checking.\n\t   * Order is not taken into account.\n\t   *\n\t   *     assert.sameDeepMembers([ {b: 3}, {a: 2}, {c: 5} ], [ {c: 5}, {b: 3}, {a: 2} ], 'same deep members');\n\t   *\n\t   * @name sameDeepMembers\n\t   * @param {Array} set1\n\t   * @param {Array} set2\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.sameDeepMembers = function (set1, set2, msg) {\n\t    new Assertion(set1, msg).to.have.same.deep.members(set2);\n\t  }\n\t\n\t  /**\n\t   * ### .includeMembers(superset, subset, [message])\n\t   *\n\t   * Asserts that `subset` is included in `superset`.\n\t   * Order is not taken into account.\n\t   *\n\t   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1 ], 'include members');\n\t   *\n\t   * @name includeMembers\n\t   * @param {Array} superset\n\t   * @param {Array} subset\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.includeMembers = function (superset, subset, msg) {\n\t    new Assertion(superset, msg).to.include.members(subset);\n\t  }\n\t\n\t  /**\n\t   * ### .oneOf(inList, list, [message])\n\t   *\n\t   * Asserts that non-object, non-array value `inList` appears in the flat array `list`.\n\t   *\n\t   *     assert.oneOf(1, [ 2, 1 ], 'Not found in list');\n\t   *\n\t   * @name oneOf\n\t   * @param {*} inList\n\t   * @param {Array<*>} list\n\t   * @param {String} message\n\t   * @api public\n\t   */\n\t\n\t  assert.oneOf = function (inList, list, msg) {\n\t    new Assertion(inList, msg).to.be.oneOf(list);\n\t  }\n\t\n\t   /**\n\t   * ### .changes(function, object, property)\n\t   *\n\t   * Asserts that a function changes the value of a property\n\t   *\n\t   *     var obj = { val: 10 };\n\t   *     var fn = function() { obj.val = 22 };\n\t   *     assert.changes(fn, obj, 'val');\n\t   *\n\t   * @name changes\n\t   * @param {Function} modifier function\n\t   * @param {Object} object\n\t   * @param {String} property name\n\t   * @param {String} message _optional_\n\t   * @api public\n\t   */\n\t\n\t  assert.changes = function (fn, obj, prop) {\n\t    new Assertion(fn).to.change(obj, prop);\n\t  }\n\t\n\t   /**\n\t   * ### .doesNotChange(function, object, property)\n\t   *\n\t   * Asserts that a function does not changes the value of a property\n\t   *\n\t   *     var obj = { val: 10 };\n\t   *     var fn = function() { console.log('foo'); };\n\t   *     assert.doesNotChange(fn, obj, 'val');\n\t   *\n\t   * @name doesNotChange\n\t   * @param {Function} modifier function\n\t   * @param {Object} object\n\t   * @param {String} property name\n\t   * @param {String} message _optional_\n\t   * @api public\n\t   */\n\t\n\t  assert.doesNotChange = function (fn, obj, prop) {\n\t    new Assertion(fn).to.not.change(obj, prop);\n\t  }\n\t\n\t   /**\n\t   * ### .increases(function, object, property)\n\t   *\n\t   * Asserts that a function increases an object property\n\t   *\n\t   *     var obj = { val: 10 };\n\t   *     var fn = function() { obj.val = 13 };\n\t   *     assert.increases(fn, obj, 'val');\n\t   *\n\t   * @name increases\n\t   * @param {Function} modifier function\n\t   * @param {Object} object\n\t   * @param {String} property name\n\t   * @param {String} message _optional_\n\t   * @api public\n\t   */\n\t\n\t  assert.increases = function (fn, obj, prop) {\n\t    new Assertion(fn).to.increase(obj, prop);\n\t  }\n\t\n\t   /**\n\t   * ### .doesNotIncrease(function, object, property)\n\t   *\n\t   * Asserts that a function does not increase object property\n\t   *\n\t   *     var obj = { val: 10 };\n\t   *     var fn = function() { obj.val = 8 };\n\t   *     assert.doesNotIncrease(fn, obj, 'val');\n\t   *\n\t   * @name doesNotIncrease\n\t   * @param {Function} modifier function\n\t   * @param {Object} object\n\t   * @param {String} property name\n\t   * @param {String} message _optional_\n\t   * @api public\n\t   */\n\t\n\t  assert.doesNotIncrease = function (fn, obj, prop) {\n\t    new Assertion(fn).to.not.increase(obj, prop);\n\t  }\n\t\n\t   /**\n\t   * ### .decreases(function, object, property)\n\t   *\n\t   * Asserts that a function decreases an object property\n\t   *\n\t   *     var obj = { val: 10 };\n\t   *     var fn = function() { obj.val = 5 };\n\t   *     assert.decreases(fn, obj, 'val');\n\t   *\n\t   * @name decreases\n\t   * @param {Function} modifier function\n\t   * @param {Object} object\n\t   * @param {String} property name\n\t   * @param {String} message _optional_\n\t   * @api public\n\t   */\n\t\n\t  assert.decreases = function (fn, obj, prop) {\n\t    new Assertion(fn).to.decrease(obj, prop);\n\t  }\n\t\n\t   /**\n\t   * ### .doesNotDecrease(function, object, property)\n\t   *\n\t   * Asserts that a function does not decreases an object property\n\t   *\n\t   *     var obj = { val: 10 };\n\t   *     var fn = function() { obj.val = 15 };\n\t   *     assert.doesNotDecrease(fn, obj, 'val');\n\t   *\n\t   * @name doesNotDecrease\n\t   * @param {Function} modifier function\n\t   * @param {Object} object\n\t   * @param {String} property name\n\t   * @param {String} message _optional_\n\t   * @api public\n\t   */\n\t\n\t  assert.doesNotDecrease = function (fn, obj, prop) {\n\t    new Assertion(fn).to.not.decrease(obj, prop);\n\t  }\n\t\n\t  /*!\n\t   * ### .ifError(object)\n\t   *\n\t   * Asserts if value is not a false value, and throws if it is a true value.\n\t   * This is added to allow for chai to be a drop-in replacement for Node's\n\t   * assert class.\n\t   *\n\t   *     var err = new Error('I am a custom error');\n\t   *     assert.ifError(err); // Rethrows err!\n\t   *\n\t   * @name ifError\n\t   * @param {Object} object\n\t   * @api public\n\t   */\n\t\n\t  assert.ifError = function (val) {\n\t    if (val) {\n\t      throw(val);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * ### .isExtensible(object)\n\t   *\n\t   * Asserts that `object` is extensible (can have new properties added to it).\n\t   *\n\t   *     assert.isExtensible({});\n\t   *\n\t   * @name isExtensible\n\t   * @alias extensible\n\t   * @param {Object} object\n\t   * @param {String} message _optional_\n\t   * @api public\n\t   */\n\t\n\t  assert.isExtensible = function (obj, msg) {\n\t    new Assertion(obj, msg).to.be.extensible;\n\t  };\n\t\n\t  /**\n\t   * ### .isNotExtensible(object)\n\t   *\n\t   * Asserts that `object` is _not_ extensible.\n\t   *\n\t   *     var nonExtensibleObject = Object.preventExtensions({});\n\t   *     var sealedObject = Object.seal({});\n\t   *     var frozenObject = Object.freese({});\n\t   *\n\t   *     assert.isNotExtensible(nonExtensibleObject);\n\t   *     assert.isNotExtensible(sealedObject);\n\t   *     assert.isNotExtensible(frozenObject);\n\t   *\n\t   * @name isNotExtensible\n\t   * @alias notExtensible\n\t   * @param {Object} object\n\t   * @param {String} message _optional_\n\t   * @api public\n\t   */\n\t\n\t  assert.isNotExtensible = function (obj, msg) {\n\t    new Assertion(obj, msg).to.not.be.extensible;\n\t  };\n\t\n\t  /**\n\t   * ### .isSealed(object)\n\t   *\n\t   * Asserts that `object` is sealed (cannot have new properties added to it\n\t   * and its existing properties cannot be removed).\n\t   *\n\t   *     var sealedObject = Object.seal({});\n\t   *     var frozenObject = Object.seal({});\n\t   *\n\t   *     assert.isSealed(sealedObject);\n\t   *     assert.isSealed(frozenObject);\n\t   *\n\t   * @name isSealed\n\t   * @alias sealed\n\t   * @param {Object} object\n\t   * @param {String} message _optional_\n\t   * @api public\n\t   */\n\t\n\t  assert.isSealed = function (obj, msg) {\n\t    new Assertion(obj, msg).to.be.sealed;\n\t  };\n\t\n\t  /**\n\t   * ### .isNotSealed(object)\n\t   *\n\t   * Asserts that `object` is _not_ sealed.\n\t   *\n\t   *     assert.isNotSealed({});\n\t   *\n\t   * @name isNotSealed\n\t   * @alias notSealed\n\t   * @param {Object} object\n\t   * @param {String} message _optional_\n\t   * @api public\n\t   */\n\t\n\t  assert.isNotSealed = function (obj, msg) {\n\t    new Assertion(obj, msg).to.not.be.sealed;\n\t  };\n\t\n\t  /**\n\t   * ### .isFrozen(object)\n\t   *\n\t   * Asserts that `object` is frozen (cannot have new properties added to it\n\t   * and its existing properties cannot be modified).\n\t   *\n\t   *     var frozenObject = Object.freeze({});\n\t   *     assert.frozen(frozenObject);\n\t   *\n\t   * @name isFrozen\n\t   * @alias frozen\n\t   * @param {Object} object\n\t   * @param {String} message _optional_\n\t   * @api public\n\t   */\n\t\n\t  assert.isFrozen = function (obj, msg) {\n\t    new Assertion(obj, msg).to.be.frozen;\n\t  };\n\t\n\t  /**\n\t   * ### .isNotFrozen(object)\n\t   *\n\t   * Asserts that `object` is _not_ frozen.\n\t   *\n\t   *     assert.isNotFrozen({});\n\t   *\n\t   * @name isNotFrozen\n\t   * @alias notFrozen\n\t   * @param {Object} object\n\t   * @param {String} message _optional_\n\t   * @api public\n\t   */\n\t\n\t  assert.isNotFrozen = function (obj, msg) {\n\t    new Assertion(obj, msg).to.not.be.frozen;\n\t  };\n\t\n\t  /*!\n\t   * Aliases.\n\t   */\n\t\n\t  (function alias(name, as){\n\t    assert[as] = assert[name];\n\t    return alias;\n\t  })\n\t  ('isOk', 'ok')\n\t  ('isNotOk', 'notOk')\n\t  ('throws', 'throw')\n\t  ('throws', 'Throw')\n\t  ('isExtensible', 'extensible')\n\t  ('isNotExtensible', 'notExtensible')\n\t  ('isSealed', 'sealed')\n\t  ('isNotSealed', 'notSealed')\n\t  ('isFrozen', 'frozen')\n\t  ('isNotFrozen', 'notFrozen');\n\t};\n\n\n/***/ },\n/* 51 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.PLAYER_ID = exports.APP_ID = undefined;\n\t\n\tvar _vars = __webpack_require__(4);\n\t\n\tvar _utils = __webpack_require__(5);\n\t\n\tvar APP_ID = exports.APP_ID = (0, _utils.isDev)() ? '33b3562a-d33b-42ee-88bc-1436e780311f' : '7b6053e0-9911-4003-a0a4-a33e417ad663';\n\tvar PLAYER_ID = exports.PLAYER_ID = (0, _utils.isDev)() ? 'b3481557-521d-4d01-be72-acf2c3f46eff' : '15b23511-e0cf-489a-8682-7cf129cb4585';\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {\n\n\tmodule.exports = __webpack_require__(__webpack_module_template_argument_0__);\n\n\n/***/ }\n/******/ ])));\n\n\n/** WEBPACK FOOTER **\n ** test.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap ecf7139b4982c612b5f0\n **/","require('./api.js');\n\n\n/** WEBPACK FOOTER **\n ** ./test/entry.js\n **/","/*** IMPORTS FROM imports-loader ***/\n(function() {\n\n(function() {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var list = this.map[name]\n    if (!list) {\n      list = []\n      this.map[name] = list\n    }\n    list.push(value)\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    var values = this.map[normalizeName(name)]\n    return values ? values[0] : null\n  }\n\n  Headers.prototype.getAll = function(name) {\n    return this.map[normalizeName(name)] || []\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = [normalizeValue(value)]\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    Object.getOwnPropertyNames(this.map).forEach(function(name) {\n      this.map[name].forEach(function(value) {\n        callback.call(thisArg, value, name, this)\n      }, this)\n    }, this)\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    reader.readAsArrayBuffer(blob)\n    return fileReaderReady(reader)\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    reader.readAsText(blob)\n    return fileReaderReady(reader)\n  }\n\n  var support = {\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob();\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (!body) {\n        this._bodyText = ''\n      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {\n        // Only support ArrayBuffers for POST method.\n        // Receiving ArrayBuffers happens via Blobs, instead.\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        return this.blob().then(readBlobAsArrayBuffer)\n      }\n\n      this.text = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return readBlobAsText(this._bodyBlob)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as text')\n        } else {\n          return Promise.resolve(this._bodyText)\n        }\n      }\n    } else {\n      this.text = function() {\n        var rejected = consumed(this)\n        return rejected ? rejected : Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n    if (Request.prototype.isPrototypeOf(input)) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = input\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this)\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function headers(xhr) {\n    var head = new Headers()\n    var pairs = xhr.getAllResponseHeaders().trim().split('\\n')\n    pairs.forEach(function(header) {\n      var split = header.trim().split(':')\n      var key = split.shift().trim()\n      var value = split.join(':').trim()\n      head.append(key, value)\n    })\n    return head\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this._initBody(bodyInit)\n    this.type = 'default'\n    this.status = options.status\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = options.statusText\n    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)\n    this.url = options.url || ''\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers;\n  self.Request = Request;\n  self.Response = Response;\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request\n      if (Request.prototype.isPrototypeOf(input) && !init) {\n        request = input\n      } else {\n        request = new Request(input, init)\n      }\n\n      var xhr = new XMLHttpRequest()\n\n      function responseURL() {\n        if ('responseURL' in xhr) {\n          return xhr.responseURL\n        }\n\n        // Avoid security warnings on getResponseHeader when not allowed by CORS\n        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n          return xhr.getResponseHeader('X-Request-URL')\n        }\n\n        return;\n      }\n\n      xhr.onload = function() {\n        var status = (xhr.status === 1223) ? 204 : xhr.status\n        if (status < 100 || status > 599) {\n          reject(new TypeError('Network request failed'))\n          return\n        }\n        var options = {\n          status: status,\n          statusText: xhr.statusText,\n          headers: headers(xhr),\n          url: responseURL()\n        }\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})();\n\n\n/*** EXPORTS FROM exports-loader ***/\nmodule.exports = global.fetch\n}.call(global));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/imports-loader?this=>global!./~/exports-loader?global.fetch!./~/whatwg-fetch/fetch.js\n ** module id = 3\n ** module chunks = 0 1\n **/","import { isDev } from './utils.js';\n\nexport const DEV_HOST = 'https://192.168.1.206:3000';\nexport const PROD_HOST = 'https://onesignal.com';\nexport const HOST_URL = (isDev() ? DEV_HOST : PROD_HOST) + '/api/v1/';\n\n\n/** WEBPACK FOOTER **\n ** ./src/vars.js\n **/","export function getHumanizedTimeDuration(timeDurationInMilliseconds) {\n  function addPluralSuffix(number) {\n    return (number > 1) ? 's' : '';\n  }\n  var duration = Math.floor(timeDurationInMilliseconds / 1000);\n\n  var years = Math.floor(duration / 31536000);\n  if (years)\n    return years + ' year' + addPluralSuffix(years);\n\n  var days = Math.floor((duration %= 31536000) / 86400);\n  if (days)\n    return days + ' day' + addPluralSuffix(days);\n\n  var hours = Math.floor((duration %= 86400) / 3600);\n  if (hours)\n    return hours + ' hour' + addPluralSuffix(hours);\n\n  var minutes = Math.floor((duration %= 3600) / 60);\n  if (minutes)\n    return minutes + ' minute' + addPluralSuffix(minutes);\n\n  var seconds = duration % 60;\n  if (seconds)\n    return seconds + ' second' + addPluralSuffix(seconds);\n\n  return 'just now';\n}\n\nexport function isServiceWorkerContext() {\n  return typeof window === \"undefined\";\n}\n\nexport function isDev() {\n  return __DEV__;\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils.js\n **/","import { HOST_URL } from './vars.js'\nimport log from 'loglevel';\n\nexport function apiCall(action, method, data) {\n  let headers = new Headers();\n  headers.append('Content-Type', 'application/json;charset=UTF-8');\n\n  let contents = {\n    method: method || 'NO_METHOD_SPECIFIED',\n    headers: headers,\n    cache: 'no-cache',\n    body: JSON.stringify(data)\n  };\n\n  return new Promise((resolve, reject) => {\n    fetch(HOST_URL + action, contents)\n      .then(function status(response) {\n        if (response.status >= 200 && response.status < 300)\n          resolve(response.json());\n        else\n          reject(new Error(response.statusText));\n      })\n      .catch(function (e) {\n        reject(e);\n      });\n  });\n}\n\nexport function sendNotification(appId, playerIds, titles, contents) {\n  var params = {\n    'app_id': appId,\n    'headings': titles,\n    'contents': contents,\n    'include_player_ids': playerIds,\n    'isAnyWeb': true,\n    'url': 'javascript:void(0);'\n  };\n  return apiCall('notifications', 'POST', params);\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/api.js\n **/","/*\r\n* loglevel - https://github.com/pimterry/loglevel\r\n*\r\n* Copyright (c) 2013 Tim Perry\r\n* Licensed under the MIT license.\r\n*/\r\n(function (root, definition) {\r\n    \"use strict\";\r\n    if (typeof module === 'object' && module.exports && typeof require === 'function') {\r\n        module.exports = definition();\r\n    } else if (typeof define === 'function' && typeof define.amd === 'object') {\r\n        define(definition);\r\n    } else {\r\n        root.log = definition();\r\n    }\r\n}(this, function () {\r\n    \"use strict\";\r\n    var noop = function() {};\r\n    var undefinedType = \"undefined\";\r\n\r\n    function realMethod(methodName) {\r\n        if (typeof console === undefinedType) {\r\n            return false; // We can't build a real method without a console to log to\r\n        } else if (console[methodName] !== undefined) {\r\n            return bindMethod(console, methodName);\r\n        } else if (console.log !== undefined) {\r\n            return bindMethod(console, 'log');\r\n        } else {\r\n            return noop;\r\n        }\r\n    }\r\n\r\n    function bindMethod(obj, methodName) {\r\n        var method = obj[methodName];\r\n        if (typeof method.bind === 'function') {\r\n            return method.bind(obj);\r\n        } else {\r\n            try {\r\n                return Function.prototype.bind.call(method, obj);\r\n            } catch (e) {\r\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\r\n                return function() {\r\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    // these private functions always need `this` to be set properly\r\n\r\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\r\n        return function () {\r\n            if (typeof console !== undefinedType) {\r\n                replaceLoggingMethods.call(this, level, loggerName);\r\n                this[methodName].apply(this, arguments);\r\n            }\r\n        };\r\n    }\r\n\r\n    function replaceLoggingMethods(level, loggerName) {\r\n        /*jshint validthis:true */\r\n        for (var i = 0; i < logMethods.length; i++) {\r\n            var methodName = logMethods[i];\r\n            this[methodName] = (i < level) ?\r\n                noop :\r\n                this.methodFactory(methodName, level, loggerName);\r\n        }\r\n    }\r\n\r\n    function defaultMethodFactory(methodName, level, loggerName) {\r\n        /*jshint validthis:true */\r\n        return realMethod(methodName) ||\r\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\r\n    }\r\n\r\n    var logMethods = [\r\n        \"trace\",\r\n        \"debug\",\r\n        \"info\",\r\n        \"warn\",\r\n        \"error\"\r\n    ];\r\n\r\n    function Logger(name, defaultLevel, factory) {\r\n      var self = this;\r\n      var currentLevel;\r\n      var storageKey = \"loglevel\";\r\n      if (name) {\r\n        storageKey += \":\" + name;\r\n      }\r\n\r\n      function persistLevelIfPossible(levelNum) {\r\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\r\n\r\n          // Use localStorage if available\r\n          try {\r\n              window.localStorage[storageKey] = levelName;\r\n              return;\r\n          } catch (ignore) {}\r\n\r\n          // Use session cookie as fallback\r\n          try {\r\n              window.document.cookie =\r\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\r\n          } catch (ignore) {}\r\n      }\r\n\r\n      function getPersistedLevel() {\r\n          var storedLevel;\r\n\r\n          try {\r\n              storedLevel = window.localStorage[storageKey];\r\n          } catch (ignore) {}\r\n\r\n          if (typeof storedLevel === undefinedType) {\r\n              try {\r\n                  var cookie = window.document.cookie;\r\n                  var location = cookie.indexOf(\r\n                      encodeURIComponent(storageKey) + \"=\");\r\n                  if (location) {\r\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\r\n                  }\r\n              } catch (ignore) {}\r\n          }\r\n\r\n          // If the stored level is not valid, treat it as if nothing was stored.\r\n          if (self.levels[storedLevel] === undefined) {\r\n              storedLevel = undefined;\r\n          }\r\n\r\n          return storedLevel;\r\n      }\r\n\r\n      /*\r\n       *\r\n       * Public API\r\n       *\r\n       */\r\n\r\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\r\n          \"ERROR\": 4, \"SILENT\": 5};\r\n\r\n      self.methodFactory = factory || defaultMethodFactory;\r\n\r\n      self.getLevel = function () {\r\n          return currentLevel;\r\n      };\r\n\r\n      self.setLevel = function (level, persist) {\r\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\r\n              level = self.levels[level.toUpperCase()];\r\n          }\r\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\r\n              currentLevel = level;\r\n              if (persist !== false) {  // defaults to true\r\n                  persistLevelIfPossible(level);\r\n              }\r\n              replaceLoggingMethods.call(self, level, name);\r\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\r\n                  return \"No console available for logging\";\r\n              }\r\n          } else {\r\n              throw \"log.setLevel() called with invalid level: \" + level;\r\n          }\r\n      };\r\n\r\n      self.setDefaultLevel = function (level) {\r\n          if (!getPersistedLevel()) {\r\n              self.setLevel(level, false);\r\n          }\r\n      };\r\n\r\n      self.enableAll = function(persist) {\r\n          self.setLevel(self.levels.TRACE, persist);\r\n      };\r\n\r\n      self.disableAll = function(persist) {\r\n          self.setLevel(self.levels.SILENT, persist);\r\n      };\r\n\r\n      // Initialize with the right level\r\n      var initialLevel = getPersistedLevel();\r\n      if (initialLevel == null) {\r\n          initialLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\r\n      }\r\n      self.setLevel(initialLevel, false);\r\n    }\r\n\r\n    /*\r\n     *\r\n     * Package-level API\r\n     *\r\n     */\r\n\r\n    var defaultLogger = new Logger();\r\n\r\n    var _loggersByName = {};\r\n    defaultLogger.getLogger = function getLogger(name) {\r\n        if (typeof name !== \"string\" || name === \"\") {\r\n          throw new TypeError(\"You must supply a name when creating a logger.\");\r\n        }\r\n\r\n        var logger = _loggersByName[name];\r\n        if (!logger) {\r\n          logger = _loggersByName[name] = new Logger(\r\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\r\n        }\r\n        return logger;\r\n    };\r\n\r\n    // Grab the current global log variable in case of overwrite\r\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\r\n    defaultLogger.noConflict = function() {\r\n        if (typeof window !== undefinedType &&\r\n               window.log === defaultLogger) {\r\n            window.log = _log;\r\n        }\r\n\r\n        return defaultLogger;\r\n    };\r\n\r\n    return defaultLogger;\r\n}));\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/loglevel/lib/loglevel.js\n ** module id = 7\n ** module chunks = 0 1\n **/","import expect from 'chai';\nimport { apiCall } from '../src/api.js';\nimport {APP_ID, PLAYER_ID} from './vars.js';\n\ndescribe('api.js', function() {\n  it('should fail an invalid create notification', function () {\n    return apiCall('notifications', 'POST', null).should.eventually.be.rejectedWith('Error: Bad Request');\n  });\n\n  it('should send a valid create notification', function () {\n    // App is on local server\n    var params = {\n      'app_id': APP_ID,\n      'contents': {'en': 'Web SDK unit test.'},\n      'include_player_ids': [PLAYER_ID]\n    };\n    return apiCall('notifications', 'POST', params).should.eventually.be.fulfilled;\n  });\n});\n\n\n/** WEBPACK FOOTER **\n ** ./test/api.js\n **/","module.exports = require('./lib/chai');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/index.js\n ** module id = 11\n ** module chunks = 1\n **/","/*!\n * chai\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar used = []\n  , exports = module.exports = {};\n\n/*!\n * Chai version\n */\n\nexports.version = '3.4.1';\n\n/*!\n * Assertion Error\n */\n\nexports.AssertionError = require('assertion-error');\n\n/*!\n * Utils for plugins (not exported)\n */\n\nvar util = require('./chai/utils');\n\n/**\n * # .use(function)\n *\n * Provides a way to extend the internals of Chai\n *\n * @param {Function}\n * @returns {this} for chaining\n * @api public\n */\n\nexports.use = function (fn) {\n  if (!~used.indexOf(fn)) {\n    fn(this, util);\n    used.push(fn);\n  }\n\n  return this;\n};\n\n/*!\n * Utility Functions\n */\n\nexports.util = util;\n\n/*!\n * Configuration\n */\n\nvar config = require('./chai/config');\nexports.config = config;\n\n/*!\n * Primary `Assertion` prototype\n */\n\nvar assertion = require('./chai/assertion');\nexports.use(assertion);\n\n/*!\n * Core Assertions\n */\n\nvar core = require('./chai/core/assertions');\nexports.use(core);\n\n/*!\n * Expect interface\n */\n\nvar expect = require('./chai/interface/expect');\nexports.use(expect);\n\n/*!\n * Should interface\n */\n\nvar should = require('./chai/interface/should');\nexports.use(should);\n\n/*!\n * Assert interface\n */\n\nvar assert = require('./chai/interface/assert');\nexports.use(assert);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai.js\n ** module id = 12\n ** module chunks = 1\n **/","/*!\n * assertion-error\n * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>\n * MIT Licensed\n */\n\n/*!\n * Return a function that will copy properties from\n * one object to another excluding any originally\n * listed. Returned function will create a new `{}`.\n *\n * @param {String} excluded properties ...\n * @return {Function}\n */\n\nfunction exclude () {\n  var excludes = [].slice.call(arguments);\n\n  function excludeProps (res, obj) {\n    Object.keys(obj).forEach(function (key) {\n      if (!~excludes.indexOf(key)) res[key] = obj[key];\n    });\n  }\n\n  return function extendExclude () {\n    var args = [].slice.call(arguments)\n      , i = 0\n      , res = {};\n\n    for (; i < args.length; i++) {\n      excludeProps(res, args[i]);\n    }\n\n    return res;\n  };\n};\n\n/*!\n * Primary Exports\n */\n\nmodule.exports = AssertionError;\n\n/**\n * ### AssertionError\n *\n * An extension of the JavaScript `Error` constructor for\n * assertion and validation scenarios.\n *\n * @param {String} message\n * @param {Object} properties to include (optional)\n * @param {callee} start stack function (optional)\n */\n\nfunction AssertionError (message, _props, ssf) {\n  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON')\n    , props = extend(_props || {});\n\n  // default values\n  this.message = message || 'Unspecified AssertionError';\n  this.showDiff = false;\n\n  // copy from properties\n  for (var key in props) {\n    this[key] = props[key];\n  }\n\n  // capture stack trace\n  ssf = ssf || arguments.callee;\n  if (ssf && Error.captureStackTrace) {\n    Error.captureStackTrace(this, ssf);\n  } else {\n    this.stack = new Error().stack;\n  }\n}\n\n/*!\n * Inherit from Error.prototype\n */\n\nAssertionError.prototype = Object.create(Error.prototype);\n\n/*!\n * Statically set name\n */\n\nAssertionError.prototype.name = 'AssertionError';\n\n/*!\n * Ensure correct constructor\n */\n\nAssertionError.prototype.constructor = AssertionError;\n\n/**\n * Allow errors to be converted to JSON for static transfer.\n *\n * @param {Boolean} include stack (default: `true`)\n * @return {Object} object that can be `JSON.stringify`\n */\n\nAssertionError.prototype.toJSON = function (stack) {\n  var extend = exclude('constructor', 'toJSON', 'stack')\n    , props = extend({ name: this.name }, this);\n\n  // include stack if exists and not turned off\n  if (false !== stack && this.stack) {\n    props.stack = this.stack;\n  }\n\n  return props;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/assertion-error/index.js\n ** module id = 13\n ** module chunks = 1\n **/","/*!\n * chai\n * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Main exports\n */\n\nvar exports = module.exports = {};\n\n/*!\n * test utility\n */\n\nexports.test = require('./test');\n\n/*!\n * type utility\n */\n\nexports.type = require('type-detect');\n\n/*!\n * expectTypes utility\n */\nexports.expectTypes = require('./expectTypes');\n\n/*!\n * message utility\n */\n\nexports.getMessage = require('./getMessage');\n\n/*!\n * actual utility\n */\n\nexports.getActual = require('./getActual');\n\n/*!\n * Inspect util\n */\n\nexports.inspect = require('./inspect');\n\n/*!\n * Object Display util\n */\n\nexports.objDisplay = require('./objDisplay');\n\n/*!\n * Flag utility\n */\n\nexports.flag = require('./flag');\n\n/*!\n * Flag transferring utility\n */\n\nexports.transferFlags = require('./transferFlags');\n\n/*!\n * Deep equal utility\n */\n\nexports.eql = require('deep-eql');\n\n/*!\n * Deep path value\n */\n\nexports.getPathValue = require('./getPathValue');\n\n/*!\n * Deep path info\n */\n\nexports.getPathInfo = require('./getPathInfo');\n\n/*!\n * Check if a property exists\n */\n\nexports.hasProperty = require('./hasProperty');\n\n/*!\n * Function name\n */\n\nexports.getName = require('./getName');\n\n/*!\n * add Property\n */\n\nexports.addProperty = require('./addProperty');\n\n/*!\n * add Method\n */\n\nexports.addMethod = require('./addMethod');\n\n/*!\n * overwrite Property\n */\n\nexports.overwriteProperty = require('./overwriteProperty');\n\n/*!\n * overwrite Method\n */\n\nexports.overwriteMethod = require('./overwriteMethod');\n\n/*!\n * Add a chainable method\n */\n\nexports.addChainableMethod = require('./addChainableMethod');\n\n/*!\n * Overwrite chainable method\n */\n\nexports.overwriteChainableMethod = require('./overwriteChainableMethod');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/index.js\n ** module id = 14\n ** module chunks = 1\n **/","/*!\n * Chai - test utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependancies\n */\n\nvar flag = require('./flag');\n\n/**\n * # test(object, expression)\n *\n * Test and object for expression.\n *\n * @param {Object} object (constructed Assertion)\n * @param {Arguments} chai.Assertion.prototype.assert arguments\n */\n\nmodule.exports = function (obj, args) {\n  var negate = flag(obj, 'negate')\n    , expr = args[0];\n  return negate ? !expr : expr;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/test.js\n ** module id = 15\n ** module chunks = 1\n **/","/*!\n * Chai - flag utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### flag(object, key, [value])\n *\n * Get or set a flag value on an object. If a\n * value is provided it will be set, else it will\n * return the currently set value or `undefined` if\n * the value is not set.\n *\n *     utils.flag(this, 'foo', 'bar'); // setter\n *     utils.flag(this, 'foo'); // getter, returns `bar`\n *\n * @param {Object} object constructed Assertion\n * @param {String} key\n * @param {Mixed} value (optional)\n * @name flag\n * @api private\n */\n\nmodule.exports = function (obj, key, value) {\n  var flags = obj.__flags || (obj.__flags = Object.create(null));\n  if (arguments.length === 3) {\n    flags[key] = value;\n  } else {\n    return flags[key];\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/flag.js\n ** module id = 16\n ** module chunks = 1\n **/","/*!\n * type-detect\n * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Primary Exports\n */\n\nvar exports = module.exports = getType;\n\n/**\n * ### typeOf (obj)\n *\n * Use several different techniques to determine\n * the type of object being tested.\n *\n *\n * @param {Mixed} object\n * @return {String} object type\n * @api public\n */\nvar objectTypeRegexp = /^\\[object (.*)\\]$/;\n\nfunction getType(obj) {\n  var type = Object.prototype.toString.call(obj).match(objectTypeRegexp)[1].toLowerCase();\n  // Let \"new String('')\" return 'object'\n  if (typeof Promise === 'function' && obj instanceof Promise) return 'promise';\n  // PhantomJS has type \"DOMWindow\" for null\n  if (obj === null) return 'null';\n  // PhantomJS has type \"DOMWindow\" for undefined\n  if (obj === undefined) return 'undefined';\n  return type;\n}\n\nexports.Library = Library;\n\n/**\n * ### Library\n *\n * Create a repository for custom type detection.\n *\n * ```js\n * var lib = new type.Library;\n * ```\n *\n */\n\nfunction Library() {\n  if (!(this instanceof Library)) return new Library();\n  this.tests = {};\n}\n\n/**\n * #### .of (obj)\n *\n * Expose replacement `typeof` detection to the library.\n *\n * ```js\n * if ('string' === lib.of('hello world')) {\n *   // ...\n * }\n * ```\n *\n * @param {Mixed} object to test\n * @return {String} type\n */\n\nLibrary.prototype.of = getType;\n\n/**\n * #### .define (type, test)\n *\n * Add a test to for the `.test()` assertion.\n *\n * Can be defined as a regular expression:\n *\n * ```js\n * lib.define('int', /^[0-9]+$/);\n * ```\n *\n * ... or as a function:\n *\n * ```js\n * lib.define('bln', function (obj) {\n *   if ('boolean' === lib.of(obj)) return true;\n *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];\n *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();\n *   return !! ~blns.indexOf(obj);\n * });\n * ```\n *\n * @param {String} type\n * @param {RegExp|Function} test\n * @api public\n */\n\nLibrary.prototype.define = function(type, test) {\n  if (arguments.length === 1) return this.tests[type];\n  this.tests[type] = test;\n  return this;\n};\n\n/**\n * #### .test (obj, test)\n *\n * Assert that an object is of type. Will first\n * check natives, and if that does not pass it will\n * use the user defined custom tests.\n *\n * ```js\n * assert(lib.test('1', 'int'));\n * assert(lib.test('yes', 'bln'));\n * ```\n *\n * @param {Mixed} object\n * @param {String} type\n * @return {Boolean} result\n * @api public\n */\n\nLibrary.prototype.test = function(obj, type) {\n  if (type === getType(obj)) return true;\n  var test = this.tests[type];\n\n  if (test && 'regexp' === getType(test)) {\n    return test.test(obj);\n  } else if (test && 'function' === getType(test)) {\n    return test(obj);\n  } else {\n    throw new ReferenceError('Type test \"' + type + '\" not defined or invalid.');\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/type-detect/lib/type.js\n ** module id = 18\n ** module chunks = 1\n **/","/*!\n * Chai - expectTypes utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### expectTypes(obj, types)\n *\n * Ensures that the object being tested against is of a valid type.\n *\n *     utils.expectTypes(this, ['array', 'object', 'string']);\n *\n * @param {Mixed} obj constructed Assertion\n * @param {Array} type A list of allowed types for this assertion\n * @name expectTypes\n * @api public\n */\n\nvar AssertionError = require('assertion-error');\nvar flag = require('./flag');\nvar type = require('type-detect');\n\nmodule.exports = function (obj, types) {\n  var obj = flag(obj, 'object');\n  types = types.map(function (t) { return t.toLowerCase(); });\n  types.sort();\n\n  // Transforms ['lorem', 'ipsum'] into 'a lirum, or an ipsum'\n  var str = types.map(function (t, index) {\n    var art = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(t.charAt(0)) ? 'an' : 'a';\n    var or = types.length > 1 && index === types.length - 1 ? 'or ' : '';\n    return or + art + ' ' + t;\n  }).join(', ');\n\n  if (!types.some(function (expected) { return type(obj) === expected; })) {\n    throw new AssertionError(\n      'object tested must be ' + str + ', but ' + type(obj) + ' given'\n    );\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/expectTypes.js\n ** module id = 19\n ** module chunks = 1\n **/","/*!\n * Chai - message composition utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependancies\n */\n\nvar flag = require('./flag')\n  , getActual = require('./getActual')\n  , inspect = require('./inspect')\n  , objDisplay = require('./objDisplay');\n\n/**\n * ### .getMessage(object, message, negateMessage)\n *\n * Construct the error message based on flags\n * and template tags. Template tags will return\n * a stringified inspection of the object referenced.\n *\n * Message template tags:\n * - `#{this}` current asserted object\n * - `#{act}` actual value\n * - `#{exp}` expected value\n *\n * @param {Object} object (constructed Assertion)\n * @param {Arguments} chai.Assertion.prototype.assert arguments\n * @name getMessage\n * @api public\n */\n\nmodule.exports = function (obj, args) {\n  var negate = flag(obj, 'negate')\n    , val = flag(obj, 'object')\n    , expected = args[3]\n    , actual = getActual(obj, args)\n    , msg = negate ? args[2] : args[1]\n    , flagMsg = flag(obj, 'message');\n\n  if(typeof msg === \"function\") msg = msg();\n  msg = msg || '';\n  msg = msg\n    .replace(/#{this}/g, objDisplay(val))\n    .replace(/#{act}/g, objDisplay(actual))\n    .replace(/#{exp}/g, objDisplay(expected));\n\n  return flagMsg ? flagMsg + ': ' + msg : msg;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/getMessage.js\n ** module id = 20\n ** module chunks = 1\n **/","/*!\n * Chai - getActual utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * # getActual(object, [actual])\n *\n * Returns the `actual` value for an Assertion\n *\n * @param {Object} object (constructed Assertion)\n * @param {Arguments} chai.Assertion.prototype.assert arguments\n */\n\nmodule.exports = function (obj, args) {\n  return args.length > 4 ? args[4] : obj._obj;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/getActual.js\n ** module id = 21\n ** module chunks = 1\n **/","// This is (almost) directly from Node.js utils\n// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js\n\nvar getName = require('./getName');\nvar getProperties = require('./getProperties');\nvar getEnumerableProperties = require('./getEnumerableProperties');\n\nmodule.exports = inspect;\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Boolean} showHidden Flag that shows hidden (not enumerable)\n *    properties of objects.\n * @param {Number} depth Depth in which to descend in object. Default is 2.\n * @param {Boolean} colors Flag to turn on ANSI escape codes to color the\n *    output. Default is false (no coloring).\n */\nfunction inspect(obj, showHidden, depth, colors) {\n  var ctx = {\n    showHidden: showHidden,\n    seen: [],\n    stylize: function (str) { return str; }\n  };\n  return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));\n}\n\n// Returns true if object is a DOM element.\nvar isDOMElement = function (object) {\n  if (typeof HTMLElement === 'object') {\n    return object instanceof HTMLElement;\n  } else {\n    return object &&\n      typeof object === 'object' &&\n      object.nodeType === 1 &&\n      typeof object.nodeName === 'string';\n  }\n};\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (value && typeof value.inspect === 'function' &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes);\n    if (typeof ret !== 'string') {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // If this is a DOM element, try to get the outer HTML.\n  if (isDOMElement(value)) {\n    if ('outerHTML' in value) {\n      return value.outerHTML;\n      // This value does not have an outerHTML attribute,\n      //   it could still be an XML element\n    } else {\n      // Attempt to serialize it\n      try {\n        if (document.xmlVersion) {\n          var xmlSerializer = new XMLSerializer();\n          return xmlSerializer.serializeToString(value);\n        } else {\n          // Firefox 11- do not support outerHTML\n          //   It does, however, support innerHTML\n          //   Use the following to render the element\n          var ns = \"http://www.w3.org/1999/xhtml\";\n          var container = document.createElementNS(ns, '_');\n\n          container.appendChild(value.cloneNode(false));\n          html = container.innerHTML\n            .replace('><', '>' + value.innerHTML + '<');\n          container.innerHTML = '';\n          return html;\n        }\n      } catch (err) {\n        // This could be a non-native DOM implementation,\n        //   continue with the normal flow:\n        //   printing the element as if it is an object.\n      }\n    }\n  }\n\n  // Look up the keys of the object.\n  var visibleKeys = getEnumerableProperties(value);\n  var keys = ctx.showHidden ? getProperties(value) : visibleKeys;\n\n  // Some type of object without properties can be shortcutted.\n  // In IE, errors have a single `stack` property, or if they are vanilla `Error`,\n  // a `stack` plus `description` property; ignore those for consistency.\n  if (keys.length === 0 || (isError(value) && (\n      (keys.length === 1 && keys[0] === 'stack') ||\n      (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')\n     ))) {\n    if (typeof value === 'function') {\n      var name = getName(value);\n      var nameSuffix = name ? ': ' + name : '';\n      return ctx.stylize('[Function' + nameSuffix + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (typeof value === 'function') {\n    var name = getName(value);\n    var nameSuffix = name ? ': ' + name : '';\n    base = ' [Function' + nameSuffix + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    return formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  switch (typeof value) {\n    case 'undefined':\n      return ctx.stylize('undefined', 'undefined');\n\n    case 'string':\n      var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                               .replace(/'/g, \"\\\\'\")\n                                               .replace(/\\\\\"/g, '\"') + '\\'';\n      return ctx.stylize(simple, 'string');\n\n    case 'number':\n      if (value === 0 && (1/value) === -Infinity) {\n        return ctx.stylize('-0', 'number');\n      }\n      return ctx.stylize('' + value, 'number');\n\n    case 'boolean':\n      return ctx.stylize('' + value, 'boolean');\n  }\n  // For some reason typeof null is \"object\", so special case here.\n  if (value === null) {\n    return ctx.stylize('null', 'null');\n  }\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (Object.prototype.hasOwnProperty.call(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str;\n  if (value.__lookupGetter__) {\n    if (value.__lookupGetter__(key)) {\n      if (value.__lookupSetter__(key)) {\n        str = ctx.stylize('[Getter/Setter]', 'special');\n      } else {\n        str = ctx.stylize('[Getter]', 'special');\n      }\n    } else {\n      if (value.__lookupSetter__(key)) {\n        str = ctx.stylize('[Setter]', 'special');\n      }\n    }\n  }\n  if (visibleKeys.indexOf(key) < 0) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(value[key]) < 0) {\n      if (recurseTimes === null) {\n        str = formatValue(ctx, value[key], null);\n      } else {\n        str = formatValue(ctx, value[key], recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (typeof name === 'undefined') {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\nfunction isArray(ar) {\n  return Array.isArray(ar) ||\n         (typeof ar === 'object' && objectToString(ar) === '[object Array]');\n}\n\nfunction isRegExp(re) {\n  return typeof re === 'object' && objectToString(re) === '[object RegExp]';\n}\n\nfunction isDate(d) {\n  return typeof d === 'object' && objectToString(d) === '[object Date]';\n}\n\nfunction isError(e) {\n  return typeof e === 'object' && objectToString(e) === '[object Error]';\n}\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/inspect.js\n ** module id = 22\n ** module chunks = 1\n **/","/*!\n * Chai - getName utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * # getName(func)\n *\n * Gets the name of a function, in a cross-browser way.\n *\n * @param {Function} a function (usually a constructor)\n */\n\nmodule.exports = function (func) {\n  if (func.name) return func.name;\n\n  var match = /^\\s?function ([^(]*)\\(/.exec(func);\n  return match && match[1] ? match[1] : \"\";\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/getName.js\n ** module id = 23\n ** module chunks = 1\n **/","/*!\n * Chai - getProperties utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .getProperties(object)\n *\n * This allows the retrieval of property names of an object, enumerable or not,\n * inherited or not.\n *\n * @param {Object} object\n * @returns {Array}\n * @name getProperties\n * @api public\n */\n\nmodule.exports = function getProperties(object) {\n  var result = Object.getOwnPropertyNames(object);\n\n  function addProperty(property) {\n    if (result.indexOf(property) === -1) {\n      result.push(property);\n    }\n  }\n\n  var proto = Object.getPrototypeOf(object);\n  while (proto !== null) {\n    Object.getOwnPropertyNames(proto).forEach(addProperty);\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return result;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/getProperties.js\n ** module id = 24\n ** module chunks = 1\n **/","/*!\n * Chai - getEnumerableProperties utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .getEnumerableProperties(object)\n *\n * This allows the retrieval of enumerable property names of an object,\n * inherited or not.\n *\n * @param {Object} object\n * @returns {Array}\n * @name getEnumerableProperties\n * @api public\n */\n\nmodule.exports = function getEnumerableProperties(object) {\n  var result = [];\n  for (var name in object) {\n    result.push(name);\n  }\n  return result;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/getEnumerableProperties.js\n ** module id = 25\n ** module chunks = 1\n **/","/*!\n * Chai - flag utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependancies\n */\n\nvar inspect = require('./inspect');\nvar config = require('../config');\n\n/**\n * ### .objDisplay (object)\n *\n * Determines if an object or an array matches\n * criteria to be inspected in-line for error\n * messages or should be truncated.\n *\n * @param {Mixed} javascript object to inspect\n * @name objDisplay\n * @api public\n */\n\nmodule.exports = function (obj) {\n  var str = inspect(obj)\n    , type = Object.prototype.toString.call(obj);\n\n  if (config.truncateThreshold && str.length >= config.truncateThreshold) {\n    if (type === '[object Function]') {\n      return !obj.name || obj.name === ''\n        ? '[Function]'\n        : '[Function: ' + obj.name + ']';\n    } else if (type === '[object Array]') {\n      return '[ Array(' + obj.length + ') ]';\n    } else if (type === '[object Object]') {\n      var keys = Object.keys(obj)\n        , kstr = keys.length > 2\n          ? keys.splice(0, 2).join(', ') + ', ...'\n          : keys.join(', ');\n      return '{ Object (' + kstr + ') }';\n    } else {\n      return str;\n    }\n  } else {\n    return str;\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/objDisplay.js\n ** module id = 26\n ** module chunks = 1\n **/","module.exports = {\n\n  /**\n   * ### config.includeStack\n   *\n   * User configurable property, influences whether stack trace\n   * is included in Assertion error message. Default of false\n   * suppresses stack trace in the error message.\n   *\n   *     chai.config.includeStack = true;  // enable stack on error\n   *\n   * @param {Boolean}\n   * @api public\n   */\n\n   includeStack: false,\n\n  /**\n   * ### config.showDiff\n   *\n   * User configurable property, influences whether or not\n   * the `showDiff` flag should be included in the thrown\n   * AssertionErrors. `false` will always be `false`; `true`\n   * will be true when the assertion has requested a diff\n   * be shown.\n   *\n   * @param {Boolean}\n   * @api public\n   */\n\n  showDiff: true,\n\n  /**\n   * ### config.truncateThreshold\n   *\n   * User configurable property, sets length threshold for actual and\n   * expected values in assertion errors. If this threshold is exceeded, for\n   * example for large data structures, the value is replaced with something\n   * like `[ Array(3) ]` or `{ Object (prop1, prop2) }`.\n   *\n   * Set it to zero if you want to disable truncating altogether.\n   *\n   * This is especially userful when doing assertions on arrays: having this\n   * set to a reasonable large value makes the failure messages readily\n   * inspectable.\n   *\n   *     chai.config.truncateThreshold = 0;  // disable truncating\n   *\n   * @param {Number}\n   * @api public\n   */\n\n  truncateThreshold: 40\n\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/config.js\n ** module id = 27\n ** module chunks = 1\n **/","/*!\n * Chai - transferFlags utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### transferFlags(assertion, object, includeAll = true)\n *\n * Transfer all the flags for `assertion` to `object`. If\n * `includeAll` is set to `false`, then the base Chai\n * assertion flags (namely `object`, `ssfi`, and `message`)\n * will not be transferred.\n *\n *\n *     var newAssertion = new Assertion();\n *     utils.transferFlags(assertion, newAssertion);\n *\n *     var anotherAsseriton = new Assertion(myObj);\n *     utils.transferFlags(assertion, anotherAssertion, false);\n *\n * @param {Assertion} assertion the assertion to transfer the flags from\n * @param {Object} object the object to transfer the flags to; usually a new assertion\n * @param {Boolean} includeAll\n * @name transferFlags\n * @api private\n */\n\nmodule.exports = function (assertion, object, includeAll) {\n  var flags = assertion.__flags || (assertion.__flags = Object.create(null));\n\n  if (!object.__flags) {\n    object.__flags = Object.create(null);\n  }\n\n  includeAll = arguments.length === 3 ? includeAll : true;\n\n  for (var flag in flags) {\n    if (includeAll ||\n        (flag !== 'object' && flag !== 'ssfi' && flag != 'message')) {\n      object.__flags[flag] = flags[flag];\n    }\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/transferFlags.js\n ** module id = 28\n ** module chunks = 1\n **/","module.exports = require('./lib/eql');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/deep-eql/index.js\n ** module id = 29\n ** module chunks = 1\n **/","/*!\n * deep-eql\n * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependencies\n */\n\nvar type = require('type-detect');\n\n/*!\n * Buffer.isBuffer browser shim\n */\n\nvar Buffer;\ntry { Buffer = require('buffer').Buffer; }\ncatch(ex) {\n  Buffer = {};\n  Buffer.isBuffer = function() { return false; }\n}\n\n/*!\n * Primary Export\n */\n\nmodule.exports = deepEqual;\n\n/**\n * Assert super-strict (egal) equality between\n * two objects of any type.\n *\n * @param {Mixed} a\n * @param {Mixed} b\n * @param {Array} memoised (optional)\n * @return {Boolean} equal match\n */\n\nfunction deepEqual(a, b, m) {\n  if (sameValue(a, b)) {\n    return true;\n  } else if ('date' === type(a)) {\n    return dateEqual(a, b);\n  } else if ('regexp' === type(a)) {\n    return regexpEqual(a, b);\n  } else if (Buffer.isBuffer(a)) {\n    return bufferEqual(a, b);\n  } else if ('arguments' === type(a)) {\n    return argumentsEqual(a, b, m);\n  } else if (!typeEqual(a, b)) {\n    return false;\n  } else if (('object' !== type(a) && 'object' !== type(b))\n  && ('array' !== type(a) && 'array' !== type(b))) {\n    return sameValue(a, b);\n  } else {\n    return objectEqual(a, b, m);\n  }\n}\n\n/*!\n * Strict (egal) equality test. Ensures that NaN always\n * equals NaN and `-0` does not equal `+0`.\n *\n * @param {Mixed} a\n * @param {Mixed} b\n * @return {Boolean} equal match\n */\n\nfunction sameValue(a, b) {\n  if (a === b) return a !== 0 || 1 / a === 1 / b;\n  return a !== a && b !== b;\n}\n\n/*!\n * Compare the types of two given objects and\n * return if they are equal. Note that an Array\n * has a type of `array` (not `object`) and arguments\n * have a type of `arguments` (not `array`/`object`).\n *\n * @param {Mixed} a\n * @param {Mixed} b\n * @return {Boolean} result\n */\n\nfunction typeEqual(a, b) {\n  return type(a) === type(b);\n}\n\n/*!\n * Compare two Date objects by asserting that\n * the time values are equal using `saveValue`.\n *\n * @param {Date} a\n * @param {Date} b\n * @return {Boolean} result\n */\n\nfunction dateEqual(a, b) {\n  if ('date' !== type(b)) return false;\n  return sameValue(a.getTime(), b.getTime());\n}\n\n/*!\n * Compare two regular expressions by converting them\n * to string and checking for `sameValue`.\n *\n * @param {RegExp} a\n * @param {RegExp} b\n * @return {Boolean} result\n */\n\nfunction regexpEqual(a, b) {\n  if ('regexp' !== type(b)) return false;\n  return sameValue(a.toString(), b.toString());\n}\n\n/*!\n * Assert deep equality of two `arguments` objects.\n * Unfortunately, these must be sliced to arrays\n * prior to test to ensure no bad behavior.\n *\n * @param {Arguments} a\n * @param {Arguments} b\n * @param {Array} memoize (optional)\n * @return {Boolean} result\n */\n\nfunction argumentsEqual(a, b, m) {\n  if ('arguments' !== type(b)) return false;\n  a = [].slice.call(a);\n  b = [].slice.call(b);\n  return deepEqual(a, b, m);\n}\n\n/*!\n * Get enumerable properties of a given object.\n *\n * @param {Object} a\n * @return {Array} property names\n */\n\nfunction enumerable(a) {\n  var res = [];\n  for (var key in a) res.push(key);\n  return res;\n}\n\n/*!\n * Simple equality for flat iterable objects\n * such as Arrays or Node.js buffers.\n *\n * @param {Iterable} a\n * @param {Iterable} b\n * @return {Boolean} result\n */\n\nfunction iterableEqual(a, b) {\n  if (a.length !==  b.length) return false;\n\n  var i = 0;\n  var match = true;\n\n  for (; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      match = false;\n      break;\n    }\n  }\n\n  return match;\n}\n\n/*!\n * Extension to `iterableEqual` specifically\n * for Node.js Buffers.\n *\n * @param {Buffer} a\n * @param {Mixed} b\n * @return {Boolean} result\n */\n\nfunction bufferEqual(a, b) {\n  if (!Buffer.isBuffer(b)) return false;\n  return iterableEqual(a, b);\n}\n\n/*!\n * Block for `objectEqual` ensuring non-existing\n * values don't get in.\n *\n * @param {Mixed} object\n * @return {Boolean} result\n */\n\nfunction isValue(a) {\n  return a !== null && a !== undefined;\n}\n\n/*!\n * Recursively check the equality of two objects.\n * Once basic sameness has been established it will\n * defer to `deepEqual` for each enumerable key\n * in the object.\n *\n * @param {Mixed} a\n * @param {Mixed} b\n * @return {Boolean} result\n */\n\nfunction objectEqual(a, b, m) {\n  if (!isValue(a) || !isValue(b)) {\n    return false;\n  }\n\n  if (a.prototype !== b.prototype) {\n    return false;\n  }\n\n  var i;\n  if (m) {\n    for (i = 0; i < m.length; i++) {\n      if ((m[i][0] === a && m[i][1] === b)\n      ||  (m[i][0] === b && m[i][1] === a)) {\n        return true;\n      }\n    }\n  } else {\n    m = [];\n  }\n\n  try {\n    var ka = enumerable(a);\n    var kb = enumerable(b);\n  } catch (ex) {\n    return false;\n  }\n\n  ka.sort();\n  kb.sort();\n\n  if (!iterableEqual(ka, kb)) {\n    return false;\n  }\n\n  m.push([ a, b ]);\n\n  var key;\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key], m)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/deep-eql/lib/eql.js\n ** module id = 30\n ** module chunks = 1\n **/","/*!\n * type-detect\n * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Primary Exports\n */\n\nvar exports = module.exports = getType;\n\n/*!\n * Detectable javascript natives\n */\n\nvar natives = {\n    '[object Array]': 'array'\n  , '[object RegExp]': 'regexp'\n  , '[object Function]': 'function'\n  , '[object Arguments]': 'arguments'\n  , '[object Date]': 'date'\n};\n\n/**\n * ### typeOf (obj)\n *\n * Use several different techniques to determine\n * the type of object being tested.\n *\n *\n * @param {Mixed} object\n * @return {String} object type\n * @api public\n */\n\nfunction getType (obj) {\n  var str = Object.prototype.toString.call(obj);\n  if (natives[str]) return natives[str];\n  if (obj === null) return 'null';\n  if (obj === undefined) return 'undefined';\n  if (obj === Object(obj)) return 'object';\n  return typeof obj;\n}\n\nexports.Library = Library;\n\n/**\n * ### Library\n *\n * Create a repository for custom type detection.\n *\n * ```js\n * var lib = new type.Library;\n * ```\n *\n */\n\nfunction Library () {\n  this.tests = {};\n}\n\n/**\n * #### .of (obj)\n *\n * Expose replacement `typeof` detection to the library.\n *\n * ```js\n * if ('string' === lib.of('hello world')) {\n *   // ...\n * }\n * ```\n *\n * @param {Mixed} object to test\n * @return {String} type\n */\n\nLibrary.prototype.of = getType;\n\n/**\n * #### .define (type, test)\n *\n * Add a test to for the `.test()` assertion.\n *\n * Can be defined as a regular expression:\n *\n * ```js\n * lib.define('int', /^[0-9]+$/);\n * ```\n *\n * ... or as a function:\n *\n * ```js\n * lib.define('bln', function (obj) {\n *   if ('boolean' === lib.of(obj)) return true;\n *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];\n *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();\n *   return !! ~blns.indexOf(obj);\n * });\n * ```\n *\n * @param {String} type\n * @param {RegExp|Function} test\n * @api public\n */\n\nLibrary.prototype.define = function (type, test) {\n  if (arguments.length === 1) return this.tests[type];\n  this.tests[type] = test;\n  return this;\n};\n\n/**\n * #### .test (obj, test)\n *\n * Assert that an object is of type. Will first\n * check natives, and if that does not pass it will\n * use the user defined custom tests.\n *\n * ```js\n * assert(lib.test('1', 'int'));\n * assert(lib.test('yes', 'bln'));\n * ```\n *\n * @param {Mixed} object\n * @param {String} type\n * @return {Boolean} result\n * @api public\n */\n\nLibrary.prototype.test = function (obj, type) {\n  if (type === getType(obj)) return true;\n  var test = this.tests[type];\n\n  if (test && 'regexp' === getType(test)) {\n    return test.test(obj);\n  } else if (test && 'function' === getType(test)) {\n    return test(obj);\n  } else {\n    throw new ReferenceError('Type test \"' + type + '\" not defined or invalid.');\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/deep-eql/~/type-detect/lib/type.js\n ** module id = 32\n ** module chunks = 1\n **/","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('is-array')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192 // not used by this implementation\n\nvar rootParent = {}\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property\n *     on objects.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\nfunction typedArraySupport () {\n  function Bar () {}\n  try {\n    var arr = new Uint8Array(1)\n    arr.foo = function () { return 42 }\n    arr.constructor = Bar\n    return arr.foo() === 42 && // typed array instances can be augmented\n        arr.constructor === Bar && // constructor can be set\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\n/**\n * Class: Buffer\n * =============\n *\n * The Buffer constructor returns instances of `Uint8Array` that are augmented\n * with function properties for all the node `Buffer` API functions. We use\n * `Uint8Array` so that square bracket notation works as expected -- it returns\n * a single octet.\n *\n * By augmenting the instances, we can avoid modifying the `Uint8Array`\n * prototype.\n */\nfunction Buffer (arg) {\n  if (!(this instanceof Buffer)) {\n    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\n    if (arguments.length > 1) return new Buffer(arg, arguments[1])\n    return new Buffer(arg)\n  }\n\n  this.length = 0\n  this.parent = undefined\n\n  // Common case.\n  if (typeof arg === 'number') {\n    return fromNumber(this, arg)\n  }\n\n  // Slightly less common case.\n  if (typeof arg === 'string') {\n    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\n  }\n\n  // Unusual.\n  return fromObject(this, arg)\n}\n\nfunction fromNumber (that, length) {\n  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < length; i++) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\n\n  // Assumption: byteLength() return value is always < kMaxLength.\n  var length = byteLength(string, encoding) | 0\n  that = allocate(that, length)\n\n  that.write(string, encoding)\n  return that\n}\n\nfunction fromObject (that, object) {\n  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\n\n  if (isArray(object)) return fromArray(that, object)\n\n  if (object == null) {\n    throw new TypeError('must start with number, buffer, array or string')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined') {\n    if (object.buffer instanceof ArrayBuffer) {\n      return fromTypedArray(that, object)\n    }\n    if (object instanceof ArrayBuffer) {\n      return fromArrayBuffer(that, object)\n    }\n  }\n\n  if (object.length) return fromArrayLike(that, object)\n\n  return fromJsonObject(that, object)\n}\n\nfunction fromBuffer (that, buffer) {\n  var length = checked(buffer.length) | 0\n  that = allocate(that, length)\n  buffer.copy(that, 0, 0, length)\n  return that\n}\n\nfunction fromArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Duplicate of fromArray() to keep fromArray() monomorphic.\nfunction fromTypedArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  // Truncating the elements is probably not what people expect from typed\n  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\n  // of the old Buffer constructor.\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    array.byteLength\n    that = Buffer._augment(new Uint8Array(array))\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromTypedArray(that, new Uint8Array(array))\n  }\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\n// Returns a zero-length buffer for inputs that don't conform to the spec.\nfunction fromJsonObject (that, object) {\n  var array\n  var length = 0\n\n  if (object.type === 'Buffer' && isArray(object.data)) {\n    array = object.data\n    length = checked(array.length) | 0\n  }\n  that = allocate(that, length)\n\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n}\n\nfunction allocate (that, length) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = Buffer._augment(new Uint8Array(length))\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that.length = length\n    that._isBuffer = true\n  }\n\n  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\n  if (fromPool) that.parent = rootParent\n\n  return that\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (subject, encoding) {\n  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n\n  var buf = new Buffer(subject, encoding)\n  delete buf.parent\n  return buf\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  var i = 0\n  var len = Math.min(x, y)\n  while (i < len) {\n    if (a[i] !== b[i]) break\n\n    ++i\n  }\n\n  if (i !== len) {\n    x = a[i]\n    y = b[i]\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; i++) {\n      length += list[i].length\n    }\n  }\n\n  var buf = new Buffer(length)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\nfunction byteLength (string, encoding) {\n  if (typeof string !== 'string') string = '' + string\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'binary':\n      // Deprecated\n      case 'raw':\n      case 'raws':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\n// pre-set for values that may exist in the future\nBuffer.prototype.length = undefined\nBuffer.prototype.parent = undefined\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  start = start | 0\n  end = end === undefined || end === Infinity ? this.length : end | 0\n\n  if (!encoding) encoding = 'utf8'\n  if (start < 0) start = 0\n  if (end > this.length) end = this.length\n  if (end <= start) return ''\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'binary':\n        return binarySlice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return 0\n  return Buffer.compare(this, b)\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset) {\n  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n  byteOffset >>= 0\n\n  if (this.length === 0) return -1\n  if (byteOffset >= this.length) return -1\n\n  // Negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n\n  if (typeof val === 'string') {\n    if (val.length === 0) return -1 // special case: looking for empty string always fails\n    return String.prototype.indexOf.call(this, val, byteOffset)\n  }\n  if (Buffer.isBuffer(val)) {\n    return arrayIndexOf(this, val, byteOffset)\n  }\n  if (typeof val === 'number') {\n    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n    }\n    return arrayIndexOf(this, [ val ], byteOffset)\n  }\n\n  function arrayIndexOf (arr, val, byteOffset) {\n    var foundIndex = -1\n    for (var i = 0; byteOffset + i < arr.length; i++) {\n      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n      } else {\n        foundIndex = -1\n      }\n    }\n    return -1\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\n// `get` is deprecated\nBuffer.prototype.get = function get (offset) {\n  console.log('.get() is deprecated. Access using array indexes instead.')\n  return this.readUInt8(offset)\n}\n\n// `set` is deprecated\nBuffer.prototype.set = function set (v, offset) {\n  console.log('.set() is deprecated. Access using array indexes instead.')\n  return this.writeUInt8(v, offset)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) throw new Error('Invalid hex string')\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction binaryWrite (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    var swap = encoding\n    encoding = offset\n    offset = length | 0\n    length = swap\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'binary':\n        return binaryWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction binarySlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = Buffer._augment(this.subarray(start, end))\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  if (newBuf.length) newBuf.parent = this.parent || this\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n  if (offset < 0) throw new RangeError('index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; i--) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; i++) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    target._set(this.subarray(start, start + len), targetStart)\n  }\n\n  return len\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  if (end < start) throw new RangeError('end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n\n  var i\n  if (typeof value === 'number') {\n    for (i = start; i < end; i++) {\n      this[i] = value\n    }\n  } else {\n    var bytes = utf8ToBytes(value.toString())\n    var len = bytes.length\n    for (i = start; i < end; i++) {\n      this[i] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n/**\n * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n */\nBuffer.prototype.toArrayBuffer = function toArrayBuffer () {\n  if (typeof Uint8Array !== 'undefined') {\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      return (new Buffer(this)).buffer\n    } else {\n      var buf = new Uint8Array(this.length)\n      for (var i = 0, len = buf.length; i < len; i += 1) {\n        buf[i] = this[i]\n      }\n      return buf.buffer\n    }\n  } else {\n    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')\n  }\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar BP = Buffer.prototype\n\n/**\n * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n */\nBuffer._augment = function _augment (arr) {\n  arr.constructor = Buffer\n  arr._isBuffer = true\n\n  // save reference to original Uint8Array set method before overwriting\n  arr._set = arr.set\n\n  // deprecated\n  arr.get = BP.get\n  arr.set = BP.set\n\n  arr.write = BP.write\n  arr.toString = BP.toString\n  arr.toLocaleString = BP.toString\n  arr.toJSON = BP.toJSON\n  arr.equals = BP.equals\n  arr.compare = BP.compare\n  arr.indexOf = BP.indexOf\n  arr.copy = BP.copy\n  arr.slice = BP.slice\n  arr.readUIntLE = BP.readUIntLE\n  arr.readUIntBE = BP.readUIntBE\n  arr.readUInt8 = BP.readUInt8\n  arr.readUInt16LE = BP.readUInt16LE\n  arr.readUInt16BE = BP.readUInt16BE\n  arr.readUInt32LE = BP.readUInt32LE\n  arr.readUInt32BE = BP.readUInt32BE\n  arr.readIntLE = BP.readIntLE\n  arr.readIntBE = BP.readIntBE\n  arr.readInt8 = BP.readInt8\n  arr.readInt16LE = BP.readInt16LE\n  arr.readInt16BE = BP.readInt16BE\n  arr.readInt32LE = BP.readInt32LE\n  arr.readInt32BE = BP.readInt32BE\n  arr.readFloatLE = BP.readFloatLE\n  arr.readFloatBE = BP.readFloatBE\n  arr.readDoubleLE = BP.readDoubleLE\n  arr.readDoubleBE = BP.readDoubleBE\n  arr.writeUInt8 = BP.writeUInt8\n  arr.writeUIntLE = BP.writeUIntLE\n  arr.writeUIntBE = BP.writeUIntBE\n  arr.writeUInt16LE = BP.writeUInt16LE\n  arr.writeUInt16BE = BP.writeUInt16BE\n  arr.writeUInt32LE = BP.writeUInt32LE\n  arr.writeUInt32BE = BP.writeUInt32BE\n  arr.writeIntLE = BP.writeIntLE\n  arr.writeIntBE = BP.writeIntBE\n  arr.writeInt8 = BP.writeInt8\n  arr.writeInt16LE = BP.writeInt16LE\n  arr.writeInt16BE = BP.writeInt16BE\n  arr.writeInt32LE = BP.writeInt32LE\n  arr.writeInt32BE = BP.writeInt32BE\n  arr.writeFloatLE = BP.writeFloatLE\n  arr.writeFloatBE = BP.writeFloatBE\n  arr.writeDoubleLE = BP.writeDoubleLE\n  arr.writeDoubleBE = BP.writeDoubleBE\n  arr.fill = BP.fill\n  arr.inspect = BP.inspect\n  arr.toArrayBuffer = BP.toArrayBuffer\n\n  return arr\n}\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; i++) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/buffer/index.js\n ** module id = 33\n ** module chunks = 1\n **/","var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n;(function (exports) {\n\t'use strict';\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n\tvar PLUS   = '+'.charCodeAt(0)\n\tvar SLASH  = '/'.charCodeAt(0)\n\tvar NUMBER = '0'.charCodeAt(0)\n\tvar LOWER  = 'a'.charCodeAt(0)\n\tvar UPPER  = 'A'.charCodeAt(0)\n\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\n\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\n\n\tfunction decode (elt) {\n\t\tvar code = elt.charCodeAt(0)\n\t\tif (code === PLUS ||\n\t\t    code === PLUS_URL_SAFE)\n\t\t\treturn 62 // '+'\n\t\tif (code === SLASH ||\n\t\t    code === SLASH_URL_SAFE)\n\t\t\treturn 63 // '/'\n\t\tif (code < NUMBER)\n\t\t\treturn -1 //no match\n\t\tif (code < NUMBER + 10)\n\t\t\treturn code - NUMBER + 26 + 26\n\t\tif (code < UPPER + 26)\n\t\t\treturn code - UPPER\n\t\tif (code < LOWER + 26)\n\t\t\treturn code - LOWER + 26\n\t}\n\n\tfunction b64ToByteArray (b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr\n\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tvar len = b64.length\n\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\n\t\tvar L = 0\n\n\t\tfunction push (v) {\n\t\t\tarr[L++] = v\n\t\t}\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\tpush(tmp & 0xFF)\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\treturn arr\n\t}\n\n\tfunction uint8ToBase64 (uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length\n\n\t\tfunction encode (num) {\n\t\t\treturn lookup.charAt(num)\n\t\t}\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t}\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\toutput += tripletToBase64(temp)\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\toutput += '=='\n\t\t\t\tbreak\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\toutput += '='\n\t\t\t\tbreak\n\t\t}\n\n\t\treturn output\n\t}\n\n\texports.toByteArray = b64ToByteArray\n\texports.fromByteArray = uint8ToBase64\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/base64-js/lib/b64.js\n ** module id = 34\n ** module chunks = 1\n **/","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ieee754/index.js\n ** module id = 35\n ** module chunks = 1\n **/","\n/**\n * isArray\n */\n\nvar isArray = Array.isArray;\n\n/**\n * toString\n */\n\nvar str = Object.prototype.toString;\n\n/**\n * Whether or not the given `val`\n * is an array.\n *\n * example:\n *\n *        isArray([]);\n *        // > true\n *        isArray(arguments);\n *        // > false\n *        isArray('');\n *        // > false\n *\n * @param {mixed} val\n * @return {bool}\n */\n\nmodule.exports = isArray || function (val) {\n  return !! val && '[object Array]' == str.call(val);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/is-array/index.js\n ** module id = 36\n ** module chunks = 1\n **/","/*!\n * Chai - getPathValue utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * @see https://github.com/logicalparadox/filtr\n * MIT Licensed\n */\n\nvar getPathInfo = require('./getPathInfo');\n\n/**\n * ### .getPathValue(path, object)\n *\n * This allows the retrieval of values in an\n * object given a string path.\n *\n *     var obj = {\n *         prop1: {\n *             arr: ['a', 'b', 'c']\n *           , str: 'Hello'\n *         }\n *       , prop2: {\n *             arr: [ { nested: 'Universe' } ]\n *           , str: 'Hello again!'\n *         }\n *     }\n *\n * The following would be the results.\n *\n *     getPathValue('prop1.str', obj); // Hello\n *     getPathValue('prop1.att[2]', obj); // b\n *     getPathValue('prop2.arr[0].nested', obj); // Universe\n *\n * @param {String} path\n * @param {Object} object\n * @returns {Object} value or `undefined`\n * @name getPathValue\n * @api public\n */\nmodule.exports = function(path, obj) {\n  var info = getPathInfo(path, obj);\n  return info.value;\n}; \n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/getPathValue.js\n ** module id = 37\n ** module chunks = 1\n **/","/*!\n * Chai - getPathInfo utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar hasProperty = require('./hasProperty');\n\n/**\n * ### .getPathInfo(path, object)\n *\n * This allows the retrieval of property info in an\n * object given a string path.\n *\n * The path info consists of an object with the\n * following properties:\n *\n * * parent - The parent object of the property referenced by `path`\n * * name - The name of the final property, a number if it was an array indexer\n * * value - The value of the property, if it exists, otherwise `undefined`\n * * exists - Whether the property exists or not\n *\n * @param {String} path\n * @param {Object} object\n * @returns {Object} info\n * @name getPathInfo\n * @api public\n */\n\nmodule.exports = function getPathInfo(path, obj) {\n  var parsed = parsePath(path),\n      last = parsed[parsed.length - 1];\n\n  var info = {\n    parent: parsed.length > 1 ? _getPathValue(parsed, obj, parsed.length - 1) : obj,\n    name: last.p || last.i,\n    value: _getPathValue(parsed, obj)\n  };\n  info.exists = hasProperty(info.name, info.parent);\n\n  return info;\n};\n\n\n/*!\n * ## parsePath(path)\n *\n * Helper function used to parse string object\n * paths. Use in conjunction with `_getPathValue`.\n *\n *      var parsed = parsePath('myobject.property.subprop');\n *\n * ### Paths:\n *\n * * Can be as near infinitely deep and nested\n * * Arrays are also valid using the formal `myobject.document[3].property`.\n * * Literal dots and brackets (not delimiter) must be backslash-escaped.\n *\n * @param {String} path\n * @returns {Object} parsed\n * @api private\n */\n\nfunction parsePath (path) {\n  var str = path.replace(/([^\\\\])\\[/g, '$1.[')\n    , parts = str.match(/(\\\\\\.|[^.]+?)+/g);\n  return parts.map(function (value) {\n    var re = /^\\[(\\d+)\\]$/\n      , mArr = re.exec(value);\n    if (mArr) return { i: parseFloat(mArr[1]) };\n    else return { p: value.replace(/\\\\([.\\[\\]])/g, '$1') };\n  });\n}\n\n\n/*!\n * ## _getPathValue(parsed, obj)\n *\n * Helper companion function for `.parsePath` that returns\n * the value located at the parsed address.\n *\n *      var value = getPathValue(parsed, obj);\n *\n * @param {Object} parsed definition from `parsePath`.\n * @param {Object} object to search against\n * @param {Number} object to search against\n * @returns {Object|Undefined} value\n * @api private\n */\n\nfunction _getPathValue (parsed, obj, index) {\n  var tmp = obj\n    , res;\n\n  index = (index === undefined ? parsed.length : index);\n\n  for (var i = 0, l = index; i < l; i++) {\n    var part = parsed[i];\n    if (tmp) {\n      if ('undefined' !== typeof part.p)\n        tmp = tmp[part.p];\n      else if ('undefined' !== typeof part.i)\n        tmp = tmp[part.i];\n      if (i == (l - 1)) res = tmp;\n    } else {\n      res = undefined;\n    }\n  }\n  return res;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/getPathInfo.js\n ** module id = 38\n ** module chunks = 1\n **/","/*!\n * Chai - hasProperty utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar type = require('type-detect');\n\n/**\n * ### .hasProperty(object, name)\n *\n * This allows checking whether an object has\n * named property or numeric array index.\n *\n * Basically does the same thing as the `in`\n * operator but works properly with natives\n * and null/undefined values.\n *\n *     var obj = {\n *         arr: ['a', 'b', 'c']\n *       , str: 'Hello'\n *     }\n *\n * The following would be the results.\n *\n *     hasProperty('str', obj);  // true\n *     hasProperty('constructor', obj);  // true\n *     hasProperty('bar', obj);  // false\n *     \n *     hasProperty('length', obj.str); // true\n *     hasProperty(1, obj.str);  // true\n *     hasProperty(5, obj.str);  // false\n *\n *     hasProperty('length', obj.arr);  // true\n *     hasProperty(2, obj.arr);  // true\n *     hasProperty(3, obj.arr);  // false\n *\n * @param {Objuect} object\n * @param {String|Number} name\n * @returns {Boolean} whether it exists\n * @name getPathInfo\n * @api public\n */\n\nvar literals = {\n    'number': Number\n  , 'string': String\n};\n\nmodule.exports = function hasProperty(name, obj) {\n  var ot = type(obj);\n\n  // Bad Object, obviously no props at all\n  if(ot === 'null' || ot === 'undefined')\n    return false;\n\n  // The `in` operator does not work with certain literals\n  // box these before the check\n  if(literals[ot] && typeof obj !== 'object')\n    obj = new literals[ot](obj);\n\n  return name in obj;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/hasProperty.js\n ** module id = 39\n ** module chunks = 1\n **/","/*!\n * Chai - addProperty utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar config = require('../config');\nvar flag = require('./flag');\n\n/**\n * ### addProperty (ctx, name, getter)\n *\n * Adds a property to the prototype of an object.\n *\n *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {\n *       var obj = utils.flag(this, 'object');\n *       new chai.Assertion(obj).to.be.instanceof(Foo);\n *     });\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.addProperty('foo', fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.be.foo;\n *\n * @param {Object} ctx object to which the property is added\n * @param {String} name of property to add\n * @param {Function} getter function to be used for name\n * @name addProperty\n * @api public\n */\n\nmodule.exports = function (ctx, name, getter) {\n  Object.defineProperty(ctx, name,\n    { get: function addProperty() {\n        var old_ssfi = flag(this, 'ssfi');\n        if (old_ssfi && config.includeStack === false)\n          flag(this, 'ssfi', addProperty);\n\n        var result = getter.call(this);\n        return result === undefined ? this : result;\n      }\n    , configurable: true\n  });\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/addProperty.js\n ** module id = 40\n ** module chunks = 1\n **/","/*!\n * Chai - addMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar config = require('../config');\n\n/**\n * ### .addMethod (ctx, name, method)\n *\n * Adds a method to the prototype of an object.\n *\n *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {\n *       var obj = utils.flag(this, 'object');\n *       new chai.Assertion(obj).to.be.equal(str);\n *     });\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.addMethod('foo', fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(fooStr).to.be.foo('bar');\n *\n * @param {Object} ctx object to which the method is added\n * @param {String} name of method to add\n * @param {Function} method function to be used for name\n * @name addMethod\n * @api public\n */\nvar flag = require('./flag');\n\nmodule.exports = function (ctx, name, method) {\n  ctx[name] = function () {\n    var old_ssfi = flag(this, 'ssfi');\n    if (old_ssfi && config.includeStack === false)\n      flag(this, 'ssfi', ctx[name]);\n    var result = method.apply(this, arguments);\n    return result === undefined ? this : result;\n  };\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/addMethod.js\n ** module id = 41\n ** module chunks = 1\n **/","/*!\n * Chai - overwriteProperty utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### overwriteProperty (ctx, name, fn)\n *\n * Overwites an already existing property getter and provides\n * access to previous value. Must return function to use as getter.\n *\n *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {\n *       return function () {\n *         var obj = utils.flag(this, 'object');\n *         if (obj instanceof Foo) {\n *           new chai.Assertion(obj.name).to.equal('bar');\n *         } else {\n *           _super.call(this);\n *         }\n *       }\n *     });\n *\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.overwriteProperty('foo', fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.be.ok;\n *\n * @param {Object} ctx object whose property is to be overwritten\n * @param {String} name of property to overwrite\n * @param {Function} getter function that returns a getter function to be used for name\n * @name overwriteProperty\n * @api public\n */\n\nmodule.exports = function (ctx, name, getter) {\n  var _get = Object.getOwnPropertyDescriptor(ctx, name)\n    , _super = function () {};\n\n  if (_get && 'function' === typeof _get.get)\n    _super = _get.get\n\n  Object.defineProperty(ctx, name,\n    { get: function () {\n        var result = getter(_super).call(this);\n        return result === undefined ? this : result;\n      }\n    , configurable: true\n  });\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/overwriteProperty.js\n ** module id = 42\n ** module chunks = 1\n **/","/*!\n * Chai - overwriteMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### overwriteMethod (ctx, name, fn)\n *\n * Overwites an already existing method and provides\n * access to previous function. Must return function\n * to be used for name.\n *\n *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {\n *       return function (str) {\n *         var obj = utils.flag(this, 'object');\n *         if (obj instanceof Foo) {\n *           new chai.Assertion(obj.value).to.equal(str);\n *         } else {\n *           _super.apply(this, arguments);\n *         }\n *       }\n *     });\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.overwriteMethod('foo', fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.equal('bar');\n *\n * @param {Object} ctx object whose method is to be overwritten\n * @param {String} name of method to overwrite\n * @param {Function} method function that returns a function to be used for name\n * @name overwriteMethod\n * @api public\n */\n\nmodule.exports = function (ctx, name, method) {\n  var _method = ctx[name]\n    , _super = function () { return this; };\n\n  if (_method && 'function' === typeof _method)\n    _super = _method;\n\n  ctx[name] = function () {\n    var result = method(_super).apply(this, arguments);\n    return result === undefined ? this : result;\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/overwriteMethod.js\n ** module id = 43\n ** module chunks = 1\n **/","/*!\n * Chai - addChainingMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependencies\n */\n\nvar transferFlags = require('./transferFlags');\nvar flag = require('./flag');\nvar config = require('../config');\n\n/*!\n * Module variables\n */\n\n// Check whether `__proto__` is supported\nvar hasProtoSupport = '__proto__' in Object;\n\n// Without `__proto__` support, this module will need to add properties to a function.\n// However, some Function.prototype methods cannot be overwritten,\n// and there seems no easy cross-platform way to detect them (@see chaijs/chai/issues/69).\nvar excludeNames = /^(?:length|name|arguments|caller)$/;\n\n// Cache `Function` properties\nvar call  = Function.prototype.call,\n    apply = Function.prototype.apply;\n\n/**\n * ### addChainableMethod (ctx, name, method, chainingBehavior)\n *\n * Adds a method to an object, such that the method can also be chained.\n *\n *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {\n *       var obj = utils.flag(this, 'object');\n *       new chai.Assertion(obj).to.be.equal(str);\n *     });\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);\n *\n * The result can then be used as both a method assertion, executing both `method` and\n * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.\n *\n *     expect(fooStr).to.be.foo('bar');\n *     expect(fooStr).to.be.foo.equal('foo');\n *\n * @param {Object} ctx object to which the method is added\n * @param {String} name of method to add\n * @param {Function} method function to be used for `name`, when called\n * @param {Function} chainingBehavior function to be called every time the property is accessed\n * @name addChainableMethod\n * @api public\n */\n\nmodule.exports = function (ctx, name, method, chainingBehavior) {\n  if (typeof chainingBehavior !== 'function') {\n    chainingBehavior = function () { };\n  }\n\n  var chainableBehavior = {\n      method: method\n    , chainingBehavior: chainingBehavior\n  };\n\n  // save the methods so we can overwrite them later, if we need to.\n  if (!ctx.__methods) {\n    ctx.__methods = {};\n  }\n  ctx.__methods[name] = chainableBehavior;\n\n  Object.defineProperty(ctx, name,\n    { get: function () {\n        chainableBehavior.chainingBehavior.call(this);\n\n        var assert = function assert() {\n          var old_ssfi = flag(this, 'ssfi');\n          if (old_ssfi && config.includeStack === false)\n            flag(this, 'ssfi', assert);\n          var result = chainableBehavior.method.apply(this, arguments);\n          return result === undefined ? this : result;\n        };\n\n        // Use `__proto__` if available\n        if (hasProtoSupport) {\n          // Inherit all properties from the object by replacing the `Function` prototype\n          var prototype = assert.__proto__ = Object.create(this);\n          // Restore the `call` and `apply` methods from `Function`\n          prototype.call = call;\n          prototype.apply = apply;\n        }\n        // Otherwise, redefine all properties (slow!)\n        else {\n          var asserterNames = Object.getOwnPropertyNames(ctx);\n          asserterNames.forEach(function (asserterName) {\n            if (!excludeNames.test(asserterName)) {\n              var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);\n              Object.defineProperty(assert, asserterName, pd);\n            }\n          });\n        }\n\n        transferFlags(this, assert);\n        return assert;\n      }\n    , configurable: true\n  });\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/addChainableMethod.js\n ** module id = 44\n ** module chunks = 1\n **/","/*!\n * Chai - overwriteChainableMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### overwriteChainableMethod (ctx, name, method, chainingBehavior)\n *\n * Overwites an already existing chainable method\n * and provides access to the previous function or\n * property.  Must return functions to be used for\n * name.\n *\n *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'length',\n *       function (_super) {\n *       }\n *     , function (_super) {\n *       }\n *     );\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.have.length(3);\n *     expect(myFoo).to.have.length.above(3);\n *\n * @param {Object} ctx object whose method / property is to be overwritten\n * @param {String} name of method / property to overwrite\n * @param {Function} method function that returns a function to be used for name\n * @param {Function} chainingBehavior function that returns a function to be used for property\n * @name overwriteChainableMethod\n * @api public\n */\n\nmodule.exports = function (ctx, name, method, chainingBehavior) {\n  var chainableBehavior = ctx.__methods[name];\n\n  var _chainingBehavior = chainableBehavior.chainingBehavior;\n  chainableBehavior.chainingBehavior = function () {\n    var result = chainingBehavior(_chainingBehavior).call(this);\n    return result === undefined ? this : result;\n  };\n\n  var _method = chainableBehavior.method;\n  chainableBehavior.method = function () {\n    var result = method(_method).apply(this, arguments);\n    return result === undefined ? this : result;\n  };\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/utils/overwriteChainableMethod.js\n ** module id = 45\n ** module chunks = 1\n **/","/*!\n * chai\n * http://chaijs.com\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar config = require('./config');\n\nmodule.exports = function (_chai, util) {\n  /*!\n   * Module dependencies.\n   */\n\n  var AssertionError = _chai.AssertionError\n    , flag = util.flag;\n\n  /*!\n   * Module export.\n   */\n\n  _chai.Assertion = Assertion;\n\n  /*!\n   * Assertion Constructor\n   *\n   * Creates object for chaining.\n   *\n   * @api private\n   */\n\n  function Assertion (obj, msg, stack) {\n    flag(this, 'ssfi', stack || arguments.callee);\n    flag(this, 'object', obj);\n    flag(this, 'message', msg);\n  }\n\n  Object.defineProperty(Assertion, 'includeStack', {\n    get: function() {\n      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');\n      return config.includeStack;\n    },\n    set: function(value) {\n      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');\n      config.includeStack = value;\n    }\n  });\n\n  Object.defineProperty(Assertion, 'showDiff', {\n    get: function() {\n      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');\n      return config.showDiff;\n    },\n    set: function(value) {\n      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');\n      config.showDiff = value;\n    }\n  });\n\n  Assertion.addProperty = function (name, fn) {\n    util.addProperty(this.prototype, name, fn);\n  };\n\n  Assertion.addMethod = function (name, fn) {\n    util.addMethod(this.prototype, name, fn);\n  };\n\n  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {\n    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);\n  };\n\n  Assertion.overwriteProperty = function (name, fn) {\n    util.overwriteProperty(this.prototype, name, fn);\n  };\n\n  Assertion.overwriteMethod = function (name, fn) {\n    util.overwriteMethod(this.prototype, name, fn);\n  };\n\n  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {\n    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);\n  };\n\n  /**\n   * ### .assert(expression, message, negateMessage, expected, actual, showDiff)\n   *\n   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.\n   *\n   * @name assert\n   * @param {Philosophical} expression to be tested\n   * @param {String|Function} message or function that returns message to display if expression fails\n   * @param {String|Function} negatedMessage or function that returns negatedMessage to display if negated expression fails\n   * @param {Mixed} expected value (remember to check for negation)\n   * @param {Mixed} actual (optional) will default to `this.obj`\n   * @param {Boolean} showDiff (optional) when set to `true`, assert will display a diff in addition to the message if expression fails\n   * @api private\n   */\n\n  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {\n    var ok = util.test(this, arguments);\n    if (true !== showDiff) showDiff = false;\n    if (true !== config.showDiff) showDiff = false;\n\n    if (!ok) {\n      var msg = util.getMessage(this, arguments)\n        , actual = util.getActual(this, arguments);\n      throw new AssertionError(msg, {\n          actual: actual\n        , expected: expected\n        , showDiff: showDiff\n      }, (config.includeStack) ? this.assert : flag(this, 'ssfi'));\n    }\n  };\n\n  /*!\n   * ### ._obj\n   *\n   * Quick reference to stored `actual` value for plugin developers.\n   *\n   * @api private\n   */\n\n  Object.defineProperty(Assertion.prototype, '_obj',\n    { get: function () {\n        return flag(this, 'object');\n      }\n    , set: function (val) {\n        flag(this, 'object', val);\n      }\n  });\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/assertion.js\n ** module id = 46\n ** module chunks = 1\n **/","/*!\n * chai\n * http://chaijs.com\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nmodule.exports = function (chai, _) {\n  var Assertion = chai.Assertion\n    , toString = Object.prototype.toString\n    , flag = _.flag;\n\n  /**\n   * ### Language Chains\n   *\n   * The following are provided as chainable getters to\n   * improve the readability of your assertions. They\n   * do not provide testing capabilities unless they\n   * have been overwritten by a plugin.\n   *\n   * **Chains**\n   *\n   * - to\n   * - be\n   * - been\n   * - is\n   * - that\n   * - which\n   * - and\n   * - has\n   * - have\n   * - with\n   * - at\n   * - of\n   * - same\n   *\n   * @name language chains\n   * @api public\n   */\n\n  [ 'to', 'be', 'been'\n  , 'is', 'and', 'has', 'have'\n  , 'with', 'that', 'which', 'at'\n  , 'of', 'same' ].forEach(function (chain) {\n    Assertion.addProperty(chain, function () {\n      return this;\n    });\n  });\n\n  /**\n   * ### .not\n   *\n   * Negates any of assertions following in the chain.\n   *\n   *     expect(foo).to.not.equal('bar');\n   *     expect(goodFn).to.not.throw(Error);\n   *     expect({ foo: 'baz' }).to.have.property('foo')\n   *       .and.not.equal('bar');\n   *\n   * @name not\n   * @api public\n   */\n\n  Assertion.addProperty('not', function () {\n    flag(this, 'negate', true);\n  });\n\n  /**\n   * ### .deep\n   *\n   * Sets the `deep` flag, later used by the `equal` and\n   * `property` assertions.\n   *\n   *     expect(foo).to.deep.equal({ bar: 'baz' });\n   *     expect({ foo: { bar: { baz: 'quux' } } })\n   *       .to.have.deep.property('foo.bar.baz', 'quux');\n   *\n   * `.deep.property` special characters can be escaped\n   * by adding two slashes before the `.` or `[]`.\n   *\n   *     var deepCss = { '.link': { '[target]': 42 }};\n   *     expect(deepCss).to.have.deep.property('\\\\.link.\\\\[target\\\\]', 42);\n   *\n   * @name deep\n   * @api public\n   */\n\n  Assertion.addProperty('deep', function () {\n    flag(this, 'deep', true);\n  });\n\n  /**\n   * ### .any\n   *\n   * Sets the `any` flag, (opposite of the `all` flag)\n   * later used in the `keys` assertion.\n   *\n   *     expect(foo).to.have.any.keys('bar', 'baz');\n   *\n   * @name any\n   * @api public\n   */\n\n  Assertion.addProperty('any', function () {\n    flag(this, 'any', true);\n    flag(this, 'all', false)\n  });\n\n\n  /**\n   * ### .all\n   *\n   * Sets the `all` flag (opposite of the `any` flag)\n   * later used by the `keys` assertion.\n   *\n   *     expect(foo).to.have.all.keys('bar', 'baz');\n   *\n   * @name all\n   * @api public\n   */\n\n  Assertion.addProperty('all', function () {\n    flag(this, 'all', true);\n    flag(this, 'any', false);\n  });\n\n  /**\n   * ### .a(type)\n   *\n   * The `a` and `an` assertions are aliases that can be\n   * used either as language chains or to assert a value's\n   * type.\n   *\n   *     // typeof\n   *     expect('test').to.be.a('string');\n   *     expect({ foo: 'bar' }).to.be.an('object');\n   *     expect(null).to.be.a('null');\n   *     expect(undefined).to.be.an('undefined');\n   *     expect(new Error).to.be.an('error');\n   *     expect(new Promise).to.be.a('promise');\n   *     expect(new Float32Array()).to.be.a('float32array');\n   *     expect(Symbol()).to.be.a('symbol');\n   *\n   *     // es6 overrides\n   *     expect({[Symbol.toStringTag]:()=>'foo'}).to.be.a('foo');\n   *\n   *     // language chain\n   *     expect(foo).to.be.an.instanceof(Foo);\n   *\n   * @name a\n   * @alias an\n   * @param {String} type\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function an (type, msg) {\n    if (msg) flag(this, 'message', msg);\n    type = type.toLowerCase();\n    var obj = flag(this, 'object')\n      , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';\n\n    this.assert(\n        type === _.type(obj)\n      , 'expected #{this} to be ' + article + type\n      , 'expected #{this} not to be ' + article + type\n    );\n  }\n\n  Assertion.addChainableMethod('an', an);\n  Assertion.addChainableMethod('a', an);\n\n  /**\n   * ### .include(value)\n   *\n   * The `include` and `contain` assertions can be used as either property\n   * based language chains or as methods to assert the inclusion of an object\n   * in an array or a substring in a string. When used as language chains,\n   * they toggle the `contains` flag for the `keys` assertion.\n   *\n   *     expect([1,2,3]).to.include(2);\n   *     expect('foobar').to.contain('foo');\n   *     expect({ foo: 'bar', hello: 'universe' }).to.include.keys('foo');\n   *\n   * @name include\n   * @alias contain\n   * @alias includes\n   * @alias contains\n   * @param {Object|String|Number} obj\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function includeChainingBehavior () {\n    flag(this, 'contains', true);\n  }\n\n  function include (val, msg) {\n    _.expectTypes(this, ['array', 'object', 'string']);\n\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    var expected = false;\n\n    if (_.type(obj) === 'array' && _.type(val) === 'object') {\n      for (var i in obj) {\n        if (_.eql(obj[i], val)) {\n          expected = true;\n          break;\n        }\n      }\n    } else if (_.type(val) === 'object') {\n      if (!flag(this, 'negate')) {\n        for (var k in val) new Assertion(obj).property(k, val[k]);\n        return;\n      }\n      var subset = {};\n      for (var k in val) subset[k] = obj[k];\n      expected = _.eql(subset, val);\n    } else {\n      expected = (obj != undefined) && ~obj.indexOf(val);\n    }\n    this.assert(\n        expected\n      , 'expected #{this} to include ' + _.inspect(val)\n      , 'expected #{this} to not include ' + _.inspect(val));\n  }\n\n  Assertion.addChainableMethod('include', include, includeChainingBehavior);\n  Assertion.addChainableMethod('contain', include, includeChainingBehavior);\n  Assertion.addChainableMethod('contains', include, includeChainingBehavior);\n  Assertion.addChainableMethod('includes', include, includeChainingBehavior);\n\n  /**\n   * ### .ok\n   *\n   * Asserts that the target is truthy.\n   *\n   *     expect('everything').to.be.ok;\n   *     expect(1).to.be.ok;\n   *     expect(false).to.not.be.ok;\n   *     expect(undefined).to.not.be.ok;\n   *     expect(null).to.not.be.ok;\n   *\n   * @name ok\n   * @api public\n   */\n\n  Assertion.addProperty('ok', function () {\n    this.assert(\n        flag(this, 'object')\n      , 'expected #{this} to be truthy'\n      , 'expected #{this} to be falsy');\n  });\n\n  /**\n   * ### .true\n   *\n   * Asserts that the target is `true`.\n   *\n   *     expect(true).to.be.true;\n   *     expect(1).to.not.be.true;\n   *\n   * @name true\n   * @api public\n   */\n\n  Assertion.addProperty('true', function () {\n    this.assert(\n        true === flag(this, 'object')\n      , 'expected #{this} to be true'\n      , 'expected #{this} to be false'\n      , this.negate ? false : true\n    );\n  });\n\n  /**\n   * ### .false\n   *\n   * Asserts that the target is `false`.\n   *\n   *     expect(false).to.be.false;\n   *     expect(0).to.not.be.false;\n   *\n   * @name false\n   * @api public\n   */\n\n  Assertion.addProperty('false', function () {\n    this.assert(\n        false === flag(this, 'object')\n      , 'expected #{this} to be false'\n      , 'expected #{this} to be true'\n      , this.negate ? true : false\n    );\n  });\n\n  /**\n   * ### .null\n   *\n   * Asserts that the target is `null`.\n   *\n   *     expect(null).to.be.null;\n   *     expect(undefined).to.not.be.null;\n   *\n   * @name null\n   * @api public\n   */\n\n  Assertion.addProperty('null', function () {\n    this.assert(\n        null === flag(this, 'object')\n      , 'expected #{this} to be null'\n      , 'expected #{this} not to be null'\n    );\n  });\n\n  /**\n   * ### .undefined\n   *\n   * Asserts that the target is `undefined`.\n   *\n   *     expect(undefined).to.be.undefined;\n   *     expect(null).to.not.be.undefined;\n   *\n   * @name undefined\n   * @api public\n   */\n\n  Assertion.addProperty('undefined', function () {\n    this.assert(\n        undefined === flag(this, 'object')\n      , 'expected #{this} to be undefined'\n      , 'expected #{this} not to be undefined'\n    );\n  });\n\n  /**\n   * ### .NaN\n   * Asserts that the target is `NaN`.\n   *\n   *     expect('foo').to.be.NaN;\n   *     expect(4).not.to.be.NaN;\n   *\n   * @name NaN\n   * @api public\n   */\n\n  Assertion.addProperty('NaN', function () {\n    this.assert(\n        isNaN(flag(this, 'object'))\n        , 'expected #{this} to be NaN'\n        , 'expected #{this} not to be NaN'\n    );\n  });\n\n  /**\n   * ### .exist\n   *\n   * Asserts that the target is neither `null` nor `undefined`.\n   *\n   *     var foo = 'hi'\n   *       , bar = null\n   *       , baz;\n   *\n   *     expect(foo).to.exist;\n   *     expect(bar).to.not.exist;\n   *     expect(baz).to.not.exist;\n   *\n   * @name exist\n   * @api public\n   */\n\n  Assertion.addProperty('exist', function () {\n    this.assert(\n        null != flag(this, 'object')\n      , 'expected #{this} to exist'\n      , 'expected #{this} to not exist'\n    );\n  });\n\n\n  /**\n   * ### .empty\n   *\n   * Asserts that the target's length is `0`. For arrays and strings, it checks\n   * the `length` property. For objects, it gets the count of\n   * enumerable keys.\n   *\n   *     expect([]).to.be.empty;\n   *     expect('').to.be.empty;\n   *     expect({}).to.be.empty;\n   *\n   * @name empty\n   * @api public\n   */\n\n  Assertion.addProperty('empty', function () {\n    var obj = flag(this, 'object')\n      , expected = obj;\n\n    if (Array.isArray(obj) || 'string' === typeof object) {\n      expected = obj.length;\n    } else if (typeof obj === 'object') {\n      expected = Object.keys(obj).length;\n    }\n\n    this.assert(\n        !expected\n      , 'expected #{this} to be empty'\n      , 'expected #{this} not to be empty'\n    );\n  });\n\n  /**\n   * ### .arguments\n   *\n   * Asserts that the target is an arguments object.\n   *\n   *     function test () {\n   *       expect(arguments).to.be.arguments;\n   *     }\n   *\n   * @name arguments\n   * @alias Arguments\n   * @api public\n   */\n\n  function checkArguments () {\n    var obj = flag(this, 'object')\n      , type = Object.prototype.toString.call(obj);\n    this.assert(\n        '[object Arguments]' === type\n      , 'expected #{this} to be arguments but got ' + type\n      , 'expected #{this} to not be arguments'\n    );\n  }\n\n  Assertion.addProperty('arguments', checkArguments);\n  Assertion.addProperty('Arguments', checkArguments);\n\n  /**\n   * ### .equal(value)\n   *\n   * Asserts that the target is strictly equal (`===`) to `value`.\n   * Alternately, if the `deep` flag is set, asserts that\n   * the target is deeply equal to `value`.\n   *\n   *     expect('hello').to.equal('hello');\n   *     expect(42).to.equal(42);\n   *     expect(1).to.not.equal(true);\n   *     expect({ foo: 'bar' }).to.not.equal({ foo: 'bar' });\n   *     expect({ foo: 'bar' }).to.deep.equal({ foo: 'bar' });\n   *\n   * @name equal\n   * @alias equals\n   * @alias eq\n   * @alias deep.equal\n   * @param {Mixed} value\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertEqual (val, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    if (flag(this, 'deep')) {\n      return this.eql(val);\n    } else {\n      this.assert(\n          val === obj\n        , 'expected #{this} to equal #{exp}'\n        , 'expected #{this} to not equal #{exp}'\n        , val\n        , this._obj\n        , true\n      );\n    }\n  }\n\n  Assertion.addMethod('equal', assertEqual);\n  Assertion.addMethod('equals', assertEqual);\n  Assertion.addMethod('eq', assertEqual);\n\n  /**\n   * ### .eql(value)\n   *\n   * Asserts that the target is deeply equal to `value`.\n   *\n   *     expect({ foo: 'bar' }).to.eql({ foo: 'bar' });\n   *     expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);\n   *\n   * @name eql\n   * @alias eqls\n   * @param {Mixed} value\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertEql(obj, msg) {\n    if (msg) flag(this, 'message', msg);\n    this.assert(\n        _.eql(obj, flag(this, 'object'))\n      , 'expected #{this} to deeply equal #{exp}'\n      , 'expected #{this} to not deeply equal #{exp}'\n      , obj\n      , this._obj\n      , true\n    );\n  }\n\n  Assertion.addMethod('eql', assertEql);\n  Assertion.addMethod('eqls', assertEql);\n\n  /**\n   * ### .above(value)\n   *\n   * Asserts that the target is greater than `value`.\n   *\n   *     expect(10).to.be.above(5);\n   *\n   * Can also be used in conjunction with `length` to\n   * assert a minimum length. The benefit being a\n   * more informative error message than if the length\n   * was supplied directly.\n   *\n   *     expect('foo').to.have.length.above(2);\n   *     expect([ 1, 2, 3 ]).to.have.length.above(2);\n   *\n   * @name above\n   * @alias gt\n   * @alias greaterThan\n   * @param {Number} value\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertAbove (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    if (flag(this, 'doLength')) {\n      new Assertion(obj, msg).to.have.property('length');\n      var len = obj.length;\n      this.assert(\n          len > n\n        , 'expected #{this} to have a length above #{exp} but got #{act}'\n        , 'expected #{this} to not have a length above #{exp}'\n        , n\n        , len\n      );\n    } else {\n      this.assert(\n          obj > n\n        , 'expected #{this} to be above ' + n\n        , 'expected #{this} to be at most ' + n\n      );\n    }\n  }\n\n  Assertion.addMethod('above', assertAbove);\n  Assertion.addMethod('gt', assertAbove);\n  Assertion.addMethod('greaterThan', assertAbove);\n\n  /**\n   * ### .least(value)\n   *\n   * Asserts that the target is greater than or equal to `value`.\n   *\n   *     expect(10).to.be.at.least(10);\n   *\n   * Can also be used in conjunction with `length` to\n   * assert a minimum length. The benefit being a\n   * more informative error message than if the length\n   * was supplied directly.\n   *\n   *     expect('foo').to.have.length.of.at.least(2);\n   *     expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);\n   *\n   * @name least\n   * @alias gte\n   * @param {Number} value\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertLeast (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    if (flag(this, 'doLength')) {\n      new Assertion(obj, msg).to.have.property('length');\n      var len = obj.length;\n      this.assert(\n          len >= n\n        , 'expected #{this} to have a length at least #{exp} but got #{act}'\n        , 'expected #{this} to have a length below #{exp}'\n        , n\n        , len\n      );\n    } else {\n      this.assert(\n          obj >= n\n        , 'expected #{this} to be at least ' + n\n        , 'expected #{this} to be below ' + n\n      );\n    }\n  }\n\n  Assertion.addMethod('least', assertLeast);\n  Assertion.addMethod('gte', assertLeast);\n\n  /**\n   * ### .below(value)\n   *\n   * Asserts that the target is less than `value`.\n   *\n   *     expect(5).to.be.below(10);\n   *\n   * Can also be used in conjunction with `length` to\n   * assert a maximum length. The benefit being a\n   * more informative error message than if the length\n   * was supplied directly.\n   *\n   *     expect('foo').to.have.length.below(4);\n   *     expect([ 1, 2, 3 ]).to.have.length.below(4);\n   *\n   * @name below\n   * @alias lt\n   * @alias lessThan\n   * @param {Number} value\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertBelow (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    if (flag(this, 'doLength')) {\n      new Assertion(obj, msg).to.have.property('length');\n      var len = obj.length;\n      this.assert(\n          len < n\n        , 'expected #{this} to have a length below #{exp} but got #{act}'\n        , 'expected #{this} to not have a length below #{exp}'\n        , n\n        , len\n      );\n    } else {\n      this.assert(\n          obj < n\n        , 'expected #{this} to be below ' + n\n        , 'expected #{this} to be at least ' + n\n      );\n    }\n  }\n\n  Assertion.addMethod('below', assertBelow);\n  Assertion.addMethod('lt', assertBelow);\n  Assertion.addMethod('lessThan', assertBelow);\n\n  /**\n   * ### .most(value)\n   *\n   * Asserts that the target is less than or equal to `value`.\n   *\n   *     expect(5).to.be.at.most(5);\n   *\n   * Can also be used in conjunction with `length` to\n   * assert a maximum length. The benefit being a\n   * more informative error message than if the length\n   * was supplied directly.\n   *\n   *     expect('foo').to.have.length.of.at.most(4);\n   *     expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);\n   *\n   * @name most\n   * @alias lte\n   * @param {Number} value\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertMost (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    if (flag(this, 'doLength')) {\n      new Assertion(obj, msg).to.have.property('length');\n      var len = obj.length;\n      this.assert(\n          len <= n\n        , 'expected #{this} to have a length at most #{exp} but got #{act}'\n        , 'expected #{this} to have a length above #{exp}'\n        , n\n        , len\n      );\n    } else {\n      this.assert(\n          obj <= n\n        , 'expected #{this} to be at most ' + n\n        , 'expected #{this} to be above ' + n\n      );\n    }\n  }\n\n  Assertion.addMethod('most', assertMost);\n  Assertion.addMethod('lte', assertMost);\n\n  /**\n   * ### .within(start, finish)\n   *\n   * Asserts that the target is within a range.\n   *\n   *     expect(7).to.be.within(5,10);\n   *\n   * Can also be used in conjunction with `length` to\n   * assert a length range. The benefit being a\n   * more informative error message than if the length\n   * was supplied directly.\n   *\n   *     expect('foo').to.have.length.within(2,4);\n   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);\n   *\n   * @name within\n   * @param {Number} start lowerbound inclusive\n   * @param {Number} finish upperbound inclusive\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  Assertion.addMethod('within', function (start, finish, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , range = start + '..' + finish;\n    if (flag(this, 'doLength')) {\n      new Assertion(obj, msg).to.have.property('length');\n      var len = obj.length;\n      this.assert(\n          len >= start && len <= finish\n        , 'expected #{this} to have a length within ' + range\n        , 'expected #{this} to not have a length within ' + range\n      );\n    } else {\n      this.assert(\n          obj >= start && obj <= finish\n        , 'expected #{this} to be within ' + range\n        , 'expected #{this} to not be within ' + range\n      );\n    }\n  });\n\n  /**\n   * ### .instanceof(constructor)\n   *\n   * Asserts that the target is an instance of `constructor`.\n   *\n   *     var Tea = function (name) { this.name = name; }\n   *       , Chai = new Tea('chai');\n   *\n   *     expect(Chai).to.be.an.instanceof(Tea);\n   *     expect([ 1, 2, 3 ]).to.be.instanceof(Array);\n   *\n   * @name instanceof\n   * @param {Constructor} constructor\n   * @param {String} message _optional_\n   * @alias instanceOf\n   * @api public\n   */\n\n  function assertInstanceOf (constructor, msg) {\n    if (msg) flag(this, 'message', msg);\n    var name = _.getName(constructor);\n    this.assert(\n        flag(this, 'object') instanceof constructor\n      , 'expected #{this} to be an instance of ' + name\n      , 'expected #{this} to not be an instance of ' + name\n    );\n  };\n\n  Assertion.addMethod('instanceof', assertInstanceOf);\n  Assertion.addMethod('instanceOf', assertInstanceOf);\n\n  /**\n   * ### .property(name, [value])\n   *\n   * Asserts that the target has a property `name`, optionally asserting that\n   * the value of that property is strictly equal to  `value`.\n   * If the `deep` flag is set, you can use dot- and bracket-notation for deep\n   * references into objects and arrays.\n   *\n   *     // simple referencing\n   *     var obj = { foo: 'bar' };\n   *     expect(obj).to.have.property('foo');\n   *     expect(obj).to.have.property('foo', 'bar');\n   *\n   *     // deep referencing\n   *     var deepObj = {\n   *         green: { tea: 'matcha' }\n   *       , teas: [ 'chai', 'matcha', { tea: 'konacha' } ]\n   *     };\n   *\n   *     expect(deepObj).to.have.deep.property('green.tea', 'matcha');\n   *     expect(deepObj).to.have.deep.property('teas[1]', 'matcha');\n   *     expect(deepObj).to.have.deep.property('teas[2].tea', 'konacha');\n   *\n   * You can also use an array as the starting point of a `deep.property`\n   * assertion, or traverse nested arrays.\n   *\n   *     var arr = [\n   *         [ 'chai', 'matcha', 'konacha' ]\n   *       , [ { tea: 'chai' }\n   *         , { tea: 'matcha' }\n   *         , { tea: 'konacha' } ]\n   *     ];\n   *\n   *     expect(arr).to.have.deep.property('[0][1]', 'matcha');\n   *     expect(arr).to.have.deep.property('[1][2].tea', 'konacha');\n   *\n   * Furthermore, `property` changes the subject of the assertion\n   * to be the value of that property from the original object. This\n   * permits for further chainable assertions on that property.\n   *\n   *     expect(obj).to.have.property('foo')\n   *       .that.is.a('string');\n   *     expect(deepObj).to.have.property('green')\n   *       .that.is.an('object')\n   *       .that.deep.equals({ tea: 'matcha' });\n   *     expect(deepObj).to.have.property('teas')\n   *       .that.is.an('array')\n   *       .with.deep.property('[2]')\n   *         .that.deep.equals({ tea: 'konacha' });\n   *\n   * Note that dots and bracket in `name` must be backslash-escaped when\n   * the `deep` flag is set, while they must NOT be escaped when the `deep`\n   * flag is not set.\n   *\n   *     // simple referencing\n   *     var css = { '.link[target]': 42 };\n   *     expect(css).to.have.property('.link[target]', 42);\n   *\n   *     // deep referencing\n   *     var deepCss = { '.link': { '[target]': 42 }};\n   *     expect(deepCss).to.have.deep.property('\\\\.link.\\\\[target\\\\]', 42);\n   *\n   * @name property\n   * @alias deep.property\n   * @param {String} name\n   * @param {Mixed} value (optional)\n   * @param {String} message _optional_\n   * @returns value of property for chaining\n   * @api public\n   */\n\n  Assertion.addMethod('property', function (name, val, msg) {\n    if (msg) flag(this, 'message', msg);\n\n    var isDeep = !!flag(this, 'deep')\n      , descriptor = isDeep ? 'deep property ' : 'property '\n      , negate = flag(this, 'negate')\n      , obj = flag(this, 'object')\n      , pathInfo = isDeep ? _.getPathInfo(name, obj) : null\n      , hasProperty = isDeep\n        ? pathInfo.exists\n        : _.hasProperty(name, obj)\n      , value = isDeep\n        ? pathInfo.value\n        : obj[name];\n\n    if (negate && arguments.length > 1) {\n      if (undefined === value) {\n        msg = (msg != null) ? msg + ': ' : '';\n        throw new Error(msg + _.inspect(obj) + ' has no ' + descriptor + _.inspect(name));\n      }\n    } else {\n      this.assert(\n          hasProperty\n        , 'expected #{this} to have a ' + descriptor + _.inspect(name)\n        , 'expected #{this} to not have ' + descriptor + _.inspect(name));\n    }\n\n    if (arguments.length > 1) {\n      this.assert(\n          val === value\n        , 'expected #{this} to have a ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'\n        , 'expected #{this} to not have a ' + descriptor + _.inspect(name) + ' of #{act}'\n        , val\n        , value\n      );\n    }\n\n    flag(this, 'object', value);\n  });\n\n\n  /**\n   * ### .ownProperty(name)\n   *\n   * Asserts that the target has an own property `name`.\n   *\n   *     expect('test').to.have.ownProperty('length');\n   *\n   * @name ownProperty\n   * @alias haveOwnProperty\n   * @param {String} name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertOwnProperty (name, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    this.assert(\n        obj.hasOwnProperty(name)\n      , 'expected #{this} to have own property ' + _.inspect(name)\n      , 'expected #{this} to not have own property ' + _.inspect(name)\n    );\n  }\n\n  Assertion.addMethod('ownProperty', assertOwnProperty);\n  Assertion.addMethod('haveOwnProperty', assertOwnProperty);\n\n  /**\n   * ### .ownPropertyDescriptor(name[, descriptor[, message]])\n   *\n   * Asserts that the target has an own property descriptor `name`, that optionally matches `descriptor`.\n   *\n   *     expect('test').to.have.ownPropertyDescriptor('length');\n   *     expect('test').to.have.ownPropertyDescriptor('length', { enumerable: false, configurable: false, writable: false, value: 4 });\n   *     expect('test').not.to.have.ownPropertyDescriptor('length', { enumerable: false, configurable: false, writable: false, value: 3 });\n   *     expect('test').ownPropertyDescriptor('length').to.have.property('enumerable', false);\n   *     expect('test').ownPropertyDescriptor('length').to.have.keys('value');\n   *\n   * @name ownPropertyDescriptor\n   * @alias haveOwnPropertyDescriptor\n   * @param {String} name\n   * @param {Object} descriptor _optional_\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertOwnPropertyDescriptor (name, descriptor, msg) {\n    if (typeof descriptor === 'string') {\n      msg = descriptor;\n      descriptor = null;\n    }\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    var actualDescriptor = Object.getOwnPropertyDescriptor(Object(obj), name);\n    if (actualDescriptor && descriptor) {\n      this.assert(\n          _.eql(descriptor, actualDescriptor)\n        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to match ' + _.inspect(descriptor) + ', got ' + _.inspect(actualDescriptor)\n        , 'expected the own property descriptor for ' + _.inspect(name) + ' on #{this} to not match ' + _.inspect(descriptor)\n        , descriptor\n        , actualDescriptor\n        , true\n      );\n    } else {\n      this.assert(\n          actualDescriptor\n        , 'expected #{this} to have an own property descriptor for ' + _.inspect(name)\n        , 'expected #{this} to not have an own property descriptor for ' + _.inspect(name)\n      );\n    }\n    flag(this, 'object', actualDescriptor);\n  }\n\n  Assertion.addMethod('ownPropertyDescriptor', assertOwnPropertyDescriptor);\n  Assertion.addMethod('haveOwnPropertyDescriptor', assertOwnPropertyDescriptor);\n\n  /**\n   * ### .length\n   *\n   * Sets the `doLength` flag later used as a chain precursor to a value\n   * comparison for the `length` property.\n   *\n   *     expect('foo').to.have.length.above(2);\n   *     expect([ 1, 2, 3 ]).to.have.length.above(2);\n   *     expect('foo').to.have.length.below(4);\n   *     expect([ 1, 2, 3 ]).to.have.length.below(4);\n   *     expect('foo').to.have.length.within(2,4);\n   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);\n   *\n   * *Deprecation notice:* Using `length` as an assertion will be deprecated\n   * in version 2.4.0 and removed in 3.0.0. Code using the old style of\n   * asserting for `length` property value using `length(value)` should be\n   * switched to use `lengthOf(value)` instead.\n   *\n   * @name length\n   * @api public\n   */\n\n  /**\n   * ### .lengthOf(value[, message])\n   *\n   * Asserts that the target's `length` property has\n   * the expected value.\n   *\n   *     expect([ 1, 2, 3]).to.have.lengthOf(3);\n   *     expect('foobar').to.have.lengthOf(6);\n   *\n   * @name lengthOf\n   * @param {Number} length\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertLengthChain () {\n    flag(this, 'doLength', true);\n  }\n\n  function assertLength (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    new Assertion(obj, msg).to.have.property('length');\n    var len = obj.length;\n\n    this.assert(\n        len == n\n      , 'expected #{this} to have a length of #{exp} but got #{act}'\n      , 'expected #{this} to not have a length of #{act}'\n      , n\n      , len\n    );\n  }\n\n  Assertion.addChainableMethod('length', assertLength, assertLengthChain);\n  Assertion.addMethod('lengthOf', assertLength);\n\n  /**\n   * ### .match(regexp)\n   *\n   * Asserts that the target matches a regular expression.\n   *\n   *     expect('foobar').to.match(/^foo/);\n   *\n   * @name match\n   * @alias matches\n   * @param {RegExp} RegularExpression\n   * @param {String} message _optional_\n   * @api public\n   */\n  function assertMatch(re, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    this.assert(\n        re.exec(obj)\n      , 'expected #{this} to match ' + re\n      , 'expected #{this} not to match ' + re\n    );\n  }\n\n  Assertion.addMethod('match', assertMatch);\n  Assertion.addMethod('matches', assertMatch);\n\n  /**\n   * ### .string(string)\n   *\n   * Asserts that the string target contains another string.\n   *\n   *     expect('foobar').to.have.string('bar');\n   *\n   * @name string\n   * @param {String} string\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  Assertion.addMethod('string', function (str, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    new Assertion(obj, msg).is.a('string');\n\n    this.assert(\n        ~obj.indexOf(str)\n      , 'expected #{this} to contain ' + _.inspect(str)\n      , 'expected #{this} to not contain ' + _.inspect(str)\n    );\n  });\n\n\n  /**\n   * ### .keys(key1, [key2], [...])\n   *\n   * Asserts that the target contains any or all of the passed-in keys.\n   * Use in combination with `any`, `all`, `contains`, or `have` will affect\n   * what will pass.\n   *\n   * When used in conjunction with `any`, at least one key that is passed\n   * in must exist in the target object. This is regardless whether or not\n   * the `have` or `contain` qualifiers are used. Note, either `any` or `all`\n   * should be used in the assertion. If neither are used, the assertion is\n   * defaulted to `all`.\n   *\n   * When both `all` and `contain` are used, the target object must have at\n   * least all of the passed-in keys but may have more keys not listed.\n   *\n   * When both `all` and `have` are used, the target object must both contain\n   * all of the passed-in keys AND the number of keys in the target object must\n   * match the number of keys passed in (in other words, a target object must\n   * have all and only all of the passed-in keys).\n   *\n   *     expect({ foo: 1, bar: 2 }).to.have.any.keys('foo', 'baz');\n   *     expect({ foo: 1, bar: 2 }).to.have.any.keys('foo');\n   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys('bar', 'baz');\n   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys(['foo']);\n   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys({'foo': 6});\n   *     expect({ foo: 1, bar: 2 }).to.have.all.keys(['bar', 'foo']);\n   *     expect({ foo: 1, bar: 2 }).to.have.all.keys({'bar': 6, 'foo': 7});\n   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys(['bar', 'foo']);\n   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys({'bar': 6});\n   *\n   *\n   * @name keys\n   * @alias key\n   * @param {...String|Array|Object} keys\n   * @api public\n   */\n\n  function assertKeys (keys) {\n    var obj = flag(this, 'object')\n      , str\n      , ok = true\n      , mixedArgsMsg = 'keys must be given single argument of Array|Object|String, or multiple String arguments';\n\n    switch (_.type(keys)) {\n      case \"array\":\n        if (arguments.length > 1) throw (new Error(mixedArgsMsg));\n        break;\n      case \"object\":\n        if (arguments.length > 1) throw (new Error(mixedArgsMsg));\n        keys = Object.keys(keys);\n        break;\n      default:\n        keys = Array.prototype.slice.call(arguments);\n    }\n\n    if (!keys.length) throw new Error('keys required');\n\n    var actual = Object.keys(obj)\n      , expected = keys\n      , len = keys.length\n      , any = flag(this, 'any')\n      , all = flag(this, 'all');\n\n    if (!any && !all) {\n      all = true;\n    }\n\n    // Has any\n    if (any) {\n      var intersection = expected.filter(function(key) {\n        return ~actual.indexOf(key);\n      });\n      ok = intersection.length > 0;\n    }\n\n    // Has all\n    if (all) {\n      ok = keys.every(function(key){\n        return ~actual.indexOf(key);\n      });\n      if (!flag(this, 'negate') && !flag(this, 'contains')) {\n        ok = ok && keys.length == actual.length;\n      }\n    }\n\n    // Key string\n    if (len > 1) {\n      keys = keys.map(function(key){\n        return _.inspect(key);\n      });\n      var last = keys.pop();\n      if (all) {\n        str = keys.join(', ') + ', and ' + last;\n      }\n      if (any) {\n        str = keys.join(', ') + ', or ' + last;\n      }\n    } else {\n      str = _.inspect(keys[0]);\n    }\n\n    // Form\n    str = (len > 1 ? 'keys ' : 'key ') + str;\n\n    // Have / include\n    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;\n\n    // Assertion\n    this.assert(\n        ok\n      , 'expected #{this} to ' + str\n      , 'expected #{this} to not ' + str\n      , expected.slice(0).sort()\n      , actual.sort()\n      , true\n    );\n  }\n\n  Assertion.addMethod('keys', assertKeys);\n  Assertion.addMethod('key', assertKeys);\n\n  /**\n   * ### .throw(constructor)\n   *\n   * Asserts that the function target will throw a specific error, or specific type of error\n   * (as determined using `instanceof`), optionally with a RegExp or string inclusion test\n   * for the error's message.\n   *\n   *     var err = new ReferenceError('This is a bad function.');\n   *     var fn = function () { throw err; }\n   *     expect(fn).to.throw(ReferenceError);\n   *     expect(fn).to.throw(Error);\n   *     expect(fn).to.throw(/bad function/);\n   *     expect(fn).to.not.throw('good function');\n   *     expect(fn).to.throw(ReferenceError, /bad function/);\n   *     expect(fn).to.throw(err);\n   *\n   * Please note that when a throw expectation is negated, it will check each\n   * parameter independently, starting with error constructor type. The appropriate way\n   * to check for the existence of a type of error but for a message that does not match\n   * is to use `and`.\n   *\n   *     expect(fn).to.throw(ReferenceError)\n   *        .and.not.throw(/good function/);\n   *\n   * @name throw\n   * @alias throws\n   * @alias Throw\n   * @param {ErrorConstructor} constructor\n   * @param {String|RegExp} expected error message\n   * @param {String} message _optional_\n   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n   * @returns error for chaining (null if no error)\n   * @api public\n   */\n\n  function assertThrows (constructor, errMsg, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    new Assertion(obj, msg).is.a('function');\n\n    var thrown = false\n      , desiredError = null\n      , name = null\n      , thrownError = null;\n\n    if (arguments.length === 0) {\n      errMsg = null;\n      constructor = null;\n    } else if (constructor && (constructor instanceof RegExp || 'string' === typeof constructor)) {\n      errMsg = constructor;\n      constructor = null;\n    } else if (constructor && constructor instanceof Error) {\n      desiredError = constructor;\n      constructor = null;\n      errMsg = null;\n    } else if (typeof constructor === 'function') {\n      name = constructor.prototype.name;\n      if (!name || (name === 'Error' && constructor !== Error)) {\n        name = constructor.name || (new constructor()).name;\n      }\n    } else {\n      constructor = null;\n    }\n\n    try {\n      obj();\n    } catch (err) {\n      // first, check desired error\n      if (desiredError) {\n        this.assert(\n            err === desiredError\n          , 'expected #{this} to throw #{exp} but #{act} was thrown'\n          , 'expected #{this} to not throw #{exp}'\n          , (desiredError instanceof Error ? desiredError.toString() : desiredError)\n          , (err instanceof Error ? err.toString() : err)\n        );\n\n        flag(this, 'object', err);\n        return this;\n      }\n\n      // next, check constructor\n      if (constructor) {\n        this.assert(\n            err instanceof constructor\n          , 'expected #{this} to throw #{exp} but #{act} was thrown'\n          , 'expected #{this} to not throw #{exp} but #{act} was thrown'\n          , name\n          , (err instanceof Error ? err.toString() : err)\n        );\n\n        if (!errMsg) {\n          flag(this, 'object', err);\n          return this;\n        }\n      }\n\n      // next, check message\n      var message = 'error' === _.type(err) && \"message\" in err\n        ? err.message\n        : '' + err;\n\n      if ((message != null) && errMsg && errMsg instanceof RegExp) {\n        this.assert(\n            errMsg.exec(message)\n          , 'expected #{this} to throw error matching #{exp} but got #{act}'\n          , 'expected #{this} to throw error not matching #{exp}'\n          , errMsg\n          , message\n        );\n\n        flag(this, 'object', err);\n        return this;\n      } else if ((message != null) && errMsg && 'string' === typeof errMsg) {\n        this.assert(\n            ~message.indexOf(errMsg)\n          , 'expected #{this} to throw error including #{exp} but got #{act}'\n          , 'expected #{this} to throw error not including #{act}'\n          , errMsg\n          , message\n        );\n\n        flag(this, 'object', err);\n        return this;\n      } else {\n        thrown = true;\n        thrownError = err;\n      }\n    }\n\n    var actuallyGot = ''\n      , expectedThrown = name !== null\n        ? name\n        : desiredError\n          ? '#{exp}' //_.inspect(desiredError)\n          : 'an error';\n\n    if (thrown) {\n      actuallyGot = ' but #{act} was thrown'\n    }\n\n    this.assert(\n        thrown === true\n      , 'expected #{this} to throw ' + expectedThrown + actuallyGot\n      , 'expected #{this} to not throw ' + expectedThrown + actuallyGot\n      , (desiredError instanceof Error ? desiredError.toString() : desiredError)\n      , (thrownError instanceof Error ? thrownError.toString() : thrownError)\n    );\n\n    flag(this, 'object', thrownError);\n  };\n\n  Assertion.addMethod('throw', assertThrows);\n  Assertion.addMethod('throws', assertThrows);\n  Assertion.addMethod('Throw', assertThrows);\n\n  /**\n   * ### .respondTo(method)\n   *\n   * Asserts that the object or class target will respond to a method.\n   *\n   *     Klass.prototype.bar = function(){};\n   *     expect(Klass).to.respondTo('bar');\n   *     expect(obj).to.respondTo('bar');\n   *\n   * To check if a constructor will respond to a static function,\n   * set the `itself` flag.\n   *\n   *     Klass.baz = function(){};\n   *     expect(Klass).itself.to.respondTo('baz');\n   *\n   * @name respondTo\n   * @alias respondsTo\n   * @param {String} method\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function respondTo (method, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , itself = flag(this, 'itself')\n      , context = ('function' === _.type(obj) && !itself)\n        ? obj.prototype[method]\n        : obj[method];\n\n    this.assert(\n        'function' === typeof context\n      , 'expected #{this} to respond to ' + _.inspect(method)\n      , 'expected #{this} to not respond to ' + _.inspect(method)\n    );\n  }\n\n  Assertion.addMethod('respondTo', respondTo);\n  Assertion.addMethod('respondsTo', respondTo);\n\n  /**\n   * ### .itself\n   *\n   * Sets the `itself` flag, later used by the `respondTo` assertion.\n   *\n   *     function Foo() {}\n   *     Foo.bar = function() {}\n   *     Foo.prototype.baz = function() {}\n   *\n   *     expect(Foo).itself.to.respondTo('bar');\n   *     expect(Foo).itself.not.to.respondTo('baz');\n   *\n   * @name itself\n   * @api public\n   */\n\n  Assertion.addProperty('itself', function () {\n    flag(this, 'itself', true);\n  });\n\n  /**\n   * ### .satisfy(method)\n   *\n   * Asserts that the target passes a given truth test.\n   *\n   *     expect(1).to.satisfy(function(num) { return num > 0; });\n   *\n   * @name satisfy\n   * @alias satisfies\n   * @param {Function} matcher\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function satisfy (matcher, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    var result = matcher(obj);\n    this.assert(\n        result\n      , 'expected #{this} to satisfy ' + _.objDisplay(matcher)\n      , 'expected #{this} to not satisfy' + _.objDisplay(matcher)\n      , this.negate ? false : true\n      , result\n    );\n  }\n\n  Assertion.addMethod('satisfy', satisfy);\n  Assertion.addMethod('satisfies', satisfy);\n\n  /**\n   * ### .closeTo(expected, delta)\n   *\n   * Asserts that the target is equal `expected`, to within a +/- `delta` range.\n   *\n   *     expect(1.5).to.be.closeTo(1, 0.5);\n   *\n   * @name closeTo\n   * @alias approximately\n   * @param {Number} expected\n   * @param {Number} delta\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function closeTo(expected, delta, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n\n    new Assertion(obj, msg).is.a('number');\n    if (_.type(expected) !== 'number' || _.type(delta) !== 'number') {\n      throw new Error('the arguments to closeTo or approximately must be numbers');\n    }\n\n    this.assert(\n        Math.abs(obj - expected) <= delta\n      , 'expected #{this} to be close to ' + expected + ' +/- ' + delta\n      , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta\n    );\n  }\n\n  Assertion.addMethod('closeTo', closeTo);\n  Assertion.addMethod('approximately', closeTo);\n\n  function isSubsetOf(subset, superset, cmp) {\n    return subset.every(function(elem) {\n      if (!cmp) return superset.indexOf(elem) !== -1;\n\n      return superset.some(function(elem2) {\n        return cmp(elem, elem2);\n      });\n    })\n  }\n\n  /**\n   * ### .members(set)\n   *\n   * Asserts that the target is a superset of `set`,\n   * or that the target and `set` have the same strictly-equal (===) members.\n   * Alternately, if the `deep` flag is set, set members are compared for deep\n   * equality.\n   *\n   *     expect([1, 2, 3]).to.include.members([3, 2]);\n   *     expect([1, 2, 3]).to.not.include.members([3, 2, 8]);\n   *\n   *     expect([4, 2]).to.have.members([2, 4]);\n   *     expect([5, 2]).to.not.have.members([5, 2, 1]);\n   *\n   *     expect([{ id: 1 }]).to.deep.include.members([{ id: 1 }]);\n   *\n   * @name members\n   * @param {Array} set\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  Assertion.addMethod('members', function (subset, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n\n    new Assertion(obj).to.be.an('array');\n    new Assertion(subset).to.be.an('array');\n\n    var cmp = flag(this, 'deep') ? _.eql : undefined;\n\n    if (flag(this, 'contains')) {\n      return this.assert(\n          isSubsetOf(subset, obj, cmp)\n        , 'expected #{this} to be a superset of #{act}'\n        , 'expected #{this} to not be a superset of #{act}'\n        , obj\n        , subset\n      );\n    }\n\n    this.assert(\n        isSubsetOf(obj, subset, cmp) && isSubsetOf(subset, obj, cmp)\n        , 'expected #{this} to have the same members as #{act}'\n        , 'expected #{this} to not have the same members as #{act}'\n        , obj\n        , subset\n    );\n  });\n\n  /**\n   * ### .oneOf(list)\n   *\n   * Assert that a value appears somewhere in the top level of array `list`.\n   *\n   *     expect('a').to.be.oneOf(['a', 'b', 'c']);\n   *     expect(9).to.not.be.oneOf(['z']);\n   *     expect([3]).to.not.be.oneOf([1, 2, [3]]);\n   *\n   *     var three = [3];\n   *     // for object-types, contents are not compared\n   *     expect(three).to.not.be.oneOf([1, 2, [3]]);\n   *     // comparing references works\n   *     expect(three).to.be.oneOf([1, 2, three]);\n   *\n   * @name oneOf\n   * @param {Array<*>} list\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function oneOf (list, msg) {\n    if (msg) flag(this, 'message', msg);\n    var expected = flag(this, 'object');\n    new Assertion(list).to.be.an('array');\n\n    this.assert(\n        list.indexOf(expected) > -1\n      , 'expected #{this} to be one of #{exp}'\n      , 'expected #{this} to not be one of #{exp}'\n      , list\n      , expected\n    );\n  }\n\n  Assertion.addMethod('oneOf', oneOf);\n\n\n  /**\n   * ### .change(function)\n   *\n   * Asserts that a function changes an object property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val += 3 };\n   *     var noChangeFn = function() { return 'foo' + 'bar'; }\n   *     expect(fn).to.change(obj, 'val');\n   *     expect(noChangFn).to.not.change(obj, 'val')\n   *\n   * @name change\n   * @alias changes\n   * @alias Change\n   * @param {String} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertChanges (object, prop, msg) {\n    if (msg) flag(this, 'message', msg);\n    var fn = flag(this, 'object');\n    new Assertion(object, msg).to.have.property(prop);\n    new Assertion(fn).is.a('function');\n\n    var initial = object[prop];\n    fn();\n\n    this.assert(\n      initial !== object[prop]\n      , 'expected .' + prop + ' to change'\n      , 'expected .' + prop + ' to not change'\n    );\n  }\n\n  Assertion.addChainableMethod('change', assertChanges);\n  Assertion.addChainableMethod('changes', assertChanges);\n\n  /**\n   * ### .increase(function)\n   *\n   * Asserts that a function increases an object property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 15 };\n   *     expect(fn).to.increase(obj, 'val');\n   *\n   * @name increase\n   * @alias increases\n   * @alias Increase\n   * @param {String} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertIncreases (object, prop, msg) {\n    if (msg) flag(this, 'message', msg);\n    var fn = flag(this, 'object');\n    new Assertion(object, msg).to.have.property(prop);\n    new Assertion(fn).is.a('function');\n\n    var initial = object[prop];\n    fn();\n\n    this.assert(\n      object[prop] - initial > 0\n      , 'expected .' + prop + ' to increase'\n      , 'expected .' + prop + ' to not increase'\n    );\n  }\n\n  Assertion.addChainableMethod('increase', assertIncreases);\n  Assertion.addChainableMethod('increases', assertIncreases);\n\n  /**\n   * ### .decrease(function)\n   *\n   * Asserts that a function decreases an object property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 5 };\n   *     expect(fn).to.decrease(obj, 'val');\n   *\n   * @name decrease\n   * @alias decreases\n   * @alias Decrease\n   * @param {String} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertDecreases (object, prop, msg) {\n    if (msg) flag(this, 'message', msg);\n    var fn = flag(this, 'object');\n    new Assertion(object, msg).to.have.property(prop);\n    new Assertion(fn).is.a('function');\n\n    var initial = object[prop];\n    fn();\n\n    this.assert(\n      object[prop] - initial < 0\n      , 'expected .' + prop + ' to decrease'\n      , 'expected .' + prop + ' to not decrease'\n    );\n  }\n\n  Assertion.addChainableMethod('decrease', assertDecreases);\n  Assertion.addChainableMethod('decreases', assertDecreases);\n\n  /**\n   * ### .extensible\n   *\n   * Asserts that the target is extensible (can have new properties added to\n   * it).\n   *\n   *     var nonExtensibleObject = Object.preventExtensions({});\n   *     var sealedObject = Object.seal({});\n   *     var frozenObject = Object.freeze({});\n   *\n   *     expect({}).to.be.extensible;\n   *     expect(nonExtensibleObject).to.not.be.extensible;\n   *     expect(sealedObject).to.not.be.extensible;\n   *     expect(frozenObject).to.not.be.extensible;\n   *\n   * @name extensible\n   * @api public\n   */\n\n  Assertion.addProperty('extensible', function() {\n    var obj = flag(this, 'object');\n\n    // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.\n    // In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible\n    // The following provides ES6 behavior when a TypeError is thrown under ES5.\n\n    var isExtensible;\n\n    try {\n      isExtensible = Object.isExtensible(obj);\n    } catch (err) {\n      if (err instanceof TypeError) isExtensible = false;\n      else throw err;\n    }\n\n    this.assert(\n      isExtensible\n      , 'expected #{this} to be extensible'\n      , 'expected #{this} to not be extensible'\n    );\n  });\n\n  /**\n   * ### .sealed\n   *\n   * Asserts that the target is sealed (cannot have new properties added to it\n   * and its existing properties cannot be removed).\n   *\n   *     var sealedObject = Object.seal({});\n   *     var frozenObject = Object.freeze({});\n   *\n   *     expect(sealedObject).to.be.sealed;\n   *     expect(frozenObject).to.be.sealed;\n   *     expect({}).to.not.be.sealed;\n   *\n   * @name sealed\n   * @api public\n   */\n\n  Assertion.addProperty('sealed', function() {\n    var obj = flag(this, 'object');\n\n    // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.\n    // In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.\n    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed\n    // The following provides ES6 behavior when a TypeError is thrown under ES5.\n\n    var isSealed;\n\n    try {\n      isSealed = Object.isSealed(obj);\n    } catch (err) {\n      if (err instanceof TypeError) isSealed = true;\n      else throw err;\n    }\n\n    this.assert(\n      isSealed\n      , 'expected #{this} to be sealed'\n      , 'expected #{this} to not be sealed'\n    );\n  });\n\n  /**\n   * ### .frozen\n   *\n   * Asserts that the target is frozen (cannot have new properties added to it\n   * and its existing properties cannot be modified).\n   *\n   *     var frozenObject = Object.freeze({});\n   *\n   *     expect(frozenObject).to.be.frozen;\n   *     expect({}).to.not.be.frozen;\n   *\n   * @name frozen\n   * @api public\n   */\n\n  Assertion.addProperty('frozen', function() {\n    var obj = flag(this, 'object');\n\n    // In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError.\n    // In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.\n    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen\n    // The following provides ES6 behavior when a TypeError is thrown under ES5.\n\n    var isFrozen;\n\n    try {\n      isFrozen = Object.isFrozen(obj);\n    } catch (err) {\n      if (err instanceof TypeError) isFrozen = true;\n      else throw err;\n    }\n\n    this.assert(\n      isFrozen\n      , 'expected #{this} to be frozen'\n      , 'expected #{this} to not be frozen'\n    );\n  });\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/core/assertions.js\n ** module id = 47\n ** module chunks = 1\n **/","/*!\n * chai\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nmodule.exports = function (chai, util) {\n  chai.expect = function (val, message) {\n    return new chai.Assertion(val, message);\n  };\n\n  /**\n   * ### .fail(actual, expected, [message], [operator])\n   *\n   * Throw a failure.\n   *\n   * @name fail\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @param {String} operator\n   * @api public\n   */\n\n  chai.expect.fail = function (actual, expected, message, operator) {\n    message = message || 'expect.fail()';\n    throw new chai.AssertionError(message, {\n        actual: actual\n      , expected: expected\n      , operator: operator\n    }, chai.expect.fail);\n  };\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/interface/expect.js\n ** module id = 48\n ** module chunks = 1\n **/","/*!\n * chai\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nmodule.exports = function (chai, util) {\n  var Assertion = chai.Assertion;\n\n  function loadShould () {\n    // explicitly define this method as function as to have it's name to include as `ssfi`\n    function shouldGetter() {\n      if (this instanceof String || this instanceof Number || this instanceof Boolean ) {\n        return new Assertion(this.valueOf(), null, shouldGetter);\n      }\n      return new Assertion(this, null, shouldGetter);\n    }\n    function shouldSetter(value) {\n      // See https://github.com/chaijs/chai/issues/86: this makes\n      // `whatever.should = someValue` actually set `someValue`, which is\n      // especially useful for `global.should = require('chai').should()`.\n      //\n      // Note that we have to use [[DefineProperty]] instead of [[Put]]\n      // since otherwise we would trigger this very setter!\n      Object.defineProperty(this, 'should', {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    }\n    // modify Object.prototype to have `should`\n    Object.defineProperty(Object.prototype, 'should', {\n      set: shouldSetter\n      , get: shouldGetter\n      , configurable: true\n    });\n\n    var should = {};\n\n    /**\n     * ### .fail(actual, expected, [message], [operator])\n     *\n     * Throw a failure.\n     *\n     * @name fail\n     * @param {Mixed} actual\n     * @param {Mixed} expected\n     * @param {String} message\n     * @param {String} operator\n     * @api public\n     */\n\n    should.fail = function (actual, expected, message, operator) {\n      message = message || 'should.fail()';\n      throw new chai.AssertionError(message, {\n          actual: actual\n        , expected: expected\n        , operator: operator\n      }, should.fail);\n    };\n\n    should.equal = function (val1, val2, msg) {\n      new Assertion(val1, msg).to.equal(val2);\n    };\n\n    should.Throw = function (fn, errt, errs, msg) {\n      new Assertion(fn, msg).to.Throw(errt, errs);\n    };\n\n    should.exist = function (val, msg) {\n      new Assertion(val, msg).to.exist;\n    }\n\n    // negation\n    should.not = {}\n\n    should.not.equal = function (val1, val2, msg) {\n      new Assertion(val1, msg).to.not.equal(val2);\n    };\n\n    should.not.Throw = function (fn, errt, errs, msg) {\n      new Assertion(fn, msg).to.not.Throw(errt, errs);\n    };\n\n    should.not.exist = function (val, msg) {\n      new Assertion(val, msg).to.not.exist;\n    }\n\n    should['throw'] = should['Throw'];\n    should.not['throw'] = should.not['Throw'];\n\n    return should;\n  };\n\n  chai.should = loadShould;\n  chai.Should = loadShould;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/interface/should.js\n ** module id = 49\n ** module chunks = 1\n **/","/*!\n * chai\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n\nmodule.exports = function (chai, util) {\n\n  /*!\n   * Chai dependencies.\n   */\n\n  var Assertion = chai.Assertion\n    , flag = util.flag;\n\n  /*!\n   * Module export.\n   */\n\n  /**\n   * ### assert(expression, message)\n   *\n   * Write your own test expressions.\n   *\n   *     assert('foo' !== 'bar', 'foo is not bar');\n   *     assert(Array.isArray([]), 'empty arrays are arrays');\n   *\n   * @param {Mixed} expression to test for truthiness\n   * @param {String} message to display on error\n   * @name assert\n   * @api public\n   */\n\n  var assert = chai.assert = function (express, errmsg) {\n    var test = new Assertion(null, null, chai.assert);\n    test.assert(\n        express\n      , errmsg\n      , '[ negation message unavailable ]'\n    );\n  };\n\n  /**\n   * ### .fail(actual, expected, [message], [operator])\n   *\n   * Throw a failure. Node.js `assert` module-compatible.\n   *\n   * @name fail\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @param {String} operator\n   * @api public\n   */\n\n  assert.fail = function (actual, expected, message, operator) {\n    message = message || 'assert.fail()';\n    throw new chai.AssertionError(message, {\n        actual: actual\n      , expected: expected\n      , operator: operator\n    }, assert.fail);\n  };\n\n  /**\n   * ### .isOk(object, [message])\n   *\n   * Asserts that `object` is truthy.\n   *\n   *     assert.isOk('everything', 'everything is ok');\n   *     assert.isOk(false, 'this will fail');\n   *\n   * @name isOk\n   * @alias ok\n   * @param {Mixed} object to test\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isOk = function (val, msg) {\n    new Assertion(val, msg).is.ok;\n  };\n\n  /**\n   * ### .isNotOk(object, [message])\n   *\n   * Asserts that `object` is falsy.\n   *\n   *     assert.isNotOk('everything', 'this will fail');\n   *     assert.isNotOk(false, 'this will pass');\n   *\n   * @name isNotOk\n   * @alias notOk\n   * @param {Mixed} object to test\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotOk = function (val, msg) {\n    new Assertion(val, msg).is.not.ok;\n  };\n\n  /**\n   * ### .equal(actual, expected, [message])\n   *\n   * Asserts non-strict equality (`==`) of `actual` and `expected`.\n   *\n   *     assert.equal(3, '3', '== coerces values to strings');\n   *\n   * @name equal\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @api public\n   */\n\n  assert.equal = function (act, exp, msg) {\n    var test = new Assertion(act, msg, assert.equal);\n\n    test.assert(\n        exp == flag(test, 'object')\n      , 'expected #{this} to equal #{exp}'\n      , 'expected #{this} to not equal #{act}'\n      , exp\n      , act\n    );\n  };\n\n  /**\n   * ### .notEqual(actual, expected, [message])\n   *\n   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.\n   *\n   *     assert.notEqual(3, 4, 'these numbers are not equal');\n   *\n   * @name notEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notEqual = function (act, exp, msg) {\n    var test = new Assertion(act, msg, assert.notEqual);\n\n    test.assert(\n        exp != flag(test, 'object')\n      , 'expected #{this} to not equal #{exp}'\n      , 'expected #{this} to equal #{act}'\n      , exp\n      , act\n    );\n  };\n\n  /**\n   * ### .strictEqual(actual, expected, [message])\n   *\n   * Asserts strict equality (`===`) of `actual` and `expected`.\n   *\n   *     assert.strictEqual(true, true, 'these booleans are strictly equal');\n   *\n   * @name strictEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @api public\n   */\n\n  assert.strictEqual = function (act, exp, msg) {\n    new Assertion(act, msg).to.equal(exp);\n  };\n\n  /**\n   * ### .notStrictEqual(actual, expected, [message])\n   *\n   * Asserts strict inequality (`!==`) of `actual` and `expected`.\n   *\n   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');\n   *\n   * @name notStrictEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notStrictEqual = function (act, exp, msg) {\n    new Assertion(act, msg).to.not.equal(exp);\n  };\n\n  /**\n   * ### .deepEqual(actual, expected, [message])\n   *\n   * Asserts that `actual` is deeply equal to `expected`.\n   *\n   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });\n   *\n   * @name deepEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @api public\n   */\n\n  assert.deepEqual = function (act, exp, msg) {\n    new Assertion(act, msg).to.eql(exp);\n  };\n\n  /**\n   * ### .notDeepEqual(actual, expected, [message])\n   *\n   * Assert that `actual` is not deeply equal to `expected`.\n   *\n   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });\n   *\n   * @name notDeepEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notDeepEqual = function (act, exp, msg) {\n    new Assertion(act, msg).to.not.eql(exp);\n  };\n\n   /**\n   * ### .isAbove(valueToCheck, valueToBeAbove, [message])\n   *\n   * Asserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`\n   *\n   *     assert.isAbove(5, 2, '5 is strictly greater than 2');\n   *\n   * @name isAbove\n   * @param {Mixed} valueToCheck\n   * @param {Mixed} valueToBeAbove\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isAbove = function (val, abv, msg) {\n    new Assertion(val, msg).to.be.above(abv);\n  };\n\n   /**\n   * ### .isAtLeast(valueToCheck, valueToBeAtLeast, [message])\n   *\n   * Asserts `valueToCheck` is greater than or equal to (>=) `valueToBeAtLeast`\n   *\n   *     assert.isAtLeast(5, 2, '5 is greater or equal to 2');\n   *     assert.isAtLeast(3, 3, '3 is greater or equal to 3');\n   *\n   * @name isAtLeast\n   * @param {Mixed} valueToCheck\n   * @param {Mixed} valueToBeAtLeast\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isAtLeast = function (val, atlst, msg) {\n    new Assertion(val, msg).to.be.least(atlst);\n  };\n\n   /**\n   * ### .isBelow(valueToCheck, valueToBeBelow, [message])\n   *\n   * Asserts `valueToCheck` is strictly less than (<) `valueToBeBelow`\n   *\n   *     assert.isBelow(3, 6, '3 is strictly less than 6');\n   *\n   * @name isBelow\n   * @param {Mixed} valueToCheck\n   * @param {Mixed} valueToBeBelow\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isBelow = function (val, blw, msg) {\n    new Assertion(val, msg).to.be.below(blw);\n  };\n\n   /**\n   * ### .isAtMost(valueToCheck, valueToBeAtMost, [message])\n   *\n   * Asserts `valueToCheck` is less than or equal to (<=) `valueToBeAtMost`\n   *\n   *     assert.isAtMost(3, 6, '3 is less than or equal to 6');\n   *     assert.isAtMost(4, 4, '4 is less than or equal to 4');\n   *\n   * @name isAtMost\n   * @param {Mixed} valueToCheck\n   * @param {Mixed} valueToBeAtMost\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isAtMost = function (val, atmst, msg) {\n    new Assertion(val, msg).to.be.most(atmst);\n  };\n\n  /**\n   * ### .isTrue(value, [message])\n   *\n   * Asserts that `value` is true.\n   *\n   *     var teaServed = true;\n   *     assert.isTrue(teaServed, 'the tea has been served');\n   *\n   * @name isTrue\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isTrue = function (val, msg) {\n    new Assertion(val, msg).is['true'];\n  };\n\n  /**\n   * ### .isNotTrue(value, [message])\n   *\n   * Asserts that `value` is not true.\n   *\n   *     var tea = 'tasty chai';\n   *     assert.isNotTrue(tea, 'great, time for tea!');\n   *\n   * @name isNotTrue\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotTrue = function (val, msg) {\n    new Assertion(val, msg).to.not.equal(true);\n  };\n\n  /**\n   * ### .isFalse(value, [message])\n   *\n   * Asserts that `value` is false.\n   *\n   *     var teaServed = false;\n   *     assert.isFalse(teaServed, 'no tea yet? hmm...');\n   *\n   * @name isFalse\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isFalse = function (val, msg) {\n    new Assertion(val, msg).is['false'];\n  };\n\n  /**\n   * ### .isNotFalse(value, [message])\n   *\n   * Asserts that `value` is not false.\n   *\n   *     var tea = 'tasty chai';\n   *     assert.isNotFalse(tea, 'great, time for tea!');\n   *\n   * @name isNotFalse\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotFalse = function (val, msg) {\n    new Assertion(val, msg).to.not.equal(false);\n  };\n\n  /**\n   * ### .isNull(value, [message])\n   *\n   * Asserts that `value` is null.\n   *\n   *     assert.isNull(err, 'there was no error');\n   *\n   * @name isNull\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNull = function (val, msg) {\n    new Assertion(val, msg).to.equal(null);\n  };\n\n  /**\n   * ### .isNotNull(value, [message])\n   *\n   * Asserts that `value` is not null.\n   *\n   *     var tea = 'tasty chai';\n   *     assert.isNotNull(tea, 'great, time for tea!');\n   *\n   * @name isNotNull\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotNull = function (val, msg) {\n    new Assertion(val, msg).to.not.equal(null);\n  };\n\n  /**\n   * ### .isNaN\n   * Asserts that value is NaN\n   *\n   *    assert.isNaN('foo', 'foo is NaN');\n   *\n   * @name isNaN\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNaN = function (val, msg) {\n    new Assertion(val, msg).to.be.NaN;\n  };\n\n  /**\n   * ### .isNotNaN\n   * Asserts that value is not NaN\n   *\n   *    assert.isNotNaN(4, '4 is not NaN');\n   *\n   * @name isNotNaN\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n  assert.isNotNaN = function (val, msg) {\n    new Assertion(val, msg).not.to.be.NaN;\n  };\n\n  /**\n   * ### .isUndefined(value, [message])\n   *\n   * Asserts that `value` is `undefined`.\n   *\n   *     var tea;\n   *     assert.isUndefined(tea, 'no tea defined');\n   *\n   * @name isUndefined\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isUndefined = function (val, msg) {\n    new Assertion(val, msg).to.equal(undefined);\n  };\n\n  /**\n   * ### .isDefined(value, [message])\n   *\n   * Asserts that `value` is not `undefined`.\n   *\n   *     var tea = 'cup of chai';\n   *     assert.isDefined(tea, 'tea has been defined');\n   *\n   * @name isDefined\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isDefined = function (val, msg) {\n    new Assertion(val, msg).to.not.equal(undefined);\n  };\n\n  /**\n   * ### .isFunction(value, [message])\n   *\n   * Asserts that `value` is a function.\n   *\n   *     function serveTea() { return 'cup of tea'; };\n   *     assert.isFunction(serveTea, 'great, we can have tea now');\n   *\n   * @name isFunction\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isFunction = function (val, msg) {\n    new Assertion(val, msg).to.be.a('function');\n  };\n\n  /**\n   * ### .isNotFunction(value, [message])\n   *\n   * Asserts that `value` is _not_ a function.\n   *\n   *     var serveTea = [ 'heat', 'pour', 'sip' ];\n   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');\n   *\n   * @name isNotFunction\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotFunction = function (val, msg) {\n    new Assertion(val, msg).to.not.be.a('function');\n  };\n\n  /**\n   * ### .isObject(value, [message])\n   *\n   * Asserts that `value` is an object (as revealed by\n   * `Object.prototype.toString`).\n   *\n   *     var selection = { name: 'Chai', serve: 'with spices' };\n   *     assert.isObject(selection, 'tea selection is an object');\n   *\n   * @name isObject\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isObject = function (val, msg) {\n    new Assertion(val, msg).to.be.a('object');\n  };\n\n  /**\n   * ### .isNotObject(value, [message])\n   *\n   * Asserts that `value` is _not_ an object.\n   *\n   *     var selection = 'chai'\n   *     assert.isNotObject(selection, 'tea selection is not an object');\n   *     assert.isNotObject(null, 'null is not an object');\n   *\n   * @name isNotObject\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotObject = function (val, msg) {\n    new Assertion(val, msg).to.not.be.a('object');\n  };\n\n  /**\n   * ### .isArray(value, [message])\n   *\n   * Asserts that `value` is an array.\n   *\n   *     var menu = [ 'green', 'chai', 'oolong' ];\n   *     assert.isArray(menu, 'what kind of tea do we want?');\n   *\n   * @name isArray\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isArray = function (val, msg) {\n    new Assertion(val, msg).to.be.an('array');\n  };\n\n  /**\n   * ### .isNotArray(value, [message])\n   *\n   * Asserts that `value` is _not_ an array.\n   *\n   *     var menu = 'green|chai|oolong';\n   *     assert.isNotArray(menu, 'what kind of tea do we want?');\n   *\n   * @name isNotArray\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotArray = function (val, msg) {\n    new Assertion(val, msg).to.not.be.an('array');\n  };\n\n  /**\n   * ### .isString(value, [message])\n   *\n   * Asserts that `value` is a string.\n   *\n   *     var teaOrder = 'chai';\n   *     assert.isString(teaOrder, 'order placed');\n   *\n   * @name isString\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isString = function (val, msg) {\n    new Assertion(val, msg).to.be.a('string');\n  };\n\n  /**\n   * ### .isNotString(value, [message])\n   *\n   * Asserts that `value` is _not_ a string.\n   *\n   *     var teaOrder = 4;\n   *     assert.isNotString(teaOrder, 'order placed');\n   *\n   * @name isNotString\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotString = function (val, msg) {\n    new Assertion(val, msg).to.not.be.a('string');\n  };\n\n  /**\n   * ### .isNumber(value, [message])\n   *\n   * Asserts that `value` is a number.\n   *\n   *     var cups = 2;\n   *     assert.isNumber(cups, 'how many cups');\n   *\n   * @name isNumber\n   * @param {Number} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNumber = function (val, msg) {\n    new Assertion(val, msg).to.be.a('number');\n  };\n\n  /**\n   * ### .isNotNumber(value, [message])\n   *\n   * Asserts that `value` is _not_ a number.\n   *\n   *     var cups = '2 cups please';\n   *     assert.isNotNumber(cups, 'how many cups');\n   *\n   * @name isNotNumber\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotNumber = function (val, msg) {\n    new Assertion(val, msg).to.not.be.a('number');\n  };\n\n  /**\n   * ### .isBoolean(value, [message])\n   *\n   * Asserts that `value` is a boolean.\n   *\n   *     var teaReady = true\n   *       , teaServed = false;\n   *\n   *     assert.isBoolean(teaReady, 'is the tea ready');\n   *     assert.isBoolean(teaServed, 'has tea been served');\n   *\n   * @name isBoolean\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isBoolean = function (val, msg) {\n    new Assertion(val, msg).to.be.a('boolean');\n  };\n\n  /**\n   * ### .isNotBoolean(value, [message])\n   *\n   * Asserts that `value` is _not_ a boolean.\n   *\n   *     var teaReady = 'yep'\n   *       , teaServed = 'nope';\n   *\n   *     assert.isNotBoolean(teaReady, 'is the tea ready');\n   *     assert.isNotBoolean(teaServed, 'has tea been served');\n   *\n   * @name isNotBoolean\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotBoolean = function (val, msg) {\n    new Assertion(val, msg).to.not.be.a('boolean');\n  };\n\n  /**\n   * ### .typeOf(value, name, [message])\n   *\n   * Asserts that `value`'s type is `name`, as determined by\n   * `Object.prototype.toString`.\n   *\n   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');\n   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');\n   *     assert.typeOf('tea', 'string', 'we have a string');\n   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');\n   *     assert.typeOf(null, 'null', 'we have a null');\n   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');\n   *\n   * @name typeOf\n   * @param {Mixed} value\n   * @param {String} name\n   * @param {String} message\n   * @api public\n   */\n\n  assert.typeOf = function (val, type, msg) {\n    new Assertion(val, msg).to.be.a(type);\n  };\n\n  /**\n   * ### .notTypeOf(value, name, [message])\n   *\n   * Asserts that `value`'s type is _not_ `name`, as determined by\n   * `Object.prototype.toString`.\n   *\n   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');\n   *\n   * @name notTypeOf\n   * @param {Mixed} value\n   * @param {String} typeof name\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notTypeOf = function (val, type, msg) {\n    new Assertion(val, msg).to.not.be.a(type);\n  };\n\n  /**\n   * ### .instanceOf(object, constructor, [message])\n   *\n   * Asserts that `value` is an instance of `constructor`.\n   *\n   *     var Tea = function (name) { this.name = name; }\n   *       , chai = new Tea('chai');\n   *\n   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');\n   *\n   * @name instanceOf\n   * @param {Object} object\n   * @param {Constructor} constructor\n   * @param {String} message\n   * @api public\n   */\n\n  assert.instanceOf = function (val, type, msg) {\n    new Assertion(val, msg).to.be.instanceOf(type);\n  };\n\n  /**\n   * ### .notInstanceOf(object, constructor, [message])\n   *\n   * Asserts `value` is not an instance of `constructor`.\n   *\n   *     var Tea = function (name) { this.name = name; }\n   *       , chai = new String('chai');\n   *\n   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');\n   *\n   * @name notInstanceOf\n   * @param {Object} object\n   * @param {Constructor} constructor\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notInstanceOf = function (val, type, msg) {\n    new Assertion(val, msg).to.not.be.instanceOf(type);\n  };\n\n  /**\n   * ### .include(haystack, needle, [message])\n   *\n   * Asserts that `haystack` includes `needle`. Works\n   * for strings and arrays.\n   *\n   *     assert.include('foobar', 'bar', 'foobar contains string \"bar\"');\n   *     assert.include([ 1, 2, 3 ], 3, 'array contains value');\n   *\n   * @name include\n   * @param {Array|String} haystack\n   * @param {Mixed} needle\n   * @param {String} message\n   * @api public\n   */\n\n  assert.include = function (exp, inc, msg) {\n    new Assertion(exp, msg, assert.include).include(inc);\n  };\n\n  /**\n   * ### .notInclude(haystack, needle, [message])\n   *\n   * Asserts that `haystack` does not include `needle`. Works\n   * for strings and arrays.\n   *\n   *     assert.notInclude('foobar', 'baz', 'string not include substring');\n   *     assert.notInclude([ 1, 2, 3 ], 4, 'array not include contain value');\n   *\n   * @name notInclude\n   * @param {Array|String} haystack\n   * @param {Mixed} needle\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notInclude = function (exp, inc, msg) {\n    new Assertion(exp, msg, assert.notInclude).not.include(inc);\n  };\n\n  /**\n   * ### .match(value, regexp, [message])\n   *\n   * Asserts that `value` matches the regular expression `regexp`.\n   *\n   *     assert.match('foobar', /^foo/, 'regexp matches');\n   *\n   * @name match\n   * @param {Mixed} value\n   * @param {RegExp} regexp\n   * @param {String} message\n   * @api public\n   */\n\n  assert.match = function (exp, re, msg) {\n    new Assertion(exp, msg).to.match(re);\n  };\n\n  /**\n   * ### .notMatch(value, regexp, [message])\n   *\n   * Asserts that `value` does not match the regular expression `regexp`.\n   *\n   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');\n   *\n   * @name notMatch\n   * @param {Mixed} value\n   * @param {RegExp} regexp\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notMatch = function (exp, re, msg) {\n    new Assertion(exp, msg).to.not.match(re);\n  };\n\n  /**\n   * ### .property(object, property, [message])\n   *\n   * Asserts that `object` has a property named by `property`.\n   *\n   *     assert.property({ tea: { green: 'matcha' }}, 'tea');\n   *\n   * @name property\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @api public\n   */\n\n  assert.property = function (obj, prop, msg) {\n    new Assertion(obj, msg).to.have.property(prop);\n  };\n\n  /**\n   * ### .notProperty(object, property, [message])\n   *\n   * Asserts that `object` does _not_ have a property named by `property`.\n   *\n   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');\n   *\n   * @name notProperty\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notProperty = function (obj, prop, msg) {\n    new Assertion(obj, msg).to.not.have.property(prop);\n  };\n\n  /**\n   * ### .deepProperty(object, property, [message])\n   *\n   * Asserts that `object` has a property named by `property`, which can be a\n   * string using dot- and bracket-notation for deep reference.\n   *\n   *     assert.deepProperty({ tea: { green: 'matcha' }}, 'tea.green');\n   *\n   * @name deepProperty\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @api public\n   */\n\n  assert.deepProperty = function (obj, prop, msg) {\n    new Assertion(obj, msg).to.have.deep.property(prop);\n  };\n\n  /**\n   * ### .notDeepProperty(object, property, [message])\n   *\n   * Asserts that `object` does _not_ have a property named by `property`, which\n   * can be a string using dot- and bracket-notation for deep reference.\n   *\n   *     assert.notDeepProperty({ tea: { green: 'matcha' }}, 'tea.oolong');\n   *\n   * @name notDeepProperty\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notDeepProperty = function (obj, prop, msg) {\n    new Assertion(obj, msg).to.not.have.deep.property(prop);\n  };\n\n  /**\n   * ### .propertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a property named by `property` with value given\n   * by `value`.\n   *\n   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');\n   *\n   * @name propertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.propertyVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg).to.have.property(prop, val);\n  };\n\n  /**\n   * ### .propertyNotVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a property named by `property`, but with a value\n   * different from that given by `value`.\n   *\n   *     assert.propertyNotVal({ tea: 'is good' }, 'tea', 'is bad');\n   *\n   * @name propertyNotVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.propertyNotVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg).to.not.have.property(prop, val);\n  };\n\n  /**\n   * ### .deepPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a property named by `property` with value given\n   * by `value`. `property` can use dot- and bracket-notation for deep\n   * reference.\n   *\n   *     assert.deepPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');\n   *\n   * @name deepPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.deepPropertyVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg).to.have.deep.property(prop, val);\n  };\n\n  /**\n   * ### .deepPropertyNotVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a property named by `property`, but with a value\n   * different from that given by `value`. `property` can use dot- and\n   * bracket-notation for deep reference.\n   *\n   *     assert.deepPropertyNotVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');\n   *\n   * @name deepPropertyNotVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.deepPropertyNotVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg).to.not.have.deep.property(prop, val);\n  };\n\n  /**\n   * ### .lengthOf(object, length, [message])\n   *\n   * Asserts that `object` has a `length` property with the expected value.\n   *\n   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');\n   *     assert.lengthOf('foobar', 6, 'string has length of 6');\n   *\n   * @name lengthOf\n   * @param {Mixed} object\n   * @param {Number} length\n   * @param {String} message\n   * @api public\n   */\n\n  assert.lengthOf = function (exp, len, msg) {\n    new Assertion(exp, msg).to.have.length(len);\n  };\n\n  /**\n   * ### .throws(function, [constructor/string/regexp], [string/regexp], [message])\n   *\n   * Asserts that `function` will throw an error that is an instance of\n   * `constructor`, or alternately that it will throw an error with message\n   * matching `regexp`.\n   *\n   *     assert.throws(fn, 'function throws a reference error');\n   *     assert.throws(fn, /function throws a reference error/);\n   *     assert.throws(fn, ReferenceError);\n   *     assert.throws(fn, ReferenceError, 'function throws a reference error');\n   *     assert.throws(fn, ReferenceError, /function throws a reference error/);\n   *\n   * @name throws\n   * @alias throw\n   * @alias Throw\n   * @param {Function} function\n   * @param {ErrorConstructor} constructor\n   * @param {RegExp} regexp\n   * @param {String} message\n   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n   * @api public\n   */\n\n  assert.throws = function (fn, errt, errs, msg) {\n    if ('string' === typeof errt || errt instanceof RegExp) {\n      errs = errt;\n      errt = null;\n    }\n\n    var assertErr = new Assertion(fn, msg).to.throw(errt, errs);\n    return flag(assertErr, 'object');\n  };\n\n  /**\n   * ### .doesNotThrow(function, [constructor/regexp], [message])\n   *\n   * Asserts that `function` will _not_ throw an error that is an instance of\n   * `constructor`, or alternately that it will not throw an error with message\n   * matching `regexp`.\n   *\n   *     assert.doesNotThrow(fn, Error, 'function does not throw');\n   *\n   * @name doesNotThrow\n   * @param {Function} function\n   * @param {ErrorConstructor} constructor\n   * @param {RegExp} regexp\n   * @param {String} message\n   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n   * @api public\n   */\n\n  assert.doesNotThrow = function (fn, type, msg) {\n    if ('string' === typeof type) {\n      msg = type;\n      type = null;\n    }\n\n    new Assertion(fn, msg).to.not.Throw(type);\n  };\n\n  /**\n   * ### .operator(val1, operator, val2, [message])\n   *\n   * Compares two values using `operator`.\n   *\n   *     assert.operator(1, '<', 2, 'everything is ok');\n   *     assert.operator(1, '>', 2, 'this will fail');\n   *\n   * @name operator\n   * @param {Mixed} val1\n   * @param {String} operator\n   * @param {Mixed} val2\n   * @param {String} message\n   * @api public\n   */\n\n  assert.operator = function (val, operator, val2, msg) {\n    var ok;\n    switch(operator) {\n      case '==':\n        ok = val == val2;\n        break;\n      case '===':\n        ok = val === val2;\n        break;\n      case '>':\n        ok = val > val2;\n        break;\n      case '>=':\n        ok = val >= val2;\n        break;\n      case '<':\n        ok = val < val2;\n        break;\n      case '<=':\n        ok = val <= val2;\n        break;\n      case '!=':\n        ok = val != val2;\n        break;\n      case '!==':\n        ok = val !== val2;\n        break;\n      default:\n        throw new Error('Invalid operator \"' + operator + '\"');\n    }\n    var test = new Assertion(ok, msg);\n    test.assert(\n        true === flag(test, 'object')\n      , 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2)\n      , 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2) );\n  };\n\n  /**\n   * ### .closeTo(actual, expected, delta, [message])\n   *\n   * Asserts that the target is equal `expected`, to within a +/- `delta` range.\n   *\n   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');\n   *\n   * @name closeTo\n   * @param {Number} actual\n   * @param {Number} expected\n   * @param {Number} delta\n   * @param {String} message\n   * @api public\n   */\n\n  assert.closeTo = function (act, exp, delta, msg) {\n    new Assertion(act, msg).to.be.closeTo(exp, delta);\n  };\n\n  /**\n   * ### .approximately(actual, expected, delta, [message])\n   *\n   * Asserts that the target is equal `expected`, to within a +/- `delta` range.\n   *\n   *     assert.approximately(1.5, 1, 0.5, 'numbers are close');\n   *\n   * @name approximately\n   * @param {Number} actual\n   * @param {Number} expected\n   * @param {Number} delta\n   * @param {String} message\n   * @api public\n   */\n\n  assert.approximately = function (act, exp, delta, msg) {\n    new Assertion(act, msg).to.be.approximately(exp, delta);\n  };\n\n  /**\n   * ### .sameMembers(set1, set2, [message])\n   *\n   * Asserts that `set1` and `set2` have the same members.\n   * Order is not taken into account.\n   *\n   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');\n   *\n   * @name sameMembers\n   * @param {Array} set1\n   * @param {Array} set2\n   * @param {String} message\n   * @api public\n   */\n\n  assert.sameMembers = function (set1, set2, msg) {\n    new Assertion(set1, msg).to.have.same.members(set2);\n  }\n\n  /**\n   * ### .sameDeepMembers(set1, set2, [message])\n   *\n   * Asserts that `set1` and `set2` have the same members - using a deep equality checking.\n   * Order is not taken into account.\n   *\n   *     assert.sameDeepMembers([ {b: 3}, {a: 2}, {c: 5} ], [ {c: 5}, {b: 3}, {a: 2} ], 'same deep members');\n   *\n   * @name sameDeepMembers\n   * @param {Array} set1\n   * @param {Array} set2\n   * @param {String} message\n   * @api public\n   */\n\n  assert.sameDeepMembers = function (set1, set2, msg) {\n    new Assertion(set1, msg).to.have.same.deep.members(set2);\n  }\n\n  /**\n   * ### .includeMembers(superset, subset, [message])\n   *\n   * Asserts that `subset` is included in `superset`.\n   * Order is not taken into account.\n   *\n   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1 ], 'include members');\n   *\n   * @name includeMembers\n   * @param {Array} superset\n   * @param {Array} subset\n   * @param {String} message\n   * @api public\n   */\n\n  assert.includeMembers = function (superset, subset, msg) {\n    new Assertion(superset, msg).to.include.members(subset);\n  }\n\n  /**\n   * ### .oneOf(inList, list, [message])\n   *\n   * Asserts that non-object, non-array value `inList` appears in the flat array `list`.\n   *\n   *     assert.oneOf(1, [ 2, 1 ], 'Not found in list');\n   *\n   * @name oneOf\n   * @param {*} inList\n   * @param {Array<*>} list\n   * @param {String} message\n   * @api public\n   */\n\n  assert.oneOf = function (inList, list, msg) {\n    new Assertion(inList, msg).to.be.oneOf(list);\n  }\n\n   /**\n   * ### .changes(function, object, property)\n   *\n   * Asserts that a function changes the value of a property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 22 };\n   *     assert.changes(fn, obj, 'val');\n   *\n   * @name changes\n   * @param {Function} modifier function\n   * @param {Object} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.changes = function (fn, obj, prop) {\n    new Assertion(fn).to.change(obj, prop);\n  }\n\n   /**\n   * ### .doesNotChange(function, object, property)\n   *\n   * Asserts that a function does not changes the value of a property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { console.log('foo'); };\n   *     assert.doesNotChange(fn, obj, 'val');\n   *\n   * @name doesNotChange\n   * @param {Function} modifier function\n   * @param {Object} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.doesNotChange = function (fn, obj, prop) {\n    new Assertion(fn).to.not.change(obj, prop);\n  }\n\n   /**\n   * ### .increases(function, object, property)\n   *\n   * Asserts that a function increases an object property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 13 };\n   *     assert.increases(fn, obj, 'val');\n   *\n   * @name increases\n   * @param {Function} modifier function\n   * @param {Object} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.increases = function (fn, obj, prop) {\n    new Assertion(fn).to.increase(obj, prop);\n  }\n\n   /**\n   * ### .doesNotIncrease(function, object, property)\n   *\n   * Asserts that a function does not increase object property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 8 };\n   *     assert.doesNotIncrease(fn, obj, 'val');\n   *\n   * @name doesNotIncrease\n   * @param {Function} modifier function\n   * @param {Object} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.doesNotIncrease = function (fn, obj, prop) {\n    new Assertion(fn).to.not.increase(obj, prop);\n  }\n\n   /**\n   * ### .decreases(function, object, property)\n   *\n   * Asserts that a function decreases an object property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 5 };\n   *     assert.decreases(fn, obj, 'val');\n   *\n   * @name decreases\n   * @param {Function} modifier function\n   * @param {Object} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.decreases = function (fn, obj, prop) {\n    new Assertion(fn).to.decrease(obj, prop);\n  }\n\n   /**\n   * ### .doesNotDecrease(function, object, property)\n   *\n   * Asserts that a function does not decreases an object property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 15 };\n   *     assert.doesNotDecrease(fn, obj, 'val');\n   *\n   * @name doesNotDecrease\n   * @param {Function} modifier function\n   * @param {Object} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.doesNotDecrease = function (fn, obj, prop) {\n    new Assertion(fn).to.not.decrease(obj, prop);\n  }\n\n  /*!\n   * ### .ifError(object)\n   *\n   * Asserts if value is not a false value, and throws if it is a true value.\n   * This is added to allow for chai to be a drop-in replacement for Node's\n   * assert class.\n   *\n   *     var err = new Error('I am a custom error');\n   *     assert.ifError(err); // Rethrows err!\n   *\n   * @name ifError\n   * @param {Object} object\n   * @api public\n   */\n\n  assert.ifError = function (val) {\n    if (val) {\n      throw(val);\n    }\n  };\n\n  /**\n   * ### .isExtensible(object)\n   *\n   * Asserts that `object` is extensible (can have new properties added to it).\n   *\n   *     assert.isExtensible({});\n   *\n   * @name isExtensible\n   * @alias extensible\n   * @param {Object} object\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.isExtensible = function (obj, msg) {\n    new Assertion(obj, msg).to.be.extensible;\n  };\n\n  /**\n   * ### .isNotExtensible(object)\n   *\n   * Asserts that `object` is _not_ extensible.\n   *\n   *     var nonExtensibleObject = Object.preventExtensions({});\n   *     var sealedObject = Object.seal({});\n   *     var frozenObject = Object.freese({});\n   *\n   *     assert.isNotExtensible(nonExtensibleObject);\n   *     assert.isNotExtensible(sealedObject);\n   *     assert.isNotExtensible(frozenObject);\n   *\n   * @name isNotExtensible\n   * @alias notExtensible\n   * @param {Object} object\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.isNotExtensible = function (obj, msg) {\n    new Assertion(obj, msg).to.not.be.extensible;\n  };\n\n  /**\n   * ### .isSealed(object)\n   *\n   * Asserts that `object` is sealed (cannot have new properties added to it\n   * and its existing properties cannot be removed).\n   *\n   *     var sealedObject = Object.seal({});\n   *     var frozenObject = Object.seal({});\n   *\n   *     assert.isSealed(sealedObject);\n   *     assert.isSealed(frozenObject);\n   *\n   * @name isSealed\n   * @alias sealed\n   * @param {Object} object\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.isSealed = function (obj, msg) {\n    new Assertion(obj, msg).to.be.sealed;\n  };\n\n  /**\n   * ### .isNotSealed(object)\n   *\n   * Asserts that `object` is _not_ sealed.\n   *\n   *     assert.isNotSealed({});\n   *\n   * @name isNotSealed\n   * @alias notSealed\n   * @param {Object} object\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.isNotSealed = function (obj, msg) {\n    new Assertion(obj, msg).to.not.be.sealed;\n  };\n\n  /**\n   * ### .isFrozen(object)\n   *\n   * Asserts that `object` is frozen (cannot have new properties added to it\n   * and its existing properties cannot be modified).\n   *\n   *     var frozenObject = Object.freeze({});\n   *     assert.frozen(frozenObject);\n   *\n   * @name isFrozen\n   * @alias frozen\n   * @param {Object} object\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.isFrozen = function (obj, msg) {\n    new Assertion(obj, msg).to.be.frozen;\n  };\n\n  /**\n   * ### .isNotFrozen(object)\n   *\n   * Asserts that `object` is _not_ frozen.\n   *\n   *     assert.isNotFrozen({});\n   *\n   * @name isNotFrozen\n   * @alias notFrozen\n   * @param {Object} object\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.isNotFrozen = function (obj, msg) {\n    new Assertion(obj, msg).to.not.be.frozen;\n  };\n\n  /*!\n   * Aliases.\n   */\n\n  (function alias(name, as){\n    assert[as] = assert[name];\n    return alias;\n  })\n  ('isOk', 'ok')\n  ('isNotOk', 'notOk')\n  ('throws', 'throw')\n  ('throws', 'Throw')\n  ('isExtensible', 'extensible')\n  ('isNotExtensible', 'notExtensible')\n  ('isSealed', 'sealed')\n  ('isNotSealed', 'notSealed')\n  ('isFrozen', 'frozen')\n  ('isNotFrozen', 'notFrozen');\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/chai/lib/chai/interface/assert.js\n ** module id = 50\n ** module chunks = 1\n **/","import { DEV_HOST, PROD_HOST, HOST_URL } from '../src/vars.js';\nimport { isDev } from '../src/utils.js';\n\nexport var APP_ID = isDev() ? '33b3562a-d33b-42ee-88bc-1436e780311f' : '7b6053e0-9911-4003-a0a4-a33e417ad663';\nexport var PLAYER_ID = isDev() ? 'b3481557-521d-4d01-be72-acf2c3f46eff' : '15b23511-e0cf-489a-8682-7cf129cb4585';\n\n\n/** WEBPACK FOOTER **\n ** ./test/vars.js\n **/","module.exports = require('./lib/type');\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/type-detect/index.js\n ** module id = 17\n ** module chunks = 1\n **/"],"sourceRoot":""}